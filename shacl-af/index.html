<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
  	<head>
    	<title>SHACL Advanced Features</title>
		<meta charset="utf-8">
    	<script src='https://www.w3.org/Tools/respec/respec-w3c-common' async="async" class='remove'></script>
    	<script class='remove'>
	
			var prepareSyntaxRules = function() {
				$("[data-syntax-rule]").each(function(index, element) {
					var ruleId = $(element).attr("data-syntax-rule");
					var tr = $("<tr class=\"syntax-rule-tr\"><td class=\#syntax-rule-id\"><a class=\"syntax-rule-id-a\" href=\"#syntax-rule-" + ruleId + "\">" + ruleId + "</a></td><td>" + $(element).html() + "</td></tr>");
					tr.find("dfn").replaceWith(function(el) { return $("<a>" + $(this).text() + "</a>"); });
					$("#syntax-rules-table").append(tr);
					$(element).attr("id", "syntax-rule-" + ruleId);
				});
			};
		
			var respecConfig = {
			
				localBiblio: {
					"shacl-js": {
						title: "SHACL JavaScript Extensions",
						authors: [ "Holger Knublauch", "Pano Maria" ],
						href: "https://www.w3.org/TR/shacl-js/",
						status: "WG-NOTE",
						publisher: "W3C"
					}
				},
			
				specStatus: "FPWD-NOTE",
				preProcess : [ prepareSyntaxRules ],
				edDraftURI: "https://w3c.github.io/data-shapes/shacl-af/",
				shortName:  "shacl-af",
				editors: [
					{
						name:       "Holger Knublauch",
						url:        "http://knublauch.com/",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/",
						w3cid:      46500
					},
					{
						name:       "Dean Allemang",
						url:        "http://workingontologist.com",
						company:    "Working Ontologist LLC.",
						companyURL: "http://workingontologist.com"
					},
					{   
						name:       "Simon Steyskal",
			         	url:        "http://steyskal.info/",
			         	company:    "WU Vienna/Siemens AG",
			         	w3cid: 	73545 
					}
				],
				publishDate: "2017-05-30",
				wg: "RDF Data Shapes Working Group",
				wgURI: "https://www.w3.org/2014/data-shapes/",
				wgPublicList: "public-rdf-shapes",
				wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/73865/status",
				noHighlightCSS: true
			};
	    </script>
 		<style>

			pre {
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
				word-wrap: normal;
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			td {
				vertical-align: top;
			}
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
			}
			
			.def-sparql {
			}
			
			.def-sparql-body {
				margin-top: 0px;
				margin-bottom: 0px;
			}
			
			.def-text {
			}
			
			.def-text-body {
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.diagram-class {
				border: 1px solid black; 
				border-radius: 4px; 
				width: 360px;
			}
			
			.diagram-class-name {
				font-size: 16px; 
				font-weight: bold; 
				text-align: center;
			}
			
			.diagram-class-properties {
				border-top: 1px solid black; 
			}
			
			.diagram-class-properties-start {
				padding: 8px;
			}
			
			.diagram-class-properties-section {
				border-top: 1px dashed #808080;
				padding: 8px;
			}
			
			.focus-node-selected {
				color: blue;
			}
			.focus-node-error {
				color: red;
			}

			.triple-can-be-skipped {
				color: grey;
			}
			.focus-node-error {
				color: red;
			}

			.target-can-be-skipped {
				color: darkslategray;
				font-style: italic;
			}
			
			.component-class {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameter-context {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameters {
				font-weight: bold;
				font-size: 16px;
			}

			.part-header {
				font-weight: bold;
			}
			
			.syntax {
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #d0d0d0;
				margin-bottom: 16px;
				padding: .5em 1em;
				background-color: #f6f6f6;
			}
			
			.syntax-rule-id {
				padding-right: 10px;
			}
			
			.syntax-rule-id-a {
				white-space: nowrap;
			}
			
			.validator-id-a {
				font-weight: bold;
				white-space: nowrap;
			}
		
			.term {
				font-style: italic;
			}
			
			.term-def-header {
				font-style: italic;
				font-weight: bold;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}

			.term-table td, th {
				border-width: 1px;
				border-style: solid;
				padding: 5px;
			}
		
			.todo {
				color: red;
			}

			/* example pre taken / adapted from R2RML */
			pre.example-shapes, pre.example-data, pre.example-results, pre.example-other, pre.example-sparql { margin-left: 0; padding: 0 2em; margin-top: 1.5em; padding: 1em; white-space: pre !important; }
			pre.example-shapes:before, pre.example-data:before, pre.example-results:before, pre.example-other:before, pre.example-sparql:before { background: white; display: block; font-family: sans-serif; margin: -1em 0 0.4em -1em; padding: 0.2em 1em; }
			pre.example-shapes { background: #deb; }
			pre.example-shapes, pre.example-shapes:before { border: 1px solid #bbb; }
			pre.example-shapes:before { color: #888; content: "Example shapes graph"; width: 13em; }
			pre.example-data { background: #eeb; }
			pre.example-data, pre.example-data:before { border: 1px solid #cc9; }
			pre.example-data:before { color: #996; content: "Example data graph"; width: 13em; }
			pre.example-results:before { color: #797; content: "Example validation results"; width: 13em; }
			pre.example-other { background: #bed; }
			pre.example-other, pre.example-other:before { border: 1px solid #ddd; }
			pre.example-other:before { color: #888; content: "Example"; width: 13em; }
			pre.example-sparql { background: #bed; }
			pre.example-sparql, pre.example-sparql:before { border: 1px solid #ddd; }
			pre.example-sparql:before { color: #888; content: "Example SPARQL"; width: 13em; }
			.example-results { background: #edb; }
			.example-results, .example-results:before, .example-results th, .example-results td { border: 1px solid #cca; }

			/* our syntax menu for switching */
			div.syntaxmenu {
				border: 1px dotted black;
				padding:0.5em;
				margin: 1em; 
			}

			@media print {
				div.syntaxmenu { display:none; }
			}
		</style>
	</head>
	<body>

		<section id='abstract'>
			This document describes advanced features of the Shapes Constraint Language (SHACL) [[!shacl]]
			including features to define custom targets, annotation properties, user-defined functions,
			node expressions and rules.
			While many of these features rely on SPARQL, they also define extension points
			that can be used by other implementation languages.
		</section>

		<section id='sotd'>
			<p>
				Future revisions of this document may be produced by a SHACL W3C Community Group.
			</p>
		</section>
				
		<section class="introductory">
			<h2>Document Conventions</h2>
			<p>
				Some examples in this document use Turtle [[!turtle]].
				The reader is expected to be familiar with SHACL [[!shacl]] and SPARQL [[!sparql11-query]].
			</p>
			<p>
				Within this document, the following namespace prefix bindings are used:
			</p>
			<table class="term-table">
				<tr>
					<th>Prefix</th>
					<th>Namespace</th>
				</tr>
				<tr>
					<td><code>rdf:</code></td>
					<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
				</tr>
				<tr>
					<td><code>rdfs:</code></td>
					<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
				</tr>
				<tr>
					<td><code>sh:</code></td>
					<td><code>http://www.w3.org/ns/shacl#</code></td>
				</tr>
				<tr>
					<td><code>xsd:</code></td>
					<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
				</tr>
				<tr>
					<td><code>ex:</code></td>
					<td><code>http://example.com/ns#</code></td>
				</tr>
			</table>
			<p>
				Throughout the document, color-coded boxes containing RDF graphs in Turtle will appear.
				These fragments of Turtle documents use the prefix bindings given above.
			</p>
			<pre class="example-shapes">
# This box represents a shapes graph
&lt;s&gt; &lt;p&gt; &lt;o&gt; .</pre>

			<pre class="example-js">
// This box contains JavaScript code</pre>

			<pre class="example-data">
# This box represents a data graph.</pre>

			<pre class="example-results">
# This box represents an output results graph</pre>

			<p>
				Formal definitions appear in blue boxes:
			</p>
			<div class="def def-sparql">
				<div class="def-header">TEXTUAL DEFINITIONS</div>
<pre class="def-sparql-body">
# This box contains textual definitions. </pre>
			</div>
				
			<p class="syntax">
				Grey boxes such as this include syntax rules that apply to the shapes graph.
			</p>
				
			<p>
				<code>true</code> denotes the RDF term <code>"true"^^xsd:boolean</code>.
				<code>false</code> denotes the RDF term <code>"false"^^xsd:boolean</code>.
			</p>
		</section>
		
		<section class="introductory">
			<h2>Terminology</h2>
			<p>
				The terminology used throughout this document is consistent with the definitions in the
				main SHACL [[!shacl]] specification, which references terms from RDF [[!rdf11-concepts]].
				This includes the terms
				<dfn data-lt="bindings"><a href="https://www.w3.org/TR/shacl/#dfn-binding">binding</a></dfn>,
				<dfn data-lt="blank nodes"><a href="https://www.w3.org/TR/shacl/#dfn-blank-node">blank node</a></dfn>,
				<dfn data-lt="conform|conforms"><a href="https://www.w3.org/TR/shacl/#dfn-conforms">conformance</a></dfn>,
				<dfn data-lt="constraints"><a href="https://www.w3.org/TR/shacl/#dfn-constraint">constraint</a></dfn>,
				<dfn data-lt="constraint components"><a href="https://www.w3.org/TR/shacl/#dfn-constraint-component">constraint component</a></dfn>,
				<dfn data-lt="data graphs"><a href="https://www.w3.org/TR/shacl/#dfn-data-graph">data graph</a></dfn>,
				<dfn data-lt="datatypes"><a href="https://www.w3.org/TR/shacl/#dfn-datatype">datatype</a></dfn>,
				<dfn data-lt="failures"><a href="https://www.w3.org/TR/shacl/#dfn-failure">failure</a></dfn>,
				<dfn data-lt="focus nodes"><a href="https://www.w3.org/TR/shacl/#dfn-focus-node">focus node</a></dfn>,
				<dfn data-lt="RDF graphs|graphs|graph"><a href="https://www.w3.org/TR/shacl/#dfn-rdf-graph">RDF graph</a></dfn>,
				<dfn><a href="https://www.w3.org/TR/shacl/#dfn-ill-formed">ill-formed</a></dfn>,
				<dfn data-lt="IRIs"><a href="https://www.w3.org/TR/shacl/#dfn-iri">IRI</a></dfn>,
				<dfn data-lt="literals"><a href="https://www.w3.org/TR/shacl/#dfn-literal">literal</a></dfn>,
				<dfn data-lt="local names"><a href="https://www.w3.org/TR/shacl/#dfn-local-name">local name</a></dfn>,
				<dfn data-lt="members"><a href="https://www.w3.org/TR/shacl/#dfn-members">member</a></dfn>,
				<dfn data-lt="nodes|RDF node"><a href="https://www.w3.org/TR/shacl/#dfn-node">node</a></dfn>,
				<dfn data-lt="node shapes"><a href="https://www.w3.org/TR/shacl/#dfn-node-shape">node shape</a></dfn>,
				<dfn data-lt="objects"><a href="https://www.w3.org/TR/shacl/#dfn-object">object</a></dfn>,
				<dfn data-lt="parameters"><a href="https://www.w3.org/TR/shacl/#dfn-parameters">parameter</a></dfn>,
				<dfn data-lt="pre-bind|pre-bound"><a href="https://www.w3.org/TR/shacl/#pre-binding">pre-binding</a></dfn>,
				<dfn data-lt="predicates"><a href="https://www.w3.org/TR/shacl/#dfn-predicate">predicate</a></dfn>,
				<dfn data-lt="property paths"><a href="https://www.w3.org/TR/shacl/#dfn-shacl-property-path">property path</a></dfn>,
				<dfn data-lt="property shapes"><a href="https://www.w3.org/TR/shacl/#dfn-property-shape">property shape</a></dfn>,
				<dfn data-lt="RDF terms|terms|term"><a href="https://www.w3.org/TR/shacl/#dfn-rdf-term">RDF term</a></dfn>,
				<dfn data-lt="SHACL instances"><a href="https://www.w3.org/TR/shacl/#dfn-shacl-instance">SHACL instance</a></dfn>,
				<dfn data-lt="SHACL lists"><a href="https://www.w3.org/TR/shacl/#dfn-shacl-list">SHACL list</a></dfn>,
				<dfn data-lt="SHACL subclasses"><a href="https://www.w3.org/TR/shacl/#dfn-shacl-subclass">SHACL subclass</a></dfn>,
				<dfn data-lt="shapes"><a href="https://www.w3.org/TR/shacl/#dfn-shape">shape</a></dfn>,
				<dfn data-lt="shapes graphs"><a href="https://www.w3.org/TR/shacl/#dfn-shapes-graph">shapes graph</a></dfn>,
				<dfn data-lt="solutions"><a href="https://www.w3.org/TR/shacl/#dfn-solution">solution</a></dfn>,
				<dfn data-lt="subjects"><a href="https://www.w3.org/TR/shacl/#dfn-subject">subject</a></dfn>,
				<dfn data-lt="targets"><a href="https://www.w3.org/TR/shacl/#dfn-target">target</a></dfn>,
				<dfn data-lt="triples"><a href="https://www.w3.org/TR/shacl/#dfn-rdf-triple">triple</a></dfn>,
				<dfn><a href="https://www.w3.org/TR/shacl/#dfn-validation">validation</a></dfn>,
				<dfn data-lt="validation reports"><a href="https://www.w3.org/TR/shacl/#dfn-validation-report">validation report</a></dfn>,
				<dfn data-lt="validation results"><a href="https://www.w3.org/TR/shacl/#dfn-validation-results">validation result</a></dfn>,
				<dfn data-lt="validators"><a href="https://www.w3.org/TR/shacl/#dfn-validators">validator</a></dfn>,
				<dfn data-lt="values"><a href="https://www.w3.org/TR/shacl/#dfn-value">value</a></dfn>,
				<dfn data-lt="value nodes"><a href="https://www.w3.org/TR/shacl/#dfn-value-nodes">value node</a></dfn>.
			</p>
		</section>

		<section id="intro">
			<h2>Introduction</h2>
			<p>
				The SHACL specification [[!shacl]] is divided into SHACL Core and SHACL-SPARQL:
			</p>
			<ul>	  
				<li>
					<strong>SHACL Core</strong> consists of frequently needed features for the representation of <a>shapes</a>,
					<a>constraints</a> and <a>targets</a>.
				</li> 
				<li>
					<strong>SHACL-SPARQL</strong> consists of all features of SHACL Core plus the expressive power of
					SPARQL-based <a>constraints</a> and an extension mechanism to declare new <a>constraint components</a>.
				</li>
			</ul>
	 		<p>
	 			This document extends the functionality of SHACL by defining RDF vocabularies to cover the following features:
	 		</p>
	 		<ul>
	 			<li><b><a>Custom Targets</a></b> - add flexibility to selecting the <a>focus nodes</a> of <a>shapes</a></li>
	 			<li><b><a>Annotation Properties</a></b> - can create extra values in validation reports</li>
	 			<li><b><a>SHACL Functions</a></b> - encapsulate complex operations into reusable building blocks</li>
	 			<li><b><a>Node Expressions</a></b> - describe how to derive sets of <a>nodes</a></li>
	 			<li><b><a>Expression Constraints</a></b> - enable constraint checks based on node expressions</li>
	 			<li><b><a>SHACL Rules</a></b> - enable deriving new <a>triples</a> from existing ones</li>
	 		</ul>
	 		<p>
	 			Taken together or individually, these features greatly extend the application scenarios of SHACL, and
	 			SHACL-SPARQL in particular.
	 		</p>
		</section>

		<section id="conformance">
	 		<p>
	 			Some of the features presented here (including <a>node expressions</a>, <a>expression constraints</a>
	 			and <a>triple rules</a>) do not necessarily require a SPARQL processor and could be used as extensions of
	 			pure SHACL Core implementations.
	 			Other features (including <a href="#SPARQLTargetType">custom target types</a>, <a>SHACL functions</a>,
	 			and general <a>SHACL rules</a>) define extension mechanisms that can also be used with other languages
	 			than SPARQL, such as JavaScript (as defined by the SHACL-JS document [[shacl-js]]).
	 		</p>
			<p>
				A SHACL-SPARQL processor that also supports all features defined in this document and is called
				an <dfn>Advanced SHACL-SPARQL</dfn> processor.
			</p>
		</section>		

		<section id="targets">
			<h2>Custom Targets</h2>
			<p>
				In general, <a>targets</a> define a mechanism that is used by SHACL engines to determine the <a>focus nodes</a>
				that should be validated against a given <a>shape</a>.
				SHACL Core [[!shacl]] defines a fixed set of Core <a>targets</a> by means of properties such as <code>sh:targetClass</code>.
				These Core targets were designed to cover a large number of use cases while retaining a simple declarative data model.
				However, in some use cases, these Core targets are not sufficient. For example it is impossible to state that
				a shape should apply only to a subset of instances of a class, e.g. persons born in the USA.
				Neither is it possible to state that a shape should apply to all subjects in a graph, or to nodes selected by completely
				different, application-specific mechanisms.
			</p>
			<p>
				This section defines richer mechanisms to define <a>targets</a>, called <dfn data-lt="custom target">custom targets</dfn>.
				Custom targets are the <a>values</a> of the property <code>sh:target</code> in the <a>shapes graph</a>.
				The property <code>sh:target</code> has a similar status as, for example, <code>sh:targetClass</code>,
				and all <a>subjects</a> of <code>sh:target</code> <a>triples</a> are also <a>shapes</a>.
			</p>
			<p class="syntax">
				<span data-syntax-rule="target-nodeKind">The <a>values</a> of <code>sh:target</code> at a <a>shape</a> are
				<a>IRIs</a> or <a>blank nodes</a>.</span>
			</p>
			<p>
				A SHACL engine that supports <a>custom targets</a> uses the <a>values</a> of the <a>custom target</a> node
				to compute the target nodes for the associated <a>shape</a>.
				The algorithm that is used for this computation depends on the <code>rdf:type</code> of the <a>custom target</a>.
				The following sub-sections define two such algorithms:
			</p>
			<ul>
				<li><a>SPARQL-based targets</a></li>
				<li><a>SPARQL-based target types</a></li>
			</ul>
			<p>
				However, other types of targets can be supported by other extension languages such as JavaScript.
				The class <code>sh:Target</code> is the recommended base class for such extensions.
			</p>
			<p>
				The behavior of a SHACL engine that is unable to handle a given <a>custom target</a> is left undefined.
				SHACL Core processors do not even need to be aware of the existence of the <code>sh:target</code> property.
				Engines that are aware of this property and cannot handle a given <a>custom target</a> SHOULD at least report a warning.
			</p>
			<section id="SPARQLTarget">
				<h3>SPARQL-based Targets</h3>
				<p>
					<a>Custom targets</a> that are <a>SHACL instances</a> of <code>sh:SPARQLTarget</code> are called
					<dfn data-lt="SPARQL-based target">SPARQL-based targets</dfn>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="SPARQLTarget-select-count"><a>SPARQL-based targets</a> have exactly one <a>value</a> for the property <code>sh:select</code>.</span>
					<span data-syntax-rule="SPARQLTarget-prefixes-nodeKind"><a>SPARQL-based targets</a> may have <a>values</a> for the property <code>sh:prefixes</code>
					and these values are <a>IRIs</a> or <a>blank nodes</a>.</span>
					<span data-syntax-rule="SPARQLTarget-select-sparql">Using the <a>values</a> of <code>sh:prefixes</code> as defined by
					<a href="https://www.w3.org/TR/shacl/#sparql-prefixes">5.2.1 Prefix Declarations for SPARQL Queries</a>,
					the <a>values</a> of <code>sh:select</code> must be valid SPARQL 1.1 SELECT queries with a single result variable <code>this</code>.</span>
					<span data-syntax-rule="SPARQLTarget-ask-count"><a>SPARQL-based targets</a> have at most one <a>value</a> for the property <code>sh:ask</code>.</span>
				</p>
				<p>
					The following example declares a well-formed SPARQL-based target that produces all persons born in the USA:
				</p>
				<pre class="example-shapes" title="SPARQL-based target example">
ex:
	sh:declare [
		sh:prefix &quot;ex&quot; ;
		sh:namespace &lt;http://example.com/ns#&gt; ;
	] .
				
ex:USCitizenShape
	a sh:NodeShape ;
	sh:target [
		a sh:SPARQLTarget ;
		sh:prefixes ex: ;
		sh:select """
			SELECT ?this
			WHERE {
				?this a ex:Person .
				?this ex:bornIn ex:USA .
			}
			""" ;
	] ;
	...</pre>
				<div class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						Let <code>Q</code> be the SPARQL SELECT query derived from the <a>values</a> of <code>sh:select</code>
						and <code>sh:prefixes</code> of the <a>SPARQL-based target</a> <code>T</code>.
						The <a>target</a> nodes of <code>T</code> are the <a>bindings</a> of the variable <code>this</code> returned
						by <code>Q</code> against the <a>data graph</a>.
					</div>
				</div>
				<p>
					While the SELECT queries can be used to identify all <a>focus nodes</a> for a given <a>shape</a>, SHACL processors sometimes
					also need to compute the inverse direction and find all <a>shapes</a> for which a given <a>node</a> needs to be validated against.
					For this reason, the following semantic restriction is recommended for SELECT queries used in SPARQL-based targets.
					Informally, SHACL Full processors should be able to derive an equivalent ASK query from the SELECT query,
					<a>pre-bind</a> the potential <a>focus node</a>,
					and check whether the potential focus node needs to be validated against the <a>shape</a> that has the given target.
					Formally, let <code>A</code> be a SPARQL ASK query that is produced by replacing the <a href="https://www.w3.org/TR/sparql11-query/#rSelectClause">SelectClause</a>
					with <code>ASK</code> in the outermost SELECT query.
					Let <code>rs</code> be the set of RDF terms returned as <a>bindings</a> for the variable <code>this</code> in the <a>solutions</a> of the SELECT query.
					Then <code>A</code> returns <code>true</code> if and only if the variable <code>this</code> is <a>pre-bound</a> with a value from <code>rs</code>.
					If the SELECT query of a SPARQL-based target does not fulfill this requirement, it needs to be accompanied
					by a SPARQL ASK query as the value for <code>sh:ask</code>.
					A SHACL engine can then determine whether a given <a>shape</a> applies to a given <a>node</a> by executing the ASK
					query with the variable <code>this</code> <a>pre-bound</a> to the <a>node</a>.
					If the ASK query evaluates to <code>true</code> then the <a>node</a> is in the target of the <a>shape</a>.
				</p>
			</section>
			<section id="SPARQLTargetType">
				<h3>SPARQL-based Target Types</h3>
				<p>
					In some cases it would be too repetitive to declare SPARQL-based targets with similar SPARQL queries that only differ
					in a few aspects.
					SHACL-SPARQL defines a mechanism for user-defined <a>constraint components</a>, allowing users to reuse the same
					SPARQL query in a parameterized form.
					The SPARQL-based target types introduced in this section follow a similar design.
				</p>
				<p>
					The class <code>sh:TargetType</code> can be used to declare high-level vocabularies for targets in a <a>shapes graph</a>.
					The class <code>sh:SPARQLTargetType</code> is declared as <code>rdfs:subClassOf sh:TargetType</code> for
					<dfn>SPARQL-based target types</dfn>.
					Other extension languages may define alternative execution instructions for target types with the same IRI,
					making them potentially more platform independent than pure <a>SPARQL-based targets</a>.
					Instances of the class <code>sh:SPARQLTargetType</code> specify a SPARQL SELECT query via the property <code>sh:select</code>,
					and this query has to fulfill the same syntactic and semantic rules as <a href="#SPARQLTarget">SPARQL-based targets</a>.
				</p>
				<p>
					Similar to SPARQL-based <a>constraint components</a>, such targets take <a>parameters</a> and
					the parameter values become <a>pre-bound</a> variables in the associated SPARQL queries.
					The parameter values of such targets cannot not be blank nodes, and the same target cannot have more than one value per parameter.
					A target that lacks a <a>value</a> for a non-optional parameter is ignored, producing no target nodes.
					Similar to SPARQL-based <a>constraint components</a>, target types may also have values for the property <code>sh:labelTemplate</code>.
				</p>
				<p>
					The following example declares a new SPARQL-based target type that takes one parameter <code>ex:country</code>
					that gets mapped into the variable <code>country</code> in the corresponding SPARQL query to determine the resulting target nodes.
				</p>
				<pre class="example-shapes">
ex:PeopleBornInCountryTarget
	a sh:SPARQLTargetType ;
	rdfs:subClassOf sh:Target ;
	sh:labelTemplate "All persons born in {$country}" ;
	sh:parameter [
		sh:path ex:country ;
		sh:description "The country that the focus nodes are 'born' in." ;
		sh:class ex:Country ;
		sh:nodeKind sh:IRI ;
	] ;
	sh:prefixes ex: ;
	sh:select """
		SELECT ?this
		WHERE {
			?this a ex:Person .
			?this ex:bornIn $country .
		}
		""" .</pre>
				<p>
					Once such a target type has been defined in a <a>shapes graph</a>, it can be used by multiple shapes:
				</p>
				<pre class="example-shapes">
ex:GermanCitizenShape
	a sh:NodeShape ;
	sh:target [
		a ex:BornInCountryTarget ;
		ex:country ex:Germany ;
	] ;
	...
	
ex:USCitizenShape
	a sh:NodeShape ;
	sh:target [
		a ex:BornInCountryTarget ;
		ex:country ex:USA ;
	] ;
	...</pre>
				<p>
					The set of focus nodes produced by such a target type consists of all bindings of the variable <code>this</code> in the result set,
					when the SPARQL SELECT query has been executed with the <a>pre-bound</a> parameter values.
				</p>
			</section>
		</section>
		
		<section id="sparql-constraints-annotations">
			<h2>Annotation Properties</h2>
			<p>
				This section extends the general <a href="https://www.w3.org/TR/shacl/#sparql-constraints-variables">mechanism from SHACL-SPARQL</a>
				[[!shacl]] to produce <a>validation reports</a> as a result of the <a>validation</a>.
			</p>
			<p>
				Implementations that support this feature make it possible to inject so-called <dfn>annotation properties</dfn>
				into the validation result nodes created for each <a>solution</a> produced by the SELECT queries of a
				SPARQL-based <a>constraint</a> or <a>constraint component</a>.
				Any such annotation property needs to be declared via a <a>value</a> of <code>sh:resultAnnotation</code> at
				the <a>subject</a> of the <code>sh:select</code> or <code>sh:ask</code> <a>triple</a>.
			</p>
			<p class="syntax">
				<span data-syntax-rule="resultAnnotation-nodeKind">The <a>values</a> of <code>sh:resultAnnotation</code> are
				called <dfn data-lt="result annotation">result annotations</dfn> and are either <a>IRIs</a> or <a>blank nodes</a></span>.
			</p>
			<p>
				<a>Result annotations</a> have the following properties:
			</p>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Summary and Syntax Rules</th>
				</tr>
				<tr>
					<td><code>sh:annotationProperty</code></td>
					<td>
						The property that shall be set.
						<span data-syntax-rule="annotationProperty">Each <a>result annotation</a> has exactly one <a>value</a>
						for the property <code>sh:annotationProperty</code> and this value is an <a>IRI</a>.</span>
					</td>
				</tr>
				<tr>
					<td><code>sh:annotationVarName</code></td>
					<td>
						The name of the SPARQL variable to take the annotation values from.
						<span data-syntax-rule="annotationVarName">Each <a>result annotation</a> has at most 1 <a>value</a>
						for the property <code>sh:annotationVarName</code> and this <a>value</a> is <a>literal</a> with
						<a>datatype</a> <code>xsd:string</code>.</span>
					</td>
				</tr>
				<tr>
					<td><code>sh:annotationValue</code></td>
					<td>
						Constant <a>RDF terms</a> that shall be used as default values.
					</td>
				</tr>
			</table>
			<p>
				For each <a>solution</a> of a SELECT result set, a SHACL processor that supports annotations
				walks through the declared result annotations.
				The mapping from result annotations to SPARQL variables uses the following rules:
			</p>
			<ol>
				<li>Use the <a>value</a> of the property <code>sh:annotationVarName</code></li>
				<li>If no such <a>value</a> exists, use the <a>local name</a> of the <a>value</a> of <code>sh:annotationProperty</code> 
				as the variable name</li>
			</ol>
			<p>
				If a variable name could be determined, then the SHACL processor copies the <a>binding</a> for the given variable
				as a value for the property specified using <code>sh:annotationProperty</code> 
				into the validation result that is being produced for the current <a>solution</a>.
				If the variable has no <a>binding</a> in the result set <a>solution</a>,
				then the <a>values</a> of <code>sh:annotationValue</code> is used, if present.
			</p>
			<p>
				Here is an example illustrating the use of result annotations.
			</p>
			<pre class="example-shapes">
ex:AnnotationExample
	a sh:NodeShape ;
	sh:targetNode ex:ExampleResource ;
	sh:sparql [   # _:b1
		sh:resultAnnotation [
			sh:annotationProperty ex:time ;
			sh:annotationVarName "time" ;
		] ;
		sh:select """
			SELECT $this ?message ?time
			WHERE {
				BIND (CONCAT("The ", "message.") AS ?message) .
				BIND (NOW() AS ?time) .
			}
			""" ;
	] .</pre>
			<p>
				Validation produces the following validation report:
			</p>
			<pre class="example-results">
[	a sh:ValidationReport ;
	sh:conforms false ;
	sh:result [
		a sh:ValidationResult ;
		sh:focusNode ex:ExampleResource ;
		sh:resultMessage "The message." ;
		sh:resultSeverity sh:Violation ;
		sh:sourceConstraint _:b1 ;
		sh:sourceConstraintComponent sh:SPARQLConstraintComponent ;
		sh:sourceShape ex:AnnotationExample ;
		ex:time "2015-03-27T10:58:00"^^xsd:dateTime ;  # Example
	]
] .</pre>
		</section>
		
		<section id="functions">
			<h2>SHACL Functions</h2>
			<p>
				<dfn data-lt="function|functions|SHACL function">SHACL functions</dfn> declare operations that produce an <a>RDF term</a>
				based on zero or more <a>parameters</a> and a <a>data graph</a>.
				Each SHACL function has an <a>IRI</a>.
				The actual execution logic (or algorithm) of a SHACL function can be declared in a variety of execution languages.
				This document defines one specific kind of SHACL functions, the <a>SPARQL-based functions</a>.
				JavaScript-based Functions are defined in the separate SHACL-JS document [[shacl-js]].
				The same function <a>IRI</a> can potentially be executed on a multitude of platforms, if it declares
				execution instructions for these platforms.
			</p>
			<p>
				SHACL functions can be called within FILTER or BIND clauses and similar features of SPARQL queries.
				SHACL functions can also be used declaratively in frameworks such as the SHACL <a>node expressions</a>
				which are used in <a>SHACL rules</a>.
				In those scenarios they may be used to perform data transformations such as string concatenation.
			</p>
			<section id="functions-example">
				<h3>An Example SHACL Function</h3>
				<p>
					The following example illustrates the declaration of a SHACL function based on a simple mathematical SPARQL query.
				</p>
				<pre class="example-shapes" title="SHACL function with a SPARQL body">
ex:multiply
	a sh:SPARQLFunction ;
	rdfs:comment "Multiplies its two arguments $op1 and $op2." ;
	sh:parameter [
		sh:path ex:op1 ;
		sh:datatype xsd:integer ;
		sh:description "The first operand" ;
	] ;
	sh:parameter [
		sh:path ex:op2 ;
		sh:datatype xsd:integer ;
		sh:description "The second operand" ;
	] ;
	sh:returnType xsd:integer ;
	sh:select """
		SELECT ($op1 * $op2 AS ?result)
		WHERE {
		}
		""" .</pre>
				<p>
					Using the declaration above, SPARQL engines that support SHACL functions install a new SPARQL function based on the
					SPARQL 1.1 <a href="http://www.w3.org/TR/sparql11-query/#extensionFunctions">Extensible Value Testing</a> mechanism.
					Such engines are then able to handle expressions such as <code>ex:multiply(7, 8)</code>, producing <code>56</code>,
					as illustrated in the following SPARQL query.
				</p>
				<pre class="example-other" title="Call of a SHACL function in a SPARQL query">
SELECT ?subject ?area
WHERE {
	?subject ex:width ?width .
	?subject ex:height ?height .
	BIND (ex:multiply(?width, ?height) AS ?area) .
}</pre>
				<p>
					The following sections introduce the general properties that such functions may have,
					before the specific characteristics of <a>SPARQL-based functions</a> are defined.
				</p>
			</section>
			<section id="function-parameters">
				<h3>Function Parameters</h3>
				<p>
					The parameters of a <a>SHACL function</a> are declared using the property <code>sh:parameter</code>.
					This corresponds closely to the <a href="https://www.w3.org/TR/shacl/#constraint-components-parameters">parameter
					declarations of SPARQL-based constraint components</a>, and the same syntax rules apply.
				</p>
				<p id="parameters-ordering">
					Parameters are ordered, corresponding to the notation of function calls in SPARQL such as
					<code>ex:exampleFunction(?param1, ?param2)</code>.
					The ordering of function parameters is determined as follows:
				</p>
				<ul>
					<li>
						If any of the parameters have a <a>value</a> for <code>sh:order</code> then all of them
						are ordered in ascending order by the parameters' numeric <a>values</a> of <code>sh:order</code>,
						using <code>0</code> as default value if unspecified.
					</li>
					<li>
						If none of the parameters have a <a>value</a> for <code>sh:order</code> then all of them
						are ordered in ascending order of the <a>local names</a> of their declared <code>sh:path</code> values.
					</li>
				</ul>
				<p>
					Each parameter may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the parameter is not mandatory.
					If a function gets invoked without all its mandatory parameters then it returns no result node
					(an error in SPARQL, producing unbound in a BIND statement).
				</p>
			</section>
			<section id="function-returnType">
				<h3>sh:returnType</h3>
				<p>
					A function may declare a single <dfn>return type</dfn> via <code>sh:returnType</code>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="returnType-maxCount">A function has at most one <a>value</a> for <code>sh:returnType</code>.</span>
					<span data-syntax-rule="returnType-nodeKind">The values of <code>sh:returnType</code> are <a>IRIs</a>.</span>
				</p>
				<p>
					The <a>return type</a> may serve for documentation purposes only.
					However, in some execution languages such as JavaScript, the declared <code>sh:returnType</code> may inform
					a processor how to cast a native value into an <a>RDF term</a>.
				</p>
			</section>
			<section id="SPARQLFunction">
				<h3>SPARQL-based Functions</h3>
				<p>
					<a>SHACL instances</a> of <code>sh:SPARQLFunction</code> that are <a>IRIs</a> in a <a>shapes graph</a>
					are called <dfn>SPARQL-based functions</dfn>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="SPARQLFunction-query"><a>SPARQL-based functions</a> have exactly one <a>value</a> for either <code>sh:ask</code> or <code>sh:select</code>.
					The <a>values</a> of these properties are strings that can be parsed into SPARQL queries of type ASK (for <code>sh:ask</code>)
					or SELECT (for <code>sh:select</code>) using the SHACL-SPARQL <a href="https://www.w3.org/TR/shacl/#sparql-prefixes">prefix declaration mechanism</a>.
					SELECT queries return exactly one result variable and do not use the <code>SELECT *</code> syntax.</span>
				</p>
				<p>
					When the function is executed, the SPARQL processor needs to <a>pre-bind</a> variables based on the provided arguments
					of the function call.
					In the <a href="#functions-example">SHACL functions example</a> above, the value for the parameter declared as
					<code>ex:op1</code> is <a>pre-bound</a> to the SPARQL variable <code>$op1</code>, etc.
					For ASK queries, the function's return value is the result of the ASK query execution, i.e. <code>true</code> or <code>false</code>.
					For SELECT queries, the function's return value is the <a>binding</a> of the (single) result variable of the first <a>solution</a> in the result set.
					Since all other bindings will be ignored, such SELECT queries should only return at most one <a>solution</a>.
					If the result variable is unbound, then the function generates a <a href="https://www.w3.org/TR/sparql11-query/#invocation">SPARQL error</a>.
				</p>
			</section>
		</section>
		
		<section id="node-expressions">
			<h2>Node Expressions</h2>
			<p>
				This section defines a feature called <dfn data-lt="node expression">node expressions</dfn>.
				Node expressions are declared as RDF nodes in a <a>shapes graph</a> and instruct a SHACL engine
				how to compute a set of <a>nodes</a> for a given <a>focus node</a>.
				Each <a>node expression</a> has one of the following types,
				each of which is defined together with its evaluation semantics in the following sub-sections.
			</p>
			<table class="term-table">
				<tr>
					<th>Node&nbsp;Expression&nbsp;Type</th>
					<th>Syntax (Informative)</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><a>Focus Node Expression</a></td>
					<td><code>sh:this</code></td>
					<td>The set consisting of the current <a>focus node</a>.</td>
				</tr>
				<tr>
					<td><a>Constant&nbsp;Term&nbsp;Expression</a></td>
					<td>Any <a>IRI</a> or <a>literal</a> except <code>sh:this</code></td>
					<td>The set consisting of the given <a>term</a>.</td>
				</tr>
				<tr>
					<td><a>Function Expression</a></td>
					<td><a>Blank node</a> with a list-valued triple</td>
					<td>The results of evaluating a given <a>SHACL Function</a>.</td>
				</tr>
				<tr>
					<td><a>Path Expression</a></td>
					<td><a>Blank node</a> with <code>sh:path</code></td>
					<td>The <a>values</a> of a given <a>property path</a>.</td>
				</tr>
				<tr>
					<td><a>Filter Shape Expression</a></td>
					<td><a>Blank node</a> with <code>sh:filterShape</code> and <code>sh:nodes</code></td>
					<td>The sub-set of the input nodes that conform to a given <a>shape</a>.</td>
				</tr>
				<tr>
					<td><a>Intersection Expression</a></td>
					<td><a>Blank node</a> with <code>sh:intersection</code></td>
					<td>The intersection of two or more input sets.</td>
				</tr>
				<tr>
					<td><a>Union Expression</a></td>
					<td><a>Blank node</a> with <code>sh:union</code></td>
					<td>The union set of two or more input sets.</td>
				</tr>
			</table>
			<p>
				The basic idea of these expressions is that they can be used to derive a set of RDF nodes from
				a given <a>focus node</a>, for example the set of all values of a given property of the focus node.
				Some of these expressions can be nested, i.e. they use the output of another expression as their input,
				leading to evaluation chains and trees.
			</p>
			<p>
				The following example declares a <a>node expression</a> that produces the display labels of all values of
				the property <code>ex:customer</code> that <a>conform</a> to a given <a>shape</a> <code>ex:GoodCustomerShape</code>.
				The assumption here is that there is a <a>SHACL function</a> <code>ex:displayLabel</code> which declares a
				single parameter.
			</p>
			<pre class="example-shapes" title="Node expression example">
[
	ex:displayLabel ( [
		sh:filterShape ex:GoodCustomerShape ;
		sh:nodes [ sh:path ex:customer ] ;
	] )
] .</pre>
			<p>
				To evaluate this example, an engine gets all <a>values</a> of <code>ex:customer</code> of the <a>focus node</a>,
				then filters them according to the <a>shape</a> <code>ex:GoodCustomerShape</code>
				and repeatedly calls the <a>SHACL function</a> <code>ex:displayLabel</code> with all values that pass the
				filter shape as arguments.
			</p>
			<p>
				Important use cases of such expressions are <a>expression constraints</a> and <a>SHACL rules</a>,
				yet the basic functionality and vocabulary may find many other application areas.
			</p>
			<p>
				Each of the following sub-sections defines a node expression type with its syntax rules 
				and evaluation semantics based on a mapping operation <code>Eval($expr, $this)</code> where the
				first argument <code>$expr</code> is the given expression, <code>$this</code> is the current <a>focus node</a>
				and which produces a set of RDF nodes.
			</p>
			<p class="syntax">
				<span data-syntax-rule="node-expressions-recursion">A <code>node expression</code> cannot recursively have itself
				as a "nested" node expression, e.g. as <a>value</a> of <code>sh:nodes</code>.</span>
			</p>
			<section id="node-expressions-focus">
				<h3>Focus Node Expressions</h3>
				<p>
					The <a>IRI</a> <code>sh:this</code> is the (only) node declaring a <dfn>focus node expression</dfn>.
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF FOCUS NODE EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>focus node expression</a> <code>sh:this</code>, <code>Eval(sh:this, $this)</code> produces
						the set <code>{ $this }</code>.
					</div>
				</div>
			</section>
			<section id="node-expressions-constant">
				<h3>Constant Term Expressions</h3>
				<p>
					Any <a>literal</a> or <a>IRI</a> except <code>sh:this</code> declares a <dfn>constant term expression</dfn>.
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF CONSTANT TERM EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>constant term expression</a> <code>$expr</code>, <code>Eval($expr, $this)</code> produces
						the set <code>{ $expr }</code>.
					</div>
				</div>
			</section>
			<section id="node-expressions-filter-shape">
				<h3>Filter Shape Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="FilterShapeExpression">A <dfn>filter shape expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for <code>sh:filterShape</code> (which is a well-formed <a>shape</a>)
					and exactly one <a>value</a> for <code>sh:nodes</code> (which is a well-formed <a>node expression</a>).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF FILTER SHAPE EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>filter shape expression</a> <code>$expr</code> with <code>S</code> being the <a>shape</a>
						that is the <a>value</a> of <code>sh:filterShape</code> and <code>N</code> being the <a>node expression</a> that
						is the <a>value</a> of <code>sh:nodes</code>, <code>Eval($expr, $this)</code> produces the set of nodes for
						each <a>node</a> <code>n</code> produced by evaluating <code>N</code> where <code>n</code> <a>conforms</a> to <code>S</code>.
					</div>
				</div>
			</section>
			<section id="node-expressions-function">
				<h3>Function Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="FunctionExpression">A <dfn data-lt="function expressions">function expression</dfn> is a <a>blank node</a>
					that does not fulfill any of the syntax rules of the other node expression types and which
					is the <a>subject</a> of exactly one <a>triple</a> <code>T</code> where the <a>object</a> is a well-formed <a>SHACL list</a>,
					and each <a>member</a> of that list is a well-formed <a>node expression</a>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF FUNCTION EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>function expression</a> <code>$expr</code>, <code>Eval($expr, $this)</code> produces
						the set of <a>nodes</a> returned by evaluating the <a>SHACL function</a> specified as <a>predicate</a>
						of the triple <code>T</code> mentioned above.
						The arguments of the function call(s) are based on the results of the <a>node expressions</a> listed
						in the <a>object</a> list of <code>T</code> so that the first list <a>member</a> is used for the first argument, etc.
						This is done for all combinations of <a>nodes</a> produced by the <a>node expression</a>.
						If one of the <a>node expressions</a> produces the empty set and the corresponding function <a>parameter</a>
						is non-optional, then the result is the empty set.
					</div>
				</div>
				<p>
					As illustrated in the following example, <a>function expressions</a> are comparable to
					SPARQL BIND clauses.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[  ex:concat ( 
		[ sh:path ex:firstName ]
		[ sh:path ex:lastName ] 
	)
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
{
	$this ex:firstName ?a .
	$this ex:lastName ?b .
	BIND (ex:concat(?a, ?b) AS ?result) .
}
</pre>
						</td>
					</tr>
				</table>
			</section>
			<section id="node-expressions-path">
				<h3>Path Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="PathExpression">A <dfn data-lt="path expressions">path expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> of the property <code>sh:path</code> (which are well-formed <a>property paths</a>)
					and at most one <a>value</a> for <code>sh:nodes</code> (which is a well-formed <a>node expression</a>).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF PATH EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>path expression</a> <code>$expr</code> that has the property path <code>P</code> as its
						<a>value</a> for <code>sh:path</code> and the <a>node expression</a> <code>N</code> as its <a>value</a>
						for <code>sh:nodes</code> (defaulting to the <a>focus node expression</a> if absent),
						<code>Eval($expr, $this)</code> produces the set of <a>values</a> of all nodes produced by <code>N</code>
						for the <a>property path</a> <code>P</code>.
					</div>
				</div>
				<p>
					As illustrated in the following examples, <a>path expressions</a> are comparable to
					SPARQL basic graph patterns.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[  sh:path ex:firstName ] .

[  sh:nodes ex:children ;
   sh:path rdfs:label ;
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
{   $this ex:firstName ?result . }

{   $this ex:children ?a .
    ?a rdfs:label ?result .
}
</pre>
						</td>
					</tr>
				</table>
			</section>
			<section id="intersection">
				<h3>Intersection Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="intersection">An <dfn>intersection expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:intersection</code> which is a well-formed <a>SHACL list</a>
					with at least two <a>members</a> (which are well-formed node expressions).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF INTERSECTION EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>intersection expression</a> <code>$expr</code> that has the list <code>L</code> as its
						<a>value</a> for <code>sh:intersection</code>, <code>Eval($expr, $this)</code> produces
						the set of <a>nodes</a> that are in all of the result sets produced by the <a>members</a> of <code>L</code>.
					</div>
				</div>
			</section>
			<section id="union">
				<h3>Union Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="union">A <dfn data-lt="union expressions">union expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:union</code> which is a well-formed <a>SHACL list</a>
					with at least two <a>members</a> (which are well-formed node expressions).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF UNION EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>union expression</a> <code>$expr</code> that has the list <code>L</code> as its
						<a>value</a> for <code>sh:union</code>, <code>Eval($expr, $this)</code> produces
						the set of <a>nodes</a> that are in any of the result sets produced by all of the <a>members</a> of <code>L</code>.
					</div>
				</div>
				<p>
					As illustrated in the following example, <a>union expressions</a> are comparable to
					SPARQL UNION clauses.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[  sh:union (
		[ sh:path ex:firstName ]
		[ sh:path ex:givenName ]
   )
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
{
	$this ex:firstName ?result . 
} UNION {
	$this ex:givenName ?result . 
}</pre>
						</td>
					</tr>
				</table>
			</section>
		</section>
		
		<section id="ExpressionConstraintComponent">
			<h2>Expression Constraints</h2>
			<p>
				Based on <a>node expressions</a>, this section introduces a <a>constraint component</a> called
				<dfn data-lt="expression constraint">expression constraints</dfn>.
				Expression constraints can be used in any <a>shape</a> to declare the condition that the
				<a>node expression</a> specified via <code>sh:expression</code> has <code>true</code> as its (only) result.
				In the evaluation of these node expressions is repeated for all <a>value nodes</a> of the <a>shape</a>
				as the <a>focus node</a>.
			</p>
			<p>
				<span class="component-class">Constraint Component IRI</span>: <code>sh:ExpressionConstraintComponent</code>
			</p>

			<div class="parameters">Parameters:</div>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Summary and Syntax Rules</th>
				</tr>
				<tr>
					<td><code>sh:expression</code></td>
					<td>
						The <a>node expression</a> that must return <code>true</code>.
						<span data-syntax-rule="expression-scope">The <a>values</a> of <code>sh:expression</code> at a
						<a>shape</a> must be well-formed <a>node expressions</a>.</span>
					</td>
				</tr>
			</table>
			<div class="def def-text">
				<div class="def-header">TEXTUAL DEFINITION</div>
				<div class="def-text-body" data-validator="Filter">
					For each <a>value node</a> <code>v</code> where <code>Eval(v, $expression)</code>
					returns a node set that is not equal to <code>{ true }</code>
					there is a <a>validation result</a> that has <code>v</code> as its <code>sh:value</code>
					and <code>$expression</code> as its <code>sh:sourceConstraint</code>.
					If the <code>$expression</code> has <a>values</a> for <code>sh:message</code> in the <a>shapes graph</a>
					then these <a>values</a> become the (only) values for <code>sh:resultMessage</code> in the
					<a>validation result</a>.
				</div>
			</div>
			<p><em>The remainder of this section is informative.</em></p>
			<p>
				The following example assumes that there are <a>SHACL functions</a> <code>ex:concat</code>,
				<code>ex:strlen</code> and <code>ex:lessThan</code> and uses them to verify that the
				combined string length of <code>ex:firstName</code> and <code>ex:lastName</code> is less than 30.
			</p>
			<pre class="example-shapes">
ex:FilterExampleShape
	a sh:NodeShape ;
	sh:expression [
		ex:lessThan ( 
			[ ex:strlen ( 
				[ ex:concat ( [ sh:path ex:firstName] [ sh:path ex:lastName ] ) ] ) 
			]
			30 );
	] .</pre>
		</section>

		<section id="rules">
			<h2>SHACL Rules</h2>
			<p>
				SHACL defines an RDF vocabulary to describe <a>shapes</a> - collections of <a>constraints</a> that apply to a set of nodes.
				Shapes can be associated with nodes using a flexible <a>target</a> mechanism, e.g. for all instances of a class.
				One focus area of SHACL is data validation.
				However, the same principles of describing data patterns in shapes can also be exploited for other purposes.
				<a>SHACL rules</a> build on SHACL to form a light-weight RDF vocabulary for the exchange of <a>rules</a> that can be used
				to derive <a>inferred</a> RDF <a>triples</a> from existing <em>asserted</em> <a>triples</a>.
			</p>
			<p>
				The <a>SHACL rules</a> feature defined in this section includes a general framework using the properties
				such as <code>sh:rule</code> and <code>sh:condition</code>, plus an extension mechanism for specific <a>rule types</a>.
				This document defines two such rule types: <a>Triple rules</a> and <a>SPARQL rules</a>.
				Other documents, including SHACL JavaScript Extensions [[shacl-js]], can define additional types of rules.
			</p>
			
			<section id="rules-examples" class="informative">
				<h3>Examples of SHACL Rules</h3>
				<p>
					The following example illustrates the use of a <a>triple rule</a> that adds an <code>rdf:type</code>
					<a>triple</a> so that those <a>SHACL instances</a> of <code>ex:Rectangle</code> where the
					<code>ex:width</code> equals the <code>ex:height</code> are also marked to be instances of <code>ex:Square</code>.
					The rule applies only to well-formed rectangles that <a>conform</a> to the <code>ex:Rectangle</code> <a>shape</a>,
					e.g. by having exactly one width and height, both integers.
				</p>
				<pre class="example-shapes" title="A rule to classify certain rectangles as squares">
ex:Rectangle
	a rdfs:Class, sh:NodeShape ;
	rdfs:label "Rectangle" ;
	sh:property [
		sh:path ex:height ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
		sh:minCount 1 ;
		sh:name "height" ;
	] ;
	sh:property [
		sh:path ex:width ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
		sh:minCount 1 ;
		sh:name "width" ;
	] ;
	sh:rule [
		a sh:TripleRule ;
		sh:subject sh:this ;
		sh:predicate rdf:type ;
		sh:object ex:Square ;
		sh:condition ex:Rectangle ;
		sh:condition [
			sh:property [
				sh:path ex:width ;
				sh:equals ex:height ;
			] ;
		] ;
	] .</pre>
				<pre class="example-data">
ex:InvalidRectangle
	a ex:Rectangle .

ex:NonSquareRectangle
	a ex:Rectangle ;
	ex:height 2 ;
	ex:width 3 .
	
ex:SquareRectangle
	a ex:Rectangle ;
	ex:height 4 ;
	ex:width 4 .</pre>
				<p>
					For the <a>data graph</a> above, a SHACL rules engine will produce the following inferred triples:
				</p>
				<pre class="example-inferences">	ex:SquareRectangle rdf:type ex:Square .</pre>
				<p>
					No inferences will be made for <code>ex:NonSquareRectangle</code> because its width is not equal to its height.
					No inferences will be made for <code>ex:InvalidRectangle</code> because although it has equal width
					and height (namely none), it does not pass the <code>sh:condition</code> of being a well-formed rectangle.
				</p>
				<p>
					The following example illustrates a simple use case of a <a>SPARQL rule</a> that applies to all instances of
					the class <code>ex:Rectangle</code> and computes the values of the <code>ex:area</code> property by multiplying
					the rectangle's width and height:
				</p>
				<pre class="example-shapes" title="A rule to compute the area of a Rectangle">
ex:RectangleShape
	a sh:NodeShape ;
	sh:targetClass ex:Rectangle ;
	sh:property [
		sh:path ex:width ;
		sh:datatype xsd:integer ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:path ex:height ;
		sh:datatype xsd:integer ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] .

ex:RectangleRulesShape
	a sh:NodeShape ;
	sh:targetClass ex:Rectangle ;
	sh:rule [
		a sh:SPARQLRule ;
		sh:prefixes ex: ;
		sh:construct """
			CONSTRUCT {
				$this ex:area ?area .
			}
			WHERE {
				$this ex:width ?width .
				$this ex:height ?height .
				BIND (?width * ?height AS ?area) .
			}
			""" ;
		sh:condition ex:RectangleShape ;    # Rule only applies to Rectangles that conform to ex:RectangleShape
	] ;
.</pre>
				<p>
					An engine that is capable of executing such rules uses the <a>target</a> statements associated
					with the <a>shapes</a> in the <a>shapes graph</a> to determine which rules need to be executed on which target nodes.
					For those target nodes that <a>conform</a> to any <a href="#condition">condition shapes</a>, it executes the provided
					CONSTRUCT queries to produce the inferred triples.
					During the execution of the query, the variable <code>this</code> has the current <a>focus node</a> as <a>pre-bound</a> variable.
					For the following <a>data graph</a>, the <a>triples</a> below would be produced.
				</p>
				<pre class="example-data">
ex:ExampleRectangle
	a ex:Rectangle ;
	ex:width 7 ;
	ex:height 8 .

ex:InvalidRectangle    # Lacks a value for ex:height, so sh:condition is not met
	a ex:Rectangle ;
	ex:width 7 .</pre>
				<p>
					Inferred triples:
				</p>
				<pre class="example-inferences">	ex:ExampleRectangle ex:area 56 .</pre>
				<p>
					The following variation produces the same results as the <a>SPARQL rule</a>, but uses a <a>Triple rule</a>.
					While not as expressive as CONSTRUCT-based rules, <a>Triple rules</a> are more declarative and
					may be executed on platforms that do not support SPARQL.
				</p>
				<pre class="example-shapes" title="A triple rule to compute the area of a Rectangle">
ex:RectangleRulesShape
	a sh:NodeShape ;
	sh:targetClass ex:Rectangle ;
	sh:rule [
		a sh:TripleRule ;
		sh:subject sh:this ;
		sh:predicate ex:area ;    # Computes the values of the ex:area property at the focus nodes
		sh:object [
			ex:multiply ( [ sh:path ex:width ] [ sh:path ex:height ] ) ;
		] ;
		sh:condition ex:RectangleShape ;    # Rule only applies to Rectangles that conform to ex:RectangleShape
	] .</pre>
			</section>
	
			<section id="rules-syntax">
				<h2>General Syntax of SHACL Rules</h2>
				<p>
					The <a>values</a> of the property <code>sh:rule</code> at a <a>shape</a> are called <dfn data-lt="rule|rules|SHACL rule">SHACL rules</dfn>.
					SHACL has a flexible design in which multiple types of rules can be supported,
					including <a>Triple rules</a> and <a>SPARQL rules</a>.
					Each <dfn data-lt="rule types">rule type</dfn> is identified by an <a>IRI</a> that is used as <code>rdf:type</code> of rules.
					Each rule type also defines <dfn>execution instructions</dfn> that can be implemented by rule engines.
				</p>
				<p class="syntax">
					<span data-syntax-rule="rule-type">Each <a>SHACL rule</a> has at least one <code>rdf:type</code> which is a <a>IRI</a>.</span>
				</p>
				<p>
					Rules can have multiple types, e.g. to provide instructions that work either in SPARQL or JavaScript,
					depending on the capabilities of the engine.
					The creator of such rules needs to make sure that such rules have consistent semantics.
					Rule <code>R</code> has <a>rule type</a> <code>T</code> if <code>R</code> is a <a>SHACL instance</a> of <code>T</code>.
				</p>
				<p>
					All rules may have the properties defined in the rest of this section.
				</p>
				<section id="condition">
					<h3>sh:condition</h3>
					<p>
						A <a>rule</a> may have values for the property <code>sh:condition</code> to specify <a>shapes</a>
						that the <a>focus nodes</a> must conform to before the rule gets executed.
					</p>
					<p class="syntax">
						<span data-syntax-rule="condition-node">The <a>values</a> of <code>sh:condition</code> at a <a>rule</a> must be well-formed <a>shapes</a>.</span>
					</p>
				</section>
				<section id="rules-order">
					<h3>sh:order</h3>
					<p>
						Rules and shapes may specify its relative <dfn>execution order</dfn> as defined in this section.
					</p>
					<p class="syntax">
						<span data-syntax-rule="rule-order-maxCount">Each <a>rule</a> or <a>shape</a> may have at most one <a>value</a> for the
						property <code>sh:order</code>.</span>
						<span data-syntax-rule="rule-order-datatype">The values of <code>sh:order</code> at <a>rules</a> and <a>shapes</a>
						are <a>literals</a> with a <em>numeric</em> datatype such as <code>xsd:decimal</code>.</span>
					</p>
					<p>
						If unspecified, then the default <a>execution order</a> is <code>0</code>.
						These values are used by a <a>rules engine</a> to determine the order of <a>rules</a>.
						When the <a>rules</a> associated with a <a>shape</a> are executed, <a>rules</a> with larger values will be executed after
						those with smaller values.
					</p>
					<pre class="example-shapes" title="Rule order example">
ex:RuleOrderExampleShape
	a sh:NodeShape ;
	sh:targetClass ex:Person ;
	sh:rule [
		a sh:SPARQLRule ;
		rdfs:label "Infer uncles, i.e. male siblings of the parents of $this" ;
		sh:prefixes ex: ;
		sh:order 1 ;   # Will be evaluated before 2
		sh:construct """
			CONSTRUCT {
				$this ex:uncle ?uncle .
			}
			WHERE {
				$this ex:parent ?parent .
				?parent ex:sibling ?uncle .
				?uncle ex:gender ex:male .
			}
			"""
	] ;
	sh:rule [
		a sh:SPARQLRule ;
		rdfs:label "Infer cousins, i.e. the children of the uncles" ;
		sh:prefixes ex: ;
		sh:order 2 ;
		sh:construct """
			CONSTRUCT {
				$this ex:cousin ?cousin .
			}
			WHERE {
				$this ex:uncle ?uncle .
				?cousin ex:parent ?uncle .
			}
			"""
	] .</pre>
				</section>
				<section id="deactivated">
					<h3>sh:deactivated</h3>
					<p>
						Rules may be <em>deactivated</em> by setting <code>sh:deactivated</code> to <code>true</code>.
						Deactivated rules are ignored by the rules engine.
					</p>
					<p class="syntax">
						<span data-syntax-rule="deactivated-maxCount">Each <a>rule</a> may have at most one <a>value</a> for the
						property <code>sh:deactivated</code>.</span>
						<span data-syntax-rule="deactivated-in">The <a>values</a> of <code>sh:deactivated</code> are either
						of the <code>xsd:boolean</code> literals <code>true</code> or <code>false</code>.</span>
					</p>
				</section>
			</section>
			<section id="Rules">
				<h3>The sh:Rules Entailment Regime</h3>
				<p>
					SHACL defines the property <a href="https://www.w3.org/TR/shacl/#shacl-rdfs"><code>sh:entailment</code></a>
					to link a <a>shapes graph</a> with <em>entailment regimes</em>.
					The <a>IRI</a> <code>sh:Rules</code> represents the <dfn>SHACL rules entailment regime</dfn>.
					In the following example, the shapes graph indicates to a SHACL validation engine that the SHACL rules
					inside of the <a>shapes graph</a> need to be executed prior to starting the validation.
				</p>
				<pre class="example-shapes">
&lt;http://example.org/my-shapes&gt;
	a owl:Ontology ;
	sh:entailment sh:Rules .</pre>
				<p>
					Following the general policy for SHACL, validation engines that do <em>not</em> support the <a>SHACL rules entailment regime</a>
					MUST signal a <a>failure</a> if this <a>triple</a> is present.
					Validation engines that do support the <a>SHACL rules entailment regime</a> execute the rules following the
					<a href="#rules-execution">rules execution instructions</a> prior to performing the actual validation. 
				</p>
			</section>
			<section id="rules-execution">
				<h3>General Execution Instructions for SHACL Rules</h3>
				<p>
					A <dfn data-lt="rules engine">SHACL rules engine</dfn> is a computer procedure that takes as input
					a <a>data graph</a> and a <a>shapes graph</a> and is capable of adding <a>triples</a> to the <a>data graph</a>.
					The new <a>triples</a> that are produced by a rules engine are called the <dfn data-lt="inferring|infer">inferred</dfn> triples.
				</p>
				<p>
					Note that, from a logical perspective, the <a>data graph</a> will be <em>modified</em> if <a>triples</a> get inferred.
					This means that rules can trigger after other triples have been inferred.
					However, in cases where the original data should not be modified, implementations may construct a logical <a>data graph</a>
					that has the original data as one subgraph and a dedicated inferences graph as another subgraph, and where
					the inferred triples get added to the inferences graph only.
				</p>
				<p>
					In order to count as a SHACL rules engine, an implementation must be capable of <a>inferring</a> <a>triples</a>
					according to the following procedure (given in pseudo-code), or a different algorithm as long as the result
					is the same as specified.
					Note that this algorithm only covers a single "iteration" over all rules, without prescribing the behavior
					if the same rule needs to be applied multiple times after other rules have fired.
					The latter is left to future work.
				</p>
				<pre>
	for each <a>shape</a> <code>S</code> in the <a>shapes graph</a>, ordered by <a>execution order</a> {
		for each non-deactivated <a>rule</a> <code>R</code> in the <a>shape</a>, ordered by <a>execution order</a> {
			for each <a>target</a> node <code>T</code> of <code>S</code> that <a>conforms</a> to all <a href="#condition">conditions</a> of <code>R</code> {
				execute <code>R</code> using <code>T</code> as <a>focus node</a> following the <a>execution instructions</a> of its <a>rule types</a>
			}
		}
	}</pre>
				<p>
					The <a>triples</a> that are inferred by a <a>rule</a> do not <em>immediately</em> become part of the <a>data graph</a>,
					i.e. the <a>triples</a> produced by one <a>rule</a> can not always be queried by other <a>rules</a>.
					These policies reduce the likelihood of race conditions and better support parallel execution.
				</p>
				<ul>
					<li>
						If two <a>shapes</a> have the same <a>execution order</a> then their newly inferred <a>triples</a> are
						not visible to each other.
					</li>
					<li>
						If two <a>rules</a> have the same <a>execution order</a> then their newly inferred <a>triples</a> are
						not visible to each other.
					</li>
					<li>
						If the same <a>rule</a> is executed on multiple target nodes then the newly inferred <a>triples</a> are
						not visible to the other target nodes.
					</li>
				</ul>
				<p>
					If a <a>rules engine</a> is not able to execute a given <a>rule</a>
					because it does not support any of the <a>rule types</a> of the <a>rule</a>,
					then it reports a <a>failure</a>.
				</p>
				<p>
					At no time are inferred triples visible to the <a>shapes graph</a>, i.e. it is impossible for rules
					to modify the definitions of rules or shapes.
				</p>
			</section>

			<section id="TripleRule">
				<h3>Triple Rules</h3>
				<p>
					This section defines a <a>rule type</a> called <dfn data-lt="triple rule">triple rules</dfn>, identified by
					the <a>IRI</a> <code>sh:TripleRule</code>.
					<a>Triple rules</a> have the following properties:
				<p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Summary and Syntax Rules</th>
					</tr>
					<tr>
						<td><code>sh:subject</code></td>
						<td>
							The <a>node expression</a> used to compute the <a>subjects</a> of the <a>triples</a>.
							<span data-syntax-rule="TripleRule-subject">Each <a>triple rule</a> must have exactly one
							<a>value</a> of the property <code>sh:subject</code> (which must be a well-formed <a>node expression</a>).
							</span>
						</td>
					</tr>
					<tr>
						<td><code>sh:predicate</code></td>
						<td>
							The <a>node expression</a> used to compute the <a>predicates</a> of the <a>triples</a>.
							<span data-syntax-rule="TripleRule-predicate">Each <a>triple rule</a> must have exactly one
							<a>value</a> of the property <code>sh:predicate</code> (which must be a well-formed <a>node expression</a>).
							</span>
						</td>
					</tr>
					<tr>
						<td><code>sh:object</code></td>
						<td>
							The <a>node expression</a> used to compute the <a>objects</a> of the <a>triples</a>.
							<span data-syntax-rule="TripleRule-object">Each <a>triple rule</a> must have exactly one
							<a>value</a> of the property <code>sh:object</code> (which must be a well-formed <a>node expression</a>).
							</span>
						</td>
					</tr>
				</table>
				<div class="def def-text">
					<div class="def-header">EXECUTION OF TRIPLE RULES</div>
					<div class="def-text-body">
						Let <code>S</code>, <code>P</code> and <code>O</code> be the sets of <a>nodes</a> produced by evaluating
						the <a>node expressions</a> that are the values of <code>sh:subject</code>, <code>sh:predicate</code>
						and <code>sh:object</code> respectively at the <a>triple rule</a>.
						For each combination of members <code>s</code> of <code>S</code>, <code>p</code> of <code>P</code> and
						<code>o</code> of <code>O</code>, <a>infer</a> a <a>triple</a> with <a>subject</a> <code>s</code>,
						<a>predicate</a> <code>p</code> and <a>object</a> <code>o</code>.
					</div>
				</div>
			</section>

			<section id="SPARQLRule">
				<h3>SPARQL Rules</h3>
				<p>
					This section defines a <a>rule type</a> called <dfn data-lt="SPARQL rule">SPARQL rules</dfn>,
					identified by the <a>IRI</a> <code>sh:SPARQLRule</code>.
					<a>SPARQL rules</a> have the following properties:
				<p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Summary and Syntax Rules</th>
					</tr>
					<tr>
						<td><code>sh:construct</code></td>
						<td>
							The SPARQL CONSTRUCT query.
							<span data-syntax-rule="construct-count"><a>SPARQL rules</a> must have exactly one
							<a>value</a> for the property <code>sh:construct</code>.</span>
							<span data-syntax-rule="construct-datatype">The values of <code>sh:construct</code>
							are <a>literals</a> with datatype <code>xsd:string</code>.</span>
						</td>
					</tr>
					<tr>
						<td><code>sh:prefixes</code></td>
						<td>
							The prefixes to use to turn the <code>sh:construct</code> into a SPARQL query.
							<a>SPARQL rules</a> may use the property <code>sh:prefixes</code> to declare a dependency on prefixes based on the
							mechanism defined in <a href="https://www.w3.org/TR/shacl/#sparql-prefixes">Prefix Declarations for SPARQL Queries</a>
							from the SHACL specification [[!shacl]].
							This mechanism allows users to abbreviate URIs in the <code>sh:construct</code> strings.
						</td>
					</tr>
				</table>
				<div class="def def-text">
					<div class="def-header">EXECUTION OF SPARQL RULES</div>
					<div class="def-text-body">
						Let <code>Q</code> be the SPARQL CONSTRUCT query derived from the values of the properties
						<code>sh:construct</code> and <code>sh:prefixes</code> of the <a>SPARQL rule</a> in the <a>shapes graph</a>.
						For each <a>focus node</a>, execute the query <code>Q</code>
						<a>pre-binding</a> the variable <code>this</code> to the <a>focus node</a>,
						and <a>infer</a> the constructed <a>triples</a>.
					</div>
				</div>
			</section>
		</section>
		
		<section id="syntax-rules" class="appendix">
			<h2>Summary of Syntax Rules from this Document</h2>
			<p>
				This section enumerates all normative syntax rules from this document.
				This section is automatically generated from other parts of this spec and hyperlinks are provided back
				into the prose if the context of the rule in unclear. 
				Nodes that violate these rules in a shapes graph are ill-formed.
			</p>
			<table class="term-table" id="syntax-rules-table">
				<tr>
					<th>Syntax Rule Id</th>
					<th>Syntax Rule Text</th>
				</tr>
			</table>
		</section>
						
		<section id="security" class="appendix informative">
			<h2>Security and Privacy Considerations</h2>
			<p>
				The features defined in this document share certain security and privacy considerations with those
				<a href="https://www.w3.org/TR/shacl/#security">mentioned</a> in [[!shacl]].
				The general advice is for users to only use trusted and controlled shape graphs.
			</p>
		</section>
		
		<section id="ack" class="appendix informative">
			<h2>Acknowledgements</h2>
			<p>
				Many people contributed to this document, including members of the RDF Data Shapes Working Group.
				The sections <a href="#targets"></a>, <a href="#sparql-constraints-annotations"></a> and
				<a href="#functions"></a> had been part of earlier drafts of the main SHACL specification [[!shacl]]
				but were moved out in part due to time constraints in the Working Group.
				Dimitris Kontokostas was the main contributor to the <a href="#sparql-constraints-annotations"></a> section.
			</p>
		</section>
	</body>
</html>
