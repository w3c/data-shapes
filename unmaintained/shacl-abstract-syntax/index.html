<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Out of Date: SHACL Core Abstract Syntax and Semantics</title>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            async="async" class='remove'></script>
    <script src="https://www.w3.org/2013/ShEx/demobits/jquery.min.js" type="text/javascript"></script>
    <!-- link rel="stylesheet" type="text/css" href="local.css" / -->
    <script class='remove'>
      var respecConfig = {
      specStatus: "ED",
      edDraftURI: "http://w3c.github.io/data-shapes/shacl-abstract-syntax/",
      shortName:  "shacl-abstract-syntax",
      editors: [
        { name:       "Eric Prud'hommeaux",
          url:        "http://www.w3.org/People/Eric/",
          company:    "W3C/MIT",
          companyURL: "http://www.w3.org/",
          w3cid: "2112" },
        { name:       "Karen Coyle",
          url:        "http://kcoyle.net/",
          company:    "DCMI",
          companyURL: "http://dublincore.org/",
          w3cid: "44865" }
      ],
      wg:           "RDF Data Shapes Working Group",
      wgURI:        "https://www.w3.org/2014/data-shapes",
      wgPublicList: "public-rdf-shapes",
      wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status",
      localBiblio:  {
      "xyz": {
      title:    "Sample Custom Reference",
      href:     "http://example.org/",
      "authors": [
      "S. Steyskal"
      ],
      publisher: "xyz"
      }
      }
      };
    </script>
		<!-- <script src="https://www.w3.org/scripts/jquery/2.1/jquery.min.js"></script>  -->
    <style>
      .todo {
      color: red;
      }
      pre {
      tab-size: 4;
      }
      th {
      text-align: left;
      }
      .comment {
      /* font-lock-comment-face */
      color: #b22222;
      }
      .constant {
      /* font-lock-constant-face */
      color: #008b8b;
      }
      .function-name {
      /* font-lock-function-name-face */
      color: #0000ff;
      }
      .keyword {
      /* font-lock-keyword-face */
      color: #a020f0;
      }
      .string {
      /* font-lock-string-face */
      color: #8b2252;
      }
      .type {
      /* font-lock-type-face */
      color: #228b22;
      }
      .example {
      display: inline-block;
      }
      .example.wrapper {
      background-color: #fff;
      }
      .example.wrapper pre {
      background-color: #fcfaee;
      margin-left: 0;
      line-height: 1.2;
      }
      .example.wrapper .fail {
      background-color: #fceefa
      }
      .verticalDivider {
      float: left;
      width: .5em;
      border:thin solid #fff; /* disappears without this */
      }

      .highlight1     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 176, 0, .5); border-right: 5px solid rgba(176, 176, 0, .5); } /* font-weight: bold  ;  */
      .highlight1.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
      .highlight1.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
      .lowlight1      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid transparent; border-right: 5px solid transparent;                     } /* font-weight: normal;  */
      .lowlight1.top  {    margin-top: -5px;                      border-top: 5px solid transparent;                                                          } /* font-weight: normal;  */
      .lowlight1.bot  { margin-bottom: -5px;                   border-bottom: 5px solid transparent;                                                          } /* font-weight: normal;  */
      .highlight2     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 0, 176, .5); border-right: 5px solid rgba(176, 0, 176, .5); } /* font-weight: bold  ;  */
      .highlight2.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
      .highlight2.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
      .lowlight2      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(127, 127, 127, .07); border-right: 5px solid rgba(127, 127, 127, .07);         } /* font-weight: normal;  */
      .lowlight2.top  {    margin-top: -5px;                      border-top: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */
      .lowlight2.bot  { margin-bottom: -5px;                   border-bottom: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */

      .highlightBG1   { /* border: 5px solid transparent; */ background-color: #bb0; font-weight: bold; }
      .lowlightBG1    { /* border: 5px solid transparent; */ font-weight: normal; }
      .highlightBG2   { /* border: 5px solid transparent; */ background-color: #b00; font-weight: bold; }
      .lowlightBG2    { /* border: 5px solid transparent; */ font-weight: normal; }

      .new            { font-weight: bold; }
      .errorSite      { color: red; }

      h3 sup,h4 sup,.eval {
      font-weight: lighter;
      color: #307;
      }
      .emph{
      font-style: italic;
      }

      .testrm{
      font-style: normal;
      }

      .textbf{
      font-weight: bold;
      }

      .math{
      font-style: normal;
      font-family: sans-serif;
      }

      .new{
      color: #6600FF;
      }

      .block-name{
      font-weight: bold;
      }

      .abstrsynt{
      margin-left: 0;
      margin-right: 2ex;
      margin-top: 0.1ex;
      margin-bottom: 0.1ex;
      /* border: double 1px #888888; */
      border: thin solid #888888;
      padding: 1ex 2ex 0.5ex 2ex;
      page-break-inside: avoid;
      background-color: #F0F8F8;
      }
      .abstrsynt.squished{ padding-top: 0; padding-bottom: 0; border: none; margin-top: 0; margin-bottom: 0; }
      h2.squished,h3.squished,h4.squished { margin-top: 1ex; margin-bottom: 0; }

      .Definition{
      margin-left: 0;
      margin-right: 2ex;
      margin-top: 0.1ex;
      margin-bottom: 0.1ex;
      /* border: double 1px #888888; */
      border: thin solid #888888;
      padding: 1ex 2ex 0.5ex 2ex;
      page-break-inside: avoid;
      background-color: #F0F0F0;
      }


      .quote{
      margin-left: 3em;
      }

      .smaller{
      font-size: .83em;
      }

      pre.schema.hljs.css { color: #070; border: thin solid #0f0; }
        pre.data.hljs.css { color: #007; border: thin solid #00f; }
      th.schema { color: #070; }
        th.data { color: #007; }
/*      pre.schema:before { content: schema }
        pre.data:before { content: data   }
*/
      table td { vertical-align: top; }
      table th { text-align: center; }
      table { border-collapse: collapse; }
      td, th { border-style: solid; }
      .pass { background-color: #cfc; }
      .fail { background-color: #fcc; }
      span.fail { background-color: #fcc; }

      .param { color: #3500c8; }
      .var { color: #056800; }
      .rdf { border-left: thick solid #77f; padding-left: .5em; }
.newref {
    background-color: #ee0;
}
.newframe {
    border: medium solid #ee0;
}

.label { font-weight: bold; }

    </style>
  </head>
  <body>
    <section id='abstract'>
      This document defines an abstract syntax for the core SHACL (SHApes Constraint Language). It is derived from 
      the <a href="http://www.w3.org/TR/shacl/">SHACL specification</a>[[!shacl]] and is a non-normative version of the content of that specification.
    </section>

    <section id='sotd'>
	<p style="color: red; font-weight: bold;">
		This document is no longer maintained and is out of date.
	</p> 
    </section>

    <!-- taken from http://www.w3.org/2014/data-shapes/charter -->
    <section id="intro">
      <h2>Introduction</h2>
      <p>
        SHACL (Shapes Constraint Language) is a language for describing and constraining the contents of <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</a>[[!rdf11-concepts]].
        SHACL constraints are grouped into "shapes", which may also be referenced by constraints in other shapes.
        These constraints describe the <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">triples</a>[[!rdf11-concepts]] connecting certain nodes in the graph.
      </p>
      <h2>Scope of This Document</h2>
      This abstract syntax describes the SHACL Core language as specified in sections 2 and 4 of the Shapes Constraint Language document.

    </section>
	  <section id="notation">
	    <h2>Notation</h2>
      <p>
        The abstract syntax consists of statements defining data structures and named members of those data structures.
        Each member has either a single type or two or more types that are a union (choice) of types.
        Each type is either a reference to another statement, an RDF type, or a <a href="http://www.w3.org/TR/sparql11-query/#operandDataTypes">SPARQL literal term</a> (e.g. <code>numeric</code>)[[!sparql11-query]], or the template type <code>Set</code>, which signifies a <a href="https://en.wikipedia.org/wiki/Set_(mathematics)">logical set</a> of a type.
        Sets are unordered and duplicate members have no significance; the set <code>(1, 1, 2, 3, 5)</code> is the same as the set <code>(5, 1, 3, 2)</code>.
      </p>
      <p>In this notation:</p>
     
      <div class="abstrsynt">
        <span class="math">Shape := <code class="param">label</code>:IRI|BNode, <code class="param">targets</code>:Set[<a href="#dfn-Target">Target</a>], <code class="param">filters</code>:Set[<a href="#dfn-Shape">Shape</a>], <code class="param">constraints</code>:Set[<a href="#dfn-Constraint">Constraint</a>]</span>
      </div>
      <p>
        This signifies that a <code>Shape</code> has four components called <code class="param">label</code>, <code class="param">targets</code>, <code class="param">filters</code>, <code class="param">constraints</code>.
        The <code class="param">label</code> is either a <code>IRI</code> or <code>BNode</code>,
        the <code class="param">targets</code> are a set of <a href="#dfn-Target"><code>Target</code>s</a>,
        the <code class="param">filters</code> are a set of <a href="#dfn-Shape"><code>Shape</code>s</a>,
        and the <code class="param">constraints</code> is a set of <a href="#dfn-Constraint"><code>Constraint</code>s</a>.
        <code>IRI</code> and <code>BNode</code> are <a href="http://www.w3.org/TR/2014/REC-rdf11-mt-20140225/#notation">defined in RDF 1.1 Semantics</a>[[!rdf11-mt]].
        <a href="#dfn-Target"><code>Target</code></a>, <a href="#dfn-Shape"><code>Shape</code></a> and <a href="#dfn-Constraint"><code>Constraint</code></a> are defined terms within this document.
      </p>
      <p>
        The term definitions given in this document rely on matching triple patterns in the form <code>(subject, predicate, object)</code> where each position may be supplied by a constant, a previously defined term, or the underscore "<code>_</code>", which represents a previously undefined element or wildcard.
        This corresponds to a <a href="http://www.w3.org/TR/sparql11-query/#defn_TriplePattern">SPARQL Triple Pattern</a> where each "_" is replaced by a unique blank node.
        Matching such a triple pattern against a graph is defined by <a href="http://www.w3.org/TR/sparql11-query/#BGPsparql">SPARQL Basic Graph Pattern Matching</a> (BFP) with a BGP containing only that triple pattern.
      </p>
      <button id="toggleRDF">Toggle RDF ("r")</button> <button id="toggleExamples">Toggle Examples ("e")</button> <button id="toggleSquished">Render only abstract syntax ("a")</button>

      <p class="rdf">
        Sections defining the RDF representation of SHACL will have a .rdf class.
      </p>
      <p>
        Validation is a function which takes schema shape and an RDF node and returns a <span class="pass">pass</span> or <span class="fail">fail</span>.
      </p>
      <div class="example">
        <p>
          In examples, the results of validation are represented in a table associating node/shape pairs with a pass or fail and a reason for failure:
        </p>
      <table>
        <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
        <tr class="pass"><td>&lt;Shape1&gt;</td><td>&lt;node1&gt;</td><td>pass</td></tr>
        <tr class="fail"><td>&lt;Shape1&gt;</td><td>&lt;node2&gt;</td><td>fail</td><td class="fail">no <code>ex:state</code> supplied.</td></tr>
      </table>
      </div>
      <!-- 
	    <p>
        The following HTML tags and CSS classes are used to highlight the roles of text in this document:
	    </p>
	    <ul>
        <li>&lt;dfn&gt;<dfn id="dfn-shacl-defined-term">defined term</dfn>&lt;dfn&gt;</li>
        <li>&lt;a class="internalDFN"&gt;<a title="SHACL defined term" href="#dfn-shacl-defined-term" class="internalDFN">defined term</a>&lt;/a&gt;</li>
        <li><sup class="eval">eval</sup> &mdash; link to evaluation semantics</li>
	      </ul>
      -->
      <p>These are the namespace prefixes used in the examples:</p>
      <ul>
      	<li class="data">PREFIX sh: &lt;http://www.w3.org/ns/shacl#&gt;</li>
      	<li class="data">PREFIX ex: &lt;http://example.com/ns#&gt;</li>
      	<li class="data">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;</li>
      </ul>
	  </section>

    <section>
      <h2>Schemas and Shapes</h2>
      <p>
      The SHACL environment uses two inputs: a SHACL shape graph, and a data graph. 
      A SHACL shape graph consists of schemas and shapes. A Schema is a set of one or more Shapes. A Shape is a set of Targets, Filters, and Constraints. Each Shape has a label that is an IRI or BNode.
      Targets define the nodes in the data graph that are selected for comparison. 
      Filters provide further refinement of the targets if needed.
      The targeted nodes in the data graph are called "focus nodes."
      </p>
 
      <div class="abstrsynt">
        <span class="math" id="dfn-Schema">Schema        := <code class="param">shapes</code>:Set[<a href="#dfn-Shape">Shape</a>]</span><br/>
        <span class="math" id="dfn-Shape">Shape         := <code class="param">label</code>:IRI|BNode, <code class="param">targets</code>:Set[<a href="#dfn-Target">Target</a>], <code class="param">filters</code>:Set[<a href="#dfn-Shape">Shape</a>], <code class="param">constraints</code>:Set[<a href="#dfn-Test">Test</a>]</span><br/>
        <span class="math" id="dfn-Test">Test          := <a href="#dfn-Constraint">Constraint</a>|<a href="#dfn-Algebraic">Algebraic</a></span>
      </div>
      <div class="rdf">
      <p>
        Shapes are represented in RDF as a subject node that is the shape's <code class="param">label</code> with a set of properties identifying the types of any <code class="param">targets</code>, <code class="param">filters</code> and <code class="param">constraints</code>.
        For example, a specific form of <a href="#dfn-Constraint">Constraint</a>, a <a href="#dfn-PathConstraint">PathConstraint</a><!-- <a href="#dfn-PropertyConstraint">PropertyConstraint</a> --> that requires that conforming nodes have a <code>foaf:name</code> property with a value that is an RDF literal would be:
      </p>
      <pre class="schema">[ sh:predicate foaf:name; sh:nodeKind sh:Literal ] .</pre>
      <p>
        A Shape with the <code class="param">label</code> IRI &lt;http://a.example/Person&gt; and only that <code class="param">constraint</code> would have a <code>sh:property</code> arc connecting the shape <code class="param">label</code> to the above <code class="param">constraint</code>:
      </p>
      <pre class="schema">&lt;Person&gt; sh:property [ sh:predicate foaf:name; sh:nodeKind sh:Literal ] .</pre>
      <p>
        Here, <code>sh:property</code> identifies a <a href="#dfn-PathConstraint">PathConstraint</a> <!-- <a href="#dfn-PropertyConstraint">PropertyConstraint</a> --> <code class="param">constraint</code>; other properties identify other forms of <code class="param">targets</code>, <code class="param">filters</code> and <code class="param">constraints</code>.
        These properties will be enumerated in the definitions below.
      </p>
      </div>
        <p>
        	The SHACL instance graph identifies the nodes in the data graph selected through <code class="param">targets</code> and <code class="param">filters</code> and that will be compared against the defined constraints.
          The data graph nodes that are identified by the <code class="param">targets</code> and <code class="param">filters</code> are call "focus nodes". Focus nodes are all nodes in the graph that:
        </p>
        
      <ol>
        <li>match any of the targets, and </li>
        <li>pass all of the filter Shapes. [deal with this somewhere (Targets in filter Shapes have no effect.)]</li>
      </ol>
      <p>
        SHACL can be used for documenting data structures or the input and output of processes, driving user interface generation or navigation because these processes all require testing some nodes in a graph against shapes.
        The process is called "validation" and the result is called a "validation result".
        The validation result is <span class="fail">fail</span> if validating any Test against each "focus node" returned <span class="fail">fail</span>, otherwise the result is <span class="pass">pass</span>.
      </p>

    </section>

    <section>
      <h2 id="Constraints">Constraints</h2>
      <div class="abstrsynt">
        <span class="math" id="dfn-Constraint">Constraint    := <a href="#dfn-NodeConstraint">NodeConstraint</a>|<a href="#dfn-PathConstraint">PathConstraint</a><!-- <a href="#dfn-PropertyConstraint">PropertyConstraint</a>|<a href="#dfn-InversePropertyConstraint">InversePropertyConstraint</a> --><span class="newref">|<a href="#dfn-PartitionConstraint">PartitionConstraint</a></span></span>
      </div>
      <p>
        Both PathConstraints <!-- PropertyConstraint or InversePropertyConstraint --> and NodeConstraints include a set of <a href="#dfn-Parameter">Parameters</a>.
        Constraints select a set of "value nodes" and then test the conformance of the value nodes against each Parameter.
      </p>

      <p class="issue">
        It's possible that renaming Constraints to Selectors and Parameters to Constraints would clarify this specification.
        Please send feedback to <a href="mailto:public-rdf-shapes@w3.org">public-rdf-shapes</a>.
      </p>

      <p>
        Parameters are either unary or n-ary.
        Validation of a unary Parameter can be performed on each value node individually.
        The result of validating a set of value nodes against a set of unary parameters is <span class="fail">fail</span> if any individual value node failed any Parameter, otherwise <span class="pass">pass</span>.
        The result of validating a set of value nodes against a set of n-ary parameters is <span class="fail">fail</span> if the set of value nodes failed any Parameter, otherwise it is <span class="pass">pass</span>.
        Both NodeConstraint and PathConstraint <span class="fail">fail</span> if any Parameter in <span class="param">parms</span> fails.
      </p>

      <p>
        Note that the Paramenter arguments include "numeric" which is the set of SPARQL numeric types enumerated in SPARQL Operand Data Types <a href="http://www.w3.org/TR/sparql11-query/#operandDataTypes">SPARQL Operand Data Types</a>.
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-NodeConstraint">NodeConstraint := <code class="param">parms</code>:Set[<a href="#dfn-Parameter">Parameter</a>]</span>
      </div>
      <p>
        Testing a NodeConstraint against a focus node returns all of the errors from testing each Parameter (Node Constraint Parameter) against the value node where the value node is the focus node.
      </p>

      <!-- 
      <div class="abstrsynt">
        <span class="math" id="dfn-PropertyConstraint">PropertyConstraint := <code class="param">predicate</code>:IRI, <code class="param">parms</code>:Set[<a href="#dfn-PCParameter">PCParameter</a>]</span>
      </div>
      <p>
        Testing a PropertyConstraint against a focus node returns all of the errors from testing each PCParameter against each value node in the triple <code>(focus node, predicate, value node)</code>.
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-InversePropertyConstraint">InversePropertyConstraint := <code class="param">predicate</code>:IRI, <code class="param">parms</code>:Set[<a href="#dfn-IPCParameter">IPCParameter</a>]</span>
      </div>
      <p>
        Testing an InversePropertyConstraing against a focus node returns all of the errors from testing each IPCParameter against each value node in the triple <code>(value node, predicate, focus node)</code>.
      </p>
      -->

      <div class="abstrsynt">
        <span class="math" id="dfn-PathConstraint">PathConstraint := <code class="param">path</code>:<a href="http://www.w3.org/TR/sparql11-query/#pp-language">SPARQLPropertyPath</a>, <code class="param">parms</code>:Set[<a href="#dfn-Parameter">Parameter</a>]</span>
      </div>
      <p>
        A SPARQLPropertyPath is a property path as defined in [[!sparql11-query]].
        Testing a PathConstraint against a focus node returns all of the errors from testing each Parameter against each value node in the <a href="http://www.w3.org/TR/sparql11-query/#defn_PropertyPathPattern">SPARQL1.1 Property Path Pattern</a> <code>(focus node, <code class="param">path</code>, value node)</code>.
        The <code class="param">path</code> is an expression in the <a href="http://www.w3.org/TR/sparql11-query/#pp-language">SPARQL1.1 Property Path language</a> excluding the forms of negation: <code>NegatedPropertySet</code>.
        Note that this includes <code>InversePath</code>.
      </p>

      <div class="newframe">
      <div class="abstrsynt">
        <span class="math" id="dfn-PartitionConstraint">PartitionConstraint := <code class="param">expression</code>:<a href="#dfn-Sexpr">Sexpr</a>, <code class="param">extra</code>:Set[IRI]</span><br/>
        <span class="math" id="dfn-Sexpr">Sexpr    := <a href="#dfn-Choice">Choice</a>|<a href="#dfn-Group">Group</a>|<a href="#dfn-PathConstraint">PathConstraint</a></span><br/>
        <span class="math" id="dfn-Choice">Choice := <code class="param">exprs</code>:Set[<a href="#dfn-Sexpr">Sexpr</a>]</span><br/>
        <span class="math" id="dfn-Group">Group := <code class="param">exprs</code>:Set[<a href="#dfn-Sexpr">Sexpr</a>]</span>
      </div>
      <p id="satisfies-PartitionConstraint">
        Validation of a PartitionConstraint depends on evaluation of <code>matches</code> <a href="#matches">defined below</a>.<br/>
        Let <span class="label">neigh</span> (the "neighborhood") be the union of every triple <code>(focus node, _, _)</code> and <code>(_, _, focus node)</code>.
        Testing a PartitionConstraint returns <span class="pass">pass</span> if and only if:
      </p>
      <ul>
        <li>
          <code class="var">neigh</code> can be partitioned into two sets <m>matched</m> and <m>remainder</m> such that <code class="function">matches(<m>matched</m>, <span class="param">expression</span>, <m>m</m>)</code>.
          If <span class="param">expression</span> is absent, <code class="function"><m>remainder</m> = neigh</code>.<br/>
          Let <span class="label">outs</span> be the arcsOut in <m>remainder</m>:
          <code class="function"><m>outs</m> = <m>remainder</m> ∩ arcsOut(<m>G</m>, <m>n</m>)</code>.<br/>
          Let <span class="label">matchables</span> be the triples in <m>outs</m> whose predicate appears in a <span class="jobjref"><a href="#dfn-TripleConstraint" class="obj">TripleConstraint</a></span> in <span class="param">expression</span>.
          If <span class="param">expression</span> is absent, <code class="function"><m>matchables</m> = <m>Ø</m> (the empty set)</code>.<br/>
        </li>
        <li>
          There is no triple in <span class="label">matchables</span> which matches a <span class="jobjref"><a href="#dfn-TripleConstraint" class="obj">TripleConstraint</a></span> in <span class="param">expression</span>.<br/>
          Let <span class="label">unmatchables</span> be the triples in <m>outs</m> which are not in <m>matchables</m>.
          <code class="function"><m>matchables</m> ∪ <m>unmatchables</m> = <m>outs</m></code>.
        </li>
        <li>
          There is no triple in <m>matchables</m> whose predicate does not appear in <span class="param">extra</span>.
        </li>
        <li><span class="param">closed</span> is false or <m>unmatchables</m> is empty.</li>
      </ul>
      <p>
        <span class="label" id="matches">matches</span>: asserts that a triple expression is matched by a set of triples that come from the neighbourhood of a node in an RDF graph.
        The expression <code>matches(<m>T</m>, <m>expr</m>, <m>m</m>)</code> indicates that a set of triples <m>T</m> can satisfy these rules:
      </p>
      <ul>
        <li>
          <p id="matches-Choice"><m>expr</m> is a <span class="jobjref"><a href="#dfn-Choice" class="obj">Choice</a></span> and there is some expression <m>se2</m> in <span class="param">exprs</span> such that a <code class="function">matches(<m>T</m>, <m>se2</m>, <m>m</m>)</code>.</p>
          <!-- div class="example"></div -->
        </li>
        <li>
          <p id="matches-Group"><m>expr</m> is a <span class="jobjref"><a href="#dfn-Group" class="obj">Group</a></span> and there is some partition of <m>T</m> into <m>T<sub>1</sub></m>, <m>T<sub>2</sub></m>,… such that for every expression <span class="function"><m>expr<sub>1</sub></m>, <m>expr<sub>2</sub></m>,…</span> in <span class="param">exprs</span>, <code class="function">matches(<m>T<sub>n</sub></m>, <m>expr<sub>n</sub></m>, <m>m</m>)</code>.</p>
          <!-- div class="example"></div -->
        </li>
        <li>
          <p id="matches-PathConstraint"><m>expr</m> is a <span class="jobjref"><a href="#dfn-PathConstraint" class="obj">PathConstraint</a></span> whose evaluation over a graph G - neigh + T (the data graph without the neighborhood but with the partition) returns <span class="pass">pass</span>.</p>
        </li>
      </ul>
      <div class="example">
        <div class="example-title marker"><span>Partition example 1</span></div>
        <pre class="schema">&lt;EmployeeShape&gt; sh:partition [
  sh:or (
    [ sh:property [
        sh:predicate foaf:name ; sh:minCount 1 ; sh:maxCount 1 ] ]
    [ sh:and (
        [ sh:property [
            sh:predicate foaf:givenName ; sh:minCount 1 ; sh:maxCount 1 ] ]
        [ sh:property [
            sh:predicate foaf:familyName ; sh:minCount 1 ; sh:maxCount 1 ] ]
      ) ] ] .</pre>
        <pre class="data">
&lt;employee1&gt; foaf:name "Bob Smith" .
&lt;employee2&gt; foaf:givenName "Bob" ; foaf:familyName "Smith" .
<span class="fail">&lt;employee3&gt; ex:otherProp "some value" .</span>
<span class="fail">&lt;employee4&gt; foaf:name "Bob Smith" ; foaf:familyName <span style="border-bottom: thin solid red;">"Smith"</span> .</span></pre>
        <table>
          <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
          <tr class="pass"><td>&lt;EmployeeShape&gt;</td><td>&lt;employee1&gt;</td><td>pass</td></tr>
          <tr class="pass"><td>&lt;EmployeeShape&gt;</td><td>&lt;employee2&gt;</td><td>pass</td></tr>
          <tr class="fail"><td>&lt;EmployeeShape&gt;</td><td>&lt;employee3&gt;</td><td>fail</td><td class="fail">expected either <code>foaf:name</code> or <code>foaf:givenName</code> and <code>foaf:familyName</code>.</td></tr>
          <tr class="fail"><td>&lt;EmployeeShape&gt;</td><td>&lt;employee4&gt;</td><td>fail</td><td class="fail">expected <em>only</em> one of <code>foaf:name</code> or <code>foaf:givenName</code> and <code>foaf:familyName</code>.</td></tr>
        </table>
        <p>
        </p>
      </div>

      </div>
    </section>

    <section>
      <h2 id="Parameters">Parameters</h2>
      <div class="abstrsynt">
        <span class="math" id="dfn-Parameter">Parameter     :=
        <a href="#dfn-UnaryParameter">UnaryParameter</a> |
        <a href="#dfn-NaryParameter">NaryParameter</a>
        </span>
      </div>
      <p>
        The specific ways a value or value set can be constrained are called <code>Parameters</code>.
        They are grouped below into unary and n-ary parameters depending on whether they evaluate a value node or a set of value nodes.
        Parameters take one or more arguments.
      </p>
      <p id="PC">
        Note that RDF graphs do not include triples with a literal subject so tests of literal values can only succeed if applied to <a href="#dfn-PathConstraint">PathConstraint</a> with a final path component with is not inverse.
        Other Parameters are only defined for <a href="#dfn-PathConstraint">PathConstraint</a>.
        The symbol <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup> indicates Parameters that should only be used in a <a href="#dfn-PathConstraint">PathConstraint</a>.
      </p>
      <section>
        <h3 id="UnaryParameters">Unary Parameters</h3>
        <p>
          Unary Parameters evaluate each node in the set of value nodes that were selected by the <a href="#dfn-Constraint">Constraints</a>.
        </p>

        <div class="abstrsynt">
          <span class="math" id="dfn-UnaryParameter">UnaryParameter     :=
          <a href="#dfn-NodeKind">NodeKind</a> |
          <a href="#dfn-In">In</a> |
          <a href="#dfn-Class">Class</a> |
          <a href="#dfn-Datatype">Datatype</a> |
          <!-- <a href="#dfn-DatatypeIn">DatatypeIn</a> | -->
          <a href="#dfn-MinLength">MinLength</a> |
          <a href="#dfn-MaxLength">MaxLength</a> |
          <a href="#dfn-Pattern">Pattern</a> |
          <a href="#dfn-Stem">Stem</a> |
          <a href="#dfn-MinInclusive">MinInclusive</a> |
          <a href="#dfn-MinExclusive">MinExclusive</a> |
          <a href="#dfn-MaxInclusive">MaxInclusive</a> |
          <a href="#dfn-MaxExclusive">MaxExclusive</a> |
          <a href="#dfn-LessThanOrEquals">LessThanEquals</a> |
          <a href="#dfn-LessThan">LessThan</a> |
          <a href="#dfn-Equals">Equals</a> |
          <a href="#dfn-Disjoint">Disjoint</a> |
          <a href="#dfn-HasShape">HasShape</a>
          </span>
        </div>

        <section>
          <h4 id="RDFtermtypeofvaluenode">RDF term type of value node<!-- : NC, PC, IPC --></h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-NodeKind">NodeKind      := <code class="param">kind</code>:"IRI"|"blank node"|"literal"</span>
          </div>
          <p>
            Testing a NodeKind parameter against a value node returns <span class="fail">fail</span> if
          </p>
          <ul>
            <li><code class="param">kind</code> = "IRI" and value node is not an IRI</li>
            <li><code class="param">kind</code> = "blank node" and value node is not a blank node</li>
            <li><code class="param">kind</code> = "literal" and value node is not an RDFLiteral</li>
          </ul>
          <p class="rdf">
            A NodeKind parameter is connected to a constraint by the <code>sh:nodeKind</code> predicate; the node kinds are represented by the constants <code>sh:IRI</code>, <code>sh:BlankNode</code> and <code>sh:Literal</code> respectively.
            The following combinations represent disjunctions of the above node kinds: <code>sh:BlankNodeOrIRI</code>, <code>sh:IRIOrLiteral</code>, <code>sh:BlankNodeOrLiteral</code>, <code>sh:IRIOrLiteral</code>, <code>sh:BlankNodeOrIRI</code>, <code>sh:BlankNodeOrLiteral</code>.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 1</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [ sh:predicate ex:state; sh:nodeKind sh:IRI ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:state ex:HunkyDory .
&lt;issue2&gt; <span style="border-bottom: thin solid red;">ex:staet</span> ex:GoodEnough . # Note mispelling of "state"
<span class="fail">&lt;issue3&gt; ex:state "just fine" .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>ex:state</code> expected to be an IRI, literal found.</td></tr>
            </table>
            <p>
              Note that &lt;issue2&gt; <span class="pass">passes</span> even though it has no <code>sh:state</code> property.
              To require a property, one must use cardinality parameters as described below in <a href="#Cardinality">Cardinality</a>.
            </p>
          </div>

        </section>

        <section>
          <h4 id="RDFtermequivalence">RDF term equivalence<!-- : NC, PC, IPC --></h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-In">In            := <code class="param">vals</code>:Set[RDF term]</span>
          </div>
          <p>
            Testing a In parameter against a value node returns <span class="fail">fail</span> if the value node is not in the set <code class="param">vals</code>.
          </p>
          <p class="rdf">
            An In parameter in RDF is represented as an RDF collection connected to a constraint by the <code>sh:in</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 3</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [ sh:predicate ex:state; sh:in (ex:Resolved, ex:Rejected) ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:state ex:Resolved .
<span class="fail">&lt;issue2&gt; ex:state ex:Unresolved .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail"><code>ex:state</code> expected to be <code>ex:Resolved</code> or <code>ex:Rejected</code>, <code>ex:Unresolved</code> found.</td></tr>
            </table>
          </div>
          <p class="note">
            The n-ary variant <a class="math" href="#dfn-HasValue">HasValue</a> passes if <em>any</em> value matches the supplied argument.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-Class">Class         := t:IRI</span>
          </div>
          <p>
            Testing a Class parameter against a value node returns <span class="fail">fail</span> if there is no triple <code>(focus node, rdf:type, X)</code> where X is the subject of any triple matched by the <a href="http://www.w3.org/TR/sparql11-query/#pp-language">SPARQL1.1 path expression</a> <code>(X, rdf:subClassOf*, <code class="param">t</code>)</code>.
          </p>
        </section>

        <section>
          <h4 id="Datatype">Datatype<!-- : NC, PC --></h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-Datatype">Datatype      := <code class="param">dt</code>:IRI</span>
          </div>
          <p>
            Testing a Datatype parameter against a value node returns <span class="fail">fail</span> if the value node is not an RDFLiteral or of the datatype of the value node is not the same RDF term as <code class="param">dt</code>.
          </p>
          <p class="rdf">
            A Datatype parameter is connected to a constraint by the <code>sh:datatype</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 4</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [ sh:predicate ex:submittedOn; sh:datatype xsd:dateTime ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:submittedOn "2016-07-08"^^xsd:date .
<span class="fail">&lt;issue2&gt; ex:submittedOn "2016-07-08T01:23:45Z"^^xsd:dateTime .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail"><code>ex:submittedOn</code> expected to be an <code>xsd:date</code>, <code>xsd:dateTime</code> found.</td></tr>
            </table>
          </div>

          <!-- 
          <div class="abstrsynt">
            <span class="math" id="dfn-DatatypeIn">DatatypeIn    := <code class="param">dts</code>:Set[IRI]</span>
          </div>
          <p>
            Testing a Datatype parameter against a value node returns <span class="fail">fail</span> if the value node is not an RDFLiteral or of the datatype of the value node is not the set <code class="param">dts</code>.
          </p>
          <p class="issue">Does DatatypeIn have enough use cases to warrant a special property rather than an <a href="#dfn-Or">or</a> of multiple <a href="#dfn-Datatype">Datatype</a> constraints?</p>
          -->
        </section>

        <section>
          <h4 id="XMLSchemastringfacets">XML Schema string facets<!-- : NC, PC, IPC --></h4>
          <div class="abstrsynt">
            <span class="math" id="dfn-MinLength">MinLength     := <code class="param">ref</code>:numeric</span>
          </div>
          <p>
            Testing a MinLength paramenter against a value node returns <span class="fail">fail</span> if the lexical form of the value node is shorter than <code class="param">ref</code>.
          </p>
          <p class="rdf">
            A MinLength parameter is connected to a constraint by the <code>sh:minLength</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 5</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [ sh:predicate ex:submittedBy; sh:minLength 20 ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:submittedBy &lt;http://a.example/bob&gt; . <span class="comment"># 20 characters</span>
<span class="fail">&lt;issue2&gt; ex:submittedBy "Bob" .</span> <span class="comment"># 3 characters</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail"><code>ex:submittedOn</code> expected to be &gt;= 20 characters,<br/> 3 characters found.</td></tr>
            </table>
          </div>

          <div class="abstrsynt">
            <span class="math" id="dfn-MaxLength">MaxLength     := <code class="param">ref</code>:numeric</span>
          </div>
          <p>
            Testing a MaxLength paramenter against a value node returns <span class="fail">fail</span> if the lexical form of the value node is longer than <code class="param">ref</code>.
          </p>
          <p class="rdf">
            A MaxLength parameter is connected to a constraint by the <code>sh:maxLength</code> predicate.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-Pattern">Pattern       := <code class="param">pat</code>:RDFLiteral, <code class="param">flagstr</code>:RDFLiteral</span>
          </div>
          <p>            
            A Pattern parameter is evaluated against the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL regex function</a> with the lexical form of the value node as the <code class="param">text</code> parameter, <code class="param">pat</code> as the <code class="param">pattern</code> parameter and <code class="param">flagstr</code> as the <code class="param">flags</code> parameter.
            The test returns <span class="fail">fail</span> is the result is false or produces an XPath type error.
          </p>
          <p class="rdf">
            A Pattern parameter is connected to a constraint by the <code>sh:pattern</code> predicate.
            An optional <code>sh:flags</code> property can supply the <code class="param">flags</code> parameter.
            It is an error for a constraint to have more than one <code>sh:flags</code> property or a single <code>sh:flags</code> property and more than one <code>sh:pattern</code> property.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 6</span></div>
            <pre class="schema">
&lt;IssueShape1&gt; sh:property [ sh:predicate ex:submittedBy; sh:pattern "^HtTp://" ; sh:flags "i" ] .
&lt;IssueShape2&gt; sh:property [ sh:predicate ex:submittedBy; sh:pattern " +" ; sh:flags "@" ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:submittedBy &lt;http://a.example/bob&gt; . <span class="comment"># matches &lt;IssueShape1&gt;'s case-insensitive pattern</span>
&lt;issue2&gt; ex:submittedBy "http://hahaha!" . <span class="comment"># also matches &lt;IssueShape1&gt;'s pattern</span>
<span class="fail">&lt;issue3&gt; ex:submittedBy &lt;mailto:bob@example.com&gt; .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape1&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="pass"><td>&lt;IssueShape1&gt;</td><td>&lt;issue2&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape1&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>mailto:bob@example.com</code> does not match the pattern <code>/^HtTp:\/\//i</code></td></tr>
              <tr class="fail"><td>&lt;IssueShape2&gt;</td><td>&lt;issue1&gt;</td><td>fail</td><td class="fail"><code>@</code> is not a valid flag string.</td></tr>
              <tr class="fail"><td>&lt;IssueShape2&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail"><code>@</code> is not a valid flag string.</td></tr>
            </table>
          </div>

          <div class="abstrsynt">
            <span class="math" id="dfn-Stem">Stem          := <code class="param">str</code>:RDFLiteral</span>
          </div>
          <p>
            Testing a Stem parameter against a value node returns <span class="fail">fail</span> if the value node is not an IRI or the lexical form of the value node does not start with <code class="param">str</code>.
          </p>

        </section>

        <section>
          <h4 id="XMLSchemanumericfacets">XML Schema numeric facets<!-- : NC, PC --></h4>
          <div class="abstrsynt">
            <span class="math" id="dfn-MinInclusive">MinInclusive  := <code class="param">ref</code>:RDFLiteral <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup></span>
          </div>
          <p>
            Testing a MinInclusive parameter against a value node returns <span class="fail">fail</span> if the evaluation of (value node &gt;= <code class="param">ref</code>) in <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator Mapping</a> returns false or results in a type error.
          </p>
          <p class="rdf">
            A MinInclusive parameter is connected to a constraint by the <code>sh:minInclusive</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 7</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [ sh:predicate ex:confirmations; sh:minInclusive 1 ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:confirmations 1 .
&lt;issue2&gt; ex:confirmations 0 .
<span class="fail">&lt;issue3&gt; ex:confirmations "ii"^^ex:romanNumeral .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail"><code>0</code> is less than <code>1</code>.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>ex:romanNumeral</code> is not a numeric datatype.</td></tr>
            </table>
          </div>

          <div class="abstrsynt">
            <span class="math" id="dfn-MinExclusive">MinExclusive  := <code class="param">ref</code>:RDFLiteral <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup></span>
          </div>
          <p>
            Testing a MinExclusive parameter against a value node returns <span class="fail">fail</span> if the evaluation of (value node &gt; <code class="param">ref</code>) in <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator Mapping</a> returns false or results in a type error.
          </p>
          <p class="rdf">
            A MinExclusive parameter is connected to a constraint by the <code>sh:minExclusive</code> predicate.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-MaxInclusive">MaxInclusive  := <code class="param">ref</code>:RDFLiteral <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup></span>
          </div>
          <p>
            Testing a MaxInclusive parameter against a value node returns <span class="fail">fail</span> if the evaluation of (value node &lt;= <code class="param">ref</code>) in <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator Mapping</a> returns false or results in a type error.
          </p>         
          <p class="rdf">
            A MaxInclusive parameter is connected to a constraint by the <code>sh:maxInclusive</code> predicate.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-MaxExclusive">MaxExclusive  := <code class="param">ref</code>:RDFLiteral <sup>
			</sup></span>
          </div>
          <p>
            Testing a MaxExclusive parameter against a value node returns <span class="fail">fail</span> if the evaluation of (value node &lt; <code class="param">ref</code>) in <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator Mapping</a> returns false or results in a type error.
          </p>
          <p class="rdf">
            A MaxExclusive parameter is connected to a constraint by the <code>sh:maxExclusive</code> predicate.
          </p>

        </section>

        <section>
          <h4 id="Comparisonwithcompareproperty">Comparison with specified property<!-- : PC --></h4>
          <p>
            Comparison parameters compare the value node against each value reachable by a specified property <code>compareProp</code>.
            Note that these are limited to arcs out of the focus node, that is, those triples matching <code>(focus node, <code class="param">compareProp</code>, _)</code>.
          </p>
          <div class="abstrsynt">
            <span class="math" id="dfn-LessThanOrEquals">LessThanOrEquals := <code class="param">compareProp</code>:RDFLiteral</span> <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup>
          </div>
          <p>
            Let <code class="var">compareVals</code> be the set of objects in triples matching <code>(focus node, <code class="param">compareProp</code>, <code class="var">compareVal</code>)</code>.
            Testing a LessThanOrEquals parameter against a value node returns <span class="fail">fail</span> if evaluating the <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator</a> (value node = <code class="var">compareVal</code>) for any <code class="var">compareVal</code> in <code class="var">compareVals</code> returns false or results in a type error.
          </p>
          <p class="rdf">
            A LessThanOrEqual's <code class="param">compareProp</code> parameter is connected to a constraint by the <code>sh:lessThanOrEquals</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 8</span></div>
            <p>
              Different departments can assign different criticalities (how important is it) and priorities (how soon should it get fixed) to issues and no priority may be lower than a criticality:
            </p>
            <pre class="schema">
# In this example, a lower number means higher priority or criticality.
&lt;IssueShape&gt; sh:property [ sh:predicate ex:priority; sh:lessThanEquals ex:criticality ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:criticality 3; ex:priority 2 .
&lt;issue2&gt; ex:priority 1, 4 . # No criticality against which to compare
&lt;issue3&gt; ex:criticality <span class="fail">2</span>, 5; ex:priority 1, <span class="fail">4</span> .
&lt;issue4&gt; ex:criticality <span class="fail">ex:Low</span>; ex:priority <span class="fail">ex:Medium</span> .
&lt;issue5&gt; ex:criticality <span class="fail">ex:Low</span>; ex:priority <span class="fail">1</span> .</pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>4</code> greater than <code>2</code>.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue4&gt;</td><td>fail</td><td class="fail"><code>"Medium"</code> greater than <code>"Low"</code>.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue5&gt;</td><td>fail</td><td class="fail"><code>1</code> not comparable with <code>ex:Low</code>.</td></tr>
            </table>
          </div>

          <div class="abstrsynt">
            <span class="math" id="dfn-LessThan">LessThan      := <code class="param">compareProp</code>:RDFLiteral</span> <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup>
          </div>
          <p>
            Let <code class="var">compareVals</code> be the set of objects in triples matching <code>(focus node, <code class="param">compareProp</code>, <code class="var">compareVal</code>)</code>.
            Testing a LessThan parameter against a value node returns <span class="fail">fail</span> if evaluating the <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator</a> (value node &lt; <code class="var">compareVal</code>) for any <code class="var">compareVal</code> in <code class="var">comapreVals</code> returns false or results in a type error.
          </p>
          <p class="rdf">
            A LessThan's <code class="param">compareProp</code> parameter is connected to a constraint by the <code>sh:lessThan</code> predicate.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-Equals">Equals        := <code class="param">compareProp</code>:RDFLiteral</span> <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup>
          </div>
          <p>
            Let <code class="var">compareVals</code> be the set of objects in triples matching <code>(focus node, <code class="param">compareProp</code>, <code class="var">compareVal</code>)</code>.
            Testing an Equals parameter against a value node returns <span class="fail">fail</span> if evaluating the <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator</a> (value node = <code class="var">compareVal</code>) for any <code class="var">compareVal</code> in <code class="var">compareVals</code> returns false or results in a type error.
          </p>
          <p class="rdf">
            A Equal's <code class="param">compareProp</code> parameter is connected to a constraint by the <code>sh:equals</code> predicate.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-Disjoint">Disjoint      := <code class="param">compareProp</code>:RDFLiteral</span>
          </div>
          <p>
            Let <code class="var">comapreVals</code> be the set of objects in triples matching <code>(focus node, <code class="param">compareProp</code>, <code class="var">compareVal</code>)</code>.
            Testing a Disjoint parameter against a value node returns <span class="fail">fail</span> if evaluating the <a href="http://www.w3.org/TR/sparql11-query/#OperatorMapping">SPARQL1.1 Operator</a> (value node != <code class="var">compareVal</code>) for any <code class="var">compareVal</code> in <code class="var">compareVals</code> returns false or results in a type error.
          </p>
          <p class="rdf">
            A Disjoint's <code class="param">compareProp</code> parameter is connected to a constraint by the <code>sh:disjoint</code> predicate.
          </p>

        </section>

        <section>
          <h4 id="Nestedshapeconstraints">Nested shape constraints<!-- : PC, IPC --></h4>
          <div class="abstrsynt">
            <span class="math" id="dfn-HasShape">HasShape      := nested:Shape</span>
          </div>
          <p>
            Testing a HasShape parameter against a value node returns any errors returned when validating the value node as nested (c.f. definition of <a class="math" href="#dfn-Shape">Shape</a> above).
          </p>
          <p class="rdf">
            A Disjoint's <code class="param">nested</code> parameter is connected to a constraint by the <code>sh:shape</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 9</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [
    sh:predicate ex:submittedBy; sh:shape &lt;UserShape&gt; ] .
&lt;UserShape&gt; sh:property [
    sh:predicate dc:creator; sh:nodeKind sh:IRI ] . </pre>
            <pre class="data">
&lt;issue1&gt; ex:submittedBy [ dc:creator &lt;mailto:alice@example.com&gt; ] .
<span class="fail">&lt;issue2&gt; ex:submittedBy [ dc:creator <span style="border-bottom: thin solid red;">"amy"</span> ] .</span>
<span class="fail">&lt;issue3&gt; ex:submittedBy &lt;mailto:andrea@example.com&gt; .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail">expected <code>dc:creator</code> to be an IRI.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail">expected <code>ex:submittedBy</code> to match <code>&lt;UserShape&gt;</code>.</td></tr>
            </table>
          </div>
        </section>
      </section>
      <section>
        <h3 id="N-aryParameters">N-ary Parameters</h3>
        <p>
          N-ary Parameters evaluate the set of value nodes which were selected by the <a href="#dfn-Constraint">Constraints</a>.
        </p>
        <div class="abstrsynt">
          <span class="math" id="dfn-NaryParameter">NaryParameter     :=
          <a href="#dfn-UniqueLang">UniqueLang</a> |
          <a href="#dfn-HasValue">HasValue</a> |
          <a href="#dfn-MinCount">MinCount</a> |
          <a href="#dfn-MaxCount">MaxCount</a> |
          <a href="#dfn-QualifiedMinCount">QualifiedMinCount</a> |
          <a href="#dfn-QualifiedMaxCount">QualifiedMaxCount</a> |
          <a href="#dfn-QualifiedValueShape">QualifiedValueShape</a>
          </span>
        </div>

        <section>
          <h4 id="Uniqueness">Uniqueness<!-- : NC, PC, IPC --></h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-UniqueLang">UniqueLang    := <code class="param">b</code>:boolean <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup></span>
          </div>
          <p>
            Testing a UniqueLang parameter against a set of value nodes returns <span class="fail">fail</span> if <code class="param">b</code> is <code>true</code> and two or more of the value nodes are RDFLiterals with the same language tag.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 10</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [ sh:predicate ex:label; sh:uniqueLang true ] ;
             sh:property [ sh:predicate ex:description; sh:uniqueLang false ] ;
             sh:property [ sh:predicate ex:notes; sh:nodeKind sh:Literal ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:description "no Save As support"@en, "pas de Sauvegarder Sous"@fr ;
         ex:description "there's no way to save a document under another filename"@en ;
         ex:notes "Should ADB take care of this?"@en .
&lt;issue2&gt; <span class="fail">ex:label "grammar conflict"@en, "conflit analyse"@en</span> ;
         ex:description "shift/reduce confict"@en, "reduce/reuse/recycle conflict"@en ;
         ex:notes "tried left factor"@en, "tried substitution"@en .
&lt;issue3&gt;
         ex:description "vague reports of random crashes"@en .
</pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail">multiple <code>ex:label</code> values with same language tag.</td></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>pass</td></tr>
            </table>
          </div>
        </section>

        <section>
          <h4 id="Nary-RDFtermequivalence">RDF term equivalence<!-- : NC, PC, IPC --></h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-HasValue">HasValue      := <code class="param">val</code>:RDF term</span>
          </div>
          <p>
            Testing a HasValue parameter against a value node returns <span class="fail">fail</span> if the set of value nodes is non-empty and no element of value nodes is the same term as <code class="param">val</code>.
          </p>
          <p class="rdf">
            A HasValue parameter is connected to a constraint by the <code>sh:hasValue</code> predicate.
          </p>
          <div class="example">
            <div class="example-title marker"><span>Parameters example 2</span></div>
            <pre class="schema">
&lt;ResolvedIssueShape&gt; sh:property [ sh:predicate ex:state; sh:hasValue ex:Resolved ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:state ex:Resolved .
&lt;issue2&gt; ex:state ex:Resolved, ex:Referred .
<span class="fail">&lt;issue3&gt; ex:state ex:Unresolved, ex:Referred .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;ResolvedIssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="pass"><td>&lt;ResolvedIssueShape&gt;</td><td>&lt;issue2&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;ResolvedIssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail"><code>ex:state</code> expected to be <code>ex:Resolved</code>, <code>ex:Unresolved</code> found.</td></tr>
            </table>
          </div>

        </section>

        <section>
          <h4 id="Cardinality">Cardinality<!-- : PC, IPC --></h4>

          <p>
            The MinCount and MaxCount Parameters on a Constraint with property P identify the minimum and maximum number of triples <code>(focus node, <code class="param">P</code>, _)</code> may exist in the instance data.
            Unless provided, the MinCount is 0 and the MaxCount in infinite.
          </p>

          <div class="abstrsynt">
            <span class="math" id="dfn-MinCount">MinCount      := <code class="param">ref</code>:numeric <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup></span>
          </div>
          <p>
            Testing a MinCount parameter against a set of value nodes returns <span class="fail">fail</span> if the number of value nodes is less than <code class="param">ref</code>.
          </p>
          
          <div class="abstrsynt">
            <span class="math" id="dfn-MaxCount">MaxCount      := <code class="param">ref</code>:numeric <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup></span>
          </div>
          <p>
            Testing a MaxCount parameter against a set of value nodes returns <span class="fail">fail</span> if the number of value nodes is greater than <code class="param">ref</code>.
          </p>

          <div class="example">
            <div class="example-title marker"><span>Parameters example 11</span></div>
            <pre class="schema">
&lt;IssueShape&gt; sh:property [ sh:predicate ex:status; sh:minCount 1; sh:maxCount 1 ] ;
             sh:property [ sh:predicate ex:notes; sh:nodeKind sh:Literal ] .</pre>
            <pre class="data">
&lt;issue1&gt; ex:status ex:Confirmed .
<span class="fail">&lt;issue2&gt; ex:status ex:Confirmed, ex:Assigned</span> .
<span class="fail">&lt;issue3&gt; ex:notes "shouldn't QC have caught this?" .</span>
</pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;IssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail">expected at most 1 <code>ex:status</code>.</td></tr>
              <tr class="fail"><td>&lt;IssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail">expected at least 1 <code>ex:status</code>.</td></tr>
            </table>
          </div>
        </section>
        <section>
          <h4 id="QualifiedCardinality">QualifiedCardinality<!-- : PC, IPC --></h4>

          <div class="abstrsynt">
            <span class="math" id="dfn-QualifiedMinCount">QualifiedMinCount := <code class="param">ref</code>:numeric <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup></span><br/>
            <span class="math" id="dfn-QualifiedMaxCount">QualifiedMaxCount := <code class="param">ref</code>:numeric <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup></span><br/>
            <span class="math" id="dfn-QualifiedValueShape">QualifiedValueShape := nested:Shape <sup><a href="#PC" title="only useful with a PathConstraint">PC</a></sup></span>
          </div>
          <p>
            QualifiedMinCount and QualifiedMaxCount restrict the set of value nodes to those that pass the Shape QualifiedValueShape.
            Once the value set is restricted, their evaluation is the same as the evaluation of MinCount and MaxCount respecctively.
          </p>

          <div class="example">
            <div class="example-title marker"><span>Parameters example 12</span></div>
            <p>
              Every approved issue must be signed by one person from<br/>engineering and at least one from quality assurance:
            </p>
            <pre class="schema">
&lt;ApprovedIssueShape&gt;
  sh:sh:property [
    sh:predicate ex:approvedBy; sh:qualifiedShape [
        sh:pattern "^mailto:.*?@engineering.example" ] ;
    sh:qualifiedMinCount 1; sh:qualifiedMaxCount 1 ] ,
  sh:sh:property [
    sh:predicate ex:approvedBy; sh:qualifiedShape [
        sh:pattern "^mailto:.*?@qa.example" ] ;
    sh:qualifiedMinCount 1 ] .
</pre>
            <pre class="data">
&lt;issue1&gt; ex:approvedBy &lt;mailto:alice@engineering.example&gt;, &lt;mailto:pat@admin.example&gt;,
    &lt;mailto:bob@qa.example&gt;, &lt;mailto:eve@qa.example&gt; .
<span class="fail">&lt;issue2&gt; ex:approvedBy <span style="border-bottom: thin solid red;">&lt;mailto:amy@engineering.example&gt;</span>,
    <span style="border-bottom: thin solid red;">&lt;mailto:brett@engeering.example&gt;</span>, &lt;mailto:cynthia@qa.example&gt;</span> .
<span class="fail">&lt;issue3&gt; ex:approvedBy &lt;mailto:angel@engineering.example&gt; .</span></pre>
            <table>
              <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
              <tr class="pass"><td>&lt;ApprovedIssueShape&gt;</td><td>&lt;issue1&gt;</td><td>pass</td></tr>
              <tr class="fail"><td>&lt;ApprovedIssueShape&gt;</td><td>&lt;issue2&gt;</td><td>fail</td><td class="fail">expected at most 1 <code>ex:approvedBy</code> matching<br/> <code>"^mailto:.*?@engineering.example"</code>.</td></tr>
              <tr class="fail"><td>&lt;ApprovedIssueShape&gt;</td><td>&lt;issue3&gt;</td><td>fail</td><td class="fail">expected at least 1 <code>ex:approvedBy</code> matching<br/> <code>"^mailto:.*?@qa.example"</code>.</td></tr>
            </table>
            <p>
              Additional <code>ex:approvedBy</code> matching neither "^mailto:.*?@engineering.example" nor "^mailto:.*?@qa.example" are not constrainted, c.f. <code>&lt;mailto:amy@engineering.example&gt;</code> on <code>&lt;Issue1&gt;</code>.
            </p>
          </div>

        </section>
      </section>
    </section>


    <section>
      <h4 id="Logicaloperators">Logical operators<!-- : NC, PC, IPC --></h4>

      <div class="abstrsynt">
        <span class="math" id="dfn-Algebraic">Algebraic      := <a href="#dfn-And">And</a>|<a href="#dfn-Or">Or</a>|<a href="#dfn-Not">Not</a></span>
      </div>
      <p>
        Algebraic operators provide logical combinations of shapes.
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-And">And           := <code class="param">shapes</code>:Set[<a href="#dfn-Shape">Shape</a>]</span>
      </div>
      <p>
        Testing an And parameter against a value node returns <span class="pass">pass</span> if validating each member of the set <code class="param">shapes</code> against the value node returns <span class="pass">pass</span>, otherwise <span class="fail">fail</span>.
      </p>
      <p class="rdf">
        An And parameter is an RDF Collection of <code class="param">shapes</code> connected to a constraint by the <code>sh:and</code> predicate.
      </p>
      <div class="example">
        <div class="example-title marker"><span>Algebraics example 1</span></div>
        <pre class="schema">
&lt;Person&gt; sh:property [ sh:predicate foaf:name; sh:nodeKind sh:Literal ] .
&lt;Customer&gt; sh:property [ sh:predicate corp:custId; sh:datatype xsd:integer ] .
&lt;User&gt; sh:constraint [ <span style="font-weight: bold;">sh:and</span> (&lt;Person&gt; &lt;Customer&gt;) ] .</pre>
        <pre class="data">
&lt;user1&gt; foaf:name "Alice"; corp:custId 1234 .
<span class="fail">&lt;user2&gt; foaf:name "Bob"; corp:custId <span style="border-bottom: thin solid red;">1234.0</span> .</span></pre>
        <table>
          <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
          <tr class="pass"><td>&lt;User&gt;</td><td>&lt;user1&gt;</td><td>pass</td></tr>
          <tr class="fail"><td>&lt;User&gt;</td><td>&lt;user2&gt;</td><td>fail</td><td class="fail">"1234.0" is an xsd:double.</td></tr>
        </table>
      </div>

      <div class="abstrsynt">
        <span class="math" id="dfn-Or">Or            := <code class="param">shapes</code>:Set[<a href="#dfn-Shape">Shape</a>]</span>
      </div>
      <p>
        Testing an Or parameter against a value node returns <span class="fail">fail</span> if validating each member of the set <code class="param">shapes</code> against the value node returns <span class="fail">fail</span>, otherwise <span class="pass">pass</span>.
      </p>
      <p class="rdf">
        An Or parameter is an RDF Collection of <code class="param">shapes</code> connected to a constraint by the <code>sh:or</code> predicate.
      </p>
      <div class="example">
        <div class="example-title marker"><span>Algebraics example 2</span></div>
        <pre class="schema">
&lt;Person&gt; sh:property [ sh:predicate foaf:name; sh:nodeKind sh:Literal; sh:minCount 1 ] .
&lt;Customer&gt; sh:property [ sh:predicate corp:custId; sh:datatype xsd:integer ] .
&lt;User&gt; sh:constraint [ <span style="font-weight: bold;">sh:or</span> (&lt;Person&gt; &lt;Customer&gt;) ] .</pre>
        <pre class="data">
&lt;user1&gt; foaf:name "Alice"; corp:custId 12 .
&lt;user2&gt; <span style="border-bottom: thin solid red;">foaf:givenName</span> "Bob"; corp:custId 34 .
&lt;user2&gt; foaf:name "Eve"; corp:custId <span style="border-bottom: thin solid red;">56.0</span> .
<span class="fail">&lt;user2&gt; foaf:name <span style="border-bottom: thin solid red;">[ rdfs:value "Bob" ]</span>; corp:customerId <span style="border-bottom: thin solid red;">78.0</span> .</span></pre>
        <table>
          <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
          <tr class="pass"><td>&lt;User&gt;</td><td>&lt;user1&gt;</td><td>pass</td></tr>
          <tr class="pass"><td>&lt;User&gt;</td><td>&lt;user2&gt;</td><td>pass</td></tr>
          <tr class="pass"><td>&lt;User&gt;</td><td>&lt;user3&gt;</td><td>pass</td></tr>
          <tr class="fail"><td>&lt;User&gt;</td><td>&lt;user4&gt;</td><td>fail</td><td class="fail">no foaf:name supplied <span  style="font-weight: bold;">and</span><br/>"78.0" is an xsd:double.</td></tr>
        </table>
      </div>

      <div class="abstrsynt">
        <span class="math" id="dfn-Not">Not           := <code class="param">shape</code>:<a href="#dfn-Shape">Shape</a></span>
      </div>
      <p>
        Testing a Not parameter against a value node returns <span class="pass">pass</span> if validating <code class="param">shape</code> against the value node returns <span class="fail">fail</span>, otherwise <span class="fail">fail</span>.
      </p>
      <p class="rdf">
        A Not parameter is a single <code class="param">shape</code> connected to a constraint by the <code>sh:not</code> predicate.
      </p>
      <p>
        In this example, the <span style="font-weight: bold;">not</span> inverts the truth values of the <span style="font-weight: bold;">or</span> example above.
      </p>
      <div class="example">
        <div class="example-title marker"><span>Algebraics example 3</span></div>
        <pre class="schema">
&lt;Person&gt; sh:property [ sh:predicate foaf:name; sh:nodeKind sh:Literal ] .
&lt;Customer&gt; sh:property [ sh:predicate corp:custId; sh:datatype xsd:integer ] .
&lt;User&gt; sh:constraint [ <span style="font-weight: bold;">sh:not</span> [ sh:or (&lt;Person&gt; &lt;Customer&gt;) ] ] .</pre>
        <pre class="data">
<span class="fail">&lt;user1&gt; foaf:name "Alice"; corp:custId 12 .</span>
<span class="fail">&lt;user2&gt; foaf:givenName "Bob"; corp:custId 34 .</span>
<span class="fail">&lt;user3&gt; foaf:name "Eve"; corp:custId 56.0</span> .
&lt;user4&gt; foaf:name [ rdfs:value "Bob" ]; corp:customerId 78.0 .</pre>
        <table>
          <tr><th class="schema">shape</th><th class="data">node</th><th>result</th><th>reason</th></tr>
          <tr class="fail"><td>&lt;User&gt;</td><td>&lt;user1&gt;</td><td>fail</td><td class="fail">foaf:name is an RDFLiteral <span  style="font-weight: bold;">and</span><br/>"12" is an xsd:integer.</td></tr>
          <tr class="fail"><td>&lt;User&gt;</td><td>&lt;user2&gt;</td><td>fail</td><td class="fail">"34" is an xsd:integer.</td></tr>
          <tr class="fail"><td>&lt;User&gt;</td><td>&lt;user3&gt;</td><td>fail</td><td class="fail">foaf:name is an RDFLiteral</td></tr>
          <tr class="pass"><td>&lt;User&gt;</td><td>&lt;user4&gt;</td><td>pass</td></tr>
        </table>
      </div>

    </section>

    <section>
      <h2 id="Targets">Targets</h2>
      <p>
        A SHACL target designates which nodes in the data graph will be validated against the defined constraints.
        A Target is defined either by matching a node label (TargetNode) in the data graph, a type statement using rdf:type (TargetClass) or a subject IRI (TargetSubjectsOf) or an object IRI (TargetObjectsOf.
      </p>

      <div class="abstrsynt">
        <span class="math" id="dfn-Target">Target         := <a href="#dfn-TargetNode">TargetNode</a>|<a href="#dfn-TargetClass">TargetClass</a>|<a href="#dfn-TargetSubjectsOf">TargetSubjectsOf</a>|<a href="#dfn-TargetObjectsOf">TargetObjectsOf</a></span>
      </div>
      <p>
        The simplest form of Target directly identifies nodes in the data graph:
      </p>
      <div class="abstrsynt">
        <span class="math" id="dfn-TargetNode">TargetNode     := <code class="param">node</code>:IRI|literal|BNode</span>
      </div>
      <p class="issue">
        BNodes as TargetNodes depends on being able to name a blank node in an RDF graph.
        SPARQL1.1 had this as a proposed feature but did not implement it (see <a href="https://lists.w3.org/Archives/Public/public-rdf-dawg/2005OctDec/thread#msg149">some of the SPARQL discussion</a>).
      </p>
      <p>
        A TargetNode matches <code class="param">node</code> if <code class="param">node</code> appears as a node (any subject or object in a triple) in the data graph.
      </p>
      <p class="rdf">
        A TargetNode is connected to a shape by the <code>sh:targetNode</code> property.
      </p>
      <div class="example">
        <div class="example-title marker"><span>Targets example 1</span></div>
		        <pre class="schema">
		&lt;PersonShape&gt; sh:targetNode &lt;http://a.example/Bob&gt;, &lt;http://a.example/Sue&gt; .
		&lt;NameShape&gt; sh:targetNode "Alice", "Bob" .</pre>
        <p>
          In a graph with multiple nodes:
        </p>
        <pre class="data">
			&lt;http://a.example/Alice&gt; foaf:name "Alice" ; foaf:knows &lt;http://a.example/Bob&gt; .
			&lt;http://a.example/Bob&gt; foaf:name "Bob" .
			&lt;http://a.example/Sue&gt; foaf:name "Sue" .</pre>
			&lt;PersonShape&gt; selects:
        <pre class="data">
			&lt;http://a.example/Alice&gt; foaf:name "Alice" ; foaf:knows <span class=pass>&lt;http://a.example/Bob&gt;</span> .
			<span class=pass>&lt;http://a.example/Bob&gt</span>; foaf:name "Bob" .
			<span class=pass>&lt;http://a.example/Sue&gt</span>; foaf:name "Sue" .</pre>
			&lt;NameShape&gt; selects:
        <pre class="data">
			&lt;http://a.example/Alice&gt; foaf:name <span class=pass>"Alice"</span> ; foaf:knows &lt;http://a.example/Bob&gt; .
			&lt;http://a.example/Bob&gt; foaf:name <span class=pass>"Bob"</span> .
			&lt;http://a.example/Sue&gt; foaf:name "Sue" .</pre>
      </div>

      <div class="abstrsynt">
        <span class="math" id="dfn-TargetClass">TargetClass    := <code class="param">type</code>:IRI</span>
      </div>
      <p>
        A TargetClass matches any node in the data graph with the triple
        <code>(node, rdf:type, <code class="param">type</code>)</code>
        or any node which is of a type which is a transitive <code>rdfs:subClassOf</code> <code class="param">type</code>.
      </p>
      <p class="rdf">
        A TargetClass is connected to a shape by the <code>sh:targetClass</code> property.
      </p>
      <div class="example">
        <div class="example-title marker"><span>Targets example 2</span></div>
        <p>
			        <pre class="schema">
			&lt;TeacherShape&gt; sh:targetClass ex:teacher .</pre>
          In a graph with nodes of types <code>ex:student</code>, <code>ex:teacher</code> and <code>ex:class</code>:
        </p>
        <pre class="data">
&lt;http://a.example/Alice&gt; a ex:student .
<span class="pass">&lt;http://a.example/Bob&gt;</span> a ex:professor . ex:professor rdfs:subClassOf ex:teacher .
&lt;http://a.example/Art&gt; a ex:class .</pre>
        <p>
          <code>sh:targetClass</code> selects &lt;http://a.example/Bob&gt; for validation.
        </p>
      </div>

      <div class="abstrsynt">
        <span class="math" id="dfn-TargetSubjectsOf">TargetSubjectsOf := <code class="param">predicate</code>:IRI</span>
      </div>
      <p>
        A TargetSubjectsOf matches any subject node in the data graph with a triple
        <code>(node, <code class="param">predicate</code>, _)</code> where "_" is any node. 
      </p>

      <p class="rdf">
        A TargetSubjectsOf is connected to a shape by the <code>sh:targetSubjectsOf</code> property.
      </p>
      <div class="example">
        <div class="example-title marker"><span>Targets example 3</span></div>
		        <pre class="schema">
		&lt;IssueShape&gt; sh:targetSubjectsOf ex:status .</pre>
		        <p>
        <p>
          In a graph with some triples with <code>ex:ex:submittedOn</code> predicates:
        </p>
        <pre class="data">
&lt;http://a.example/Issue1&gt; ex:submittedOn "2015-07-08" .
<span class="pass">&lt;http://a.example/Issue2&gt;</span> ex:submittedOn "2015-07-09"; ex:status ex:assigned .
<span class="pass">&lt;http://a.example/Issue3&gt;</span> ex:submittedOn "2015-07-10"; ex:status ex:resolved .</pre>
        <p>
          <code>sh:targetSubjectOf</code> selects &lt;http://a.example/Issue2&gt; and &lt;http://a.example/Issue3&gt; for valdiation.
        </p>
      </div>
      
  <div class="abstrsynt">
        <span class="math" id="dfn-TargetObjectsOf">TargetObjectsOf := <code class="param">predicate</code>:IRI</span>
      </div>
      <p>
        A TargetObjectsOf matches any object node in the data graph with a triple
        <code>(_, <code class="param">predicate</code>, node)</code> where "_" is any node. 
      </p>

      <p class="rdf">
        A TargetObjectsOf is connected to a shape by the <code>sh:targetObjectsOf</code> property.
      </p>
      <div class="example">
        <div class="example-title marker"><span>Targets example 4</span></div>
		        <pre class="schema">
		&lt;IssueShape&gt; sh:targetObjectsOf ex:waitingOn .</pre>
		        <p>
        <p>
          In a graph with some triples with <code>ex:submittedOn</code> predicates:
        </p>
        <pre class="data">
&lt;http://a.example/Workflow1&gt; ex:relatedTo &lt;http://a.example/Issue1&gt; .
&lt;http://a.example/Workflow2&gt; ex:waitingOn &lt;http://a.example/Issue2&gt; .
&lt;http://a.example/Workflow3&gt; ex:waitingOn &lt;http://a.example/Issue3&gt; .</pre>
        <p>
          <code>sh:targetObjectsOf</code> selects &lt;http://a.example/Workflow2&gt; and &lt;http://a.example/Workflow3&gt; for valdiation.
        </p>
      </div>
    
    </section>

    <script>
      $("m").wrapInner("<span class='math'/>").children(0).unwrap();
    </script>
    <script>
      var toggledElts = {
        "r": $(".rdf"),
        "e": $(".example")
      };
      function toggle (l) {
        var visibleTop = $(window).scrollTop();
        var v = l.is(":visible");
        if (!v)
          l.toggle();
        var adj = 0;
        for (var i = 0; i < l.length; ++i) {
          var elt = l.slice(i, i+1);
          if (elt.offset().top >= visibleTop) // stop when we pass the current scroll top.
            break;
          //adj += elt.outerHeight(true);
          adj += elt.outerHeight(false) + (elt.outerHeight(true) - elt.outerHeight(false))/2;
        }
        $(window).scrollTop(visibleTop + (v ? 0 - adj : adj)); // move the scroll top.
        if (v)
          l.toggle();
        return false;
      }
      var rdfElts = $(".rdf");
      $("#toggleRDF").on("click", e => { toggledElts["r"].toggle(toggledElts["r"]); });
      $("#toggleExamples").on("click", e => { toggledElts["e"].toggle(toggledElts["e"]); });
      $("html > body").keypress(function (evt) {
        if (evt.ctrlKey)
          return true; // don't interfere with browser control keys.
        var k = String.fromCharCode(evt.which).toLowerCase();
    	  if (k in toggledElts)
    	    return toggle(toggledElts[k]); // returns false meaning "don't propagate"
        if (k === "a")
          return toggleASonly(k);        // returns false meaning "don't propagate"
    	  return true;
      });
      var toggleSquished = $("#toggleSquished").on("click", toggleASonly);
      function toggleASonly (k) {
        var applyTo = toggleSquished.parent().nextAll();
        var toSquish = applyTo.find(".abstrsynt,h2,h3,h4");
        var toToggle = applyTo.find("p,ul,ol,pre,div.issue,div.example,div.note");
        toggle(toToggle);
        if (toSquish.hasClass("squished")) {
          // toToggle.show();
          toSquish.removeClass("squished");
        } else {
          // toToggle.hide();
          toSquish.addClass("squished");
        }
        return false;
      }
    </script>
  </body>
</html>
