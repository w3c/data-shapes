<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-US">
  <head>
    <title>SHACL Axiomatic Semantics</title>
    <meta charset='utf-8'></meta>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <link rel="stylesheet" type="text/css" href="local.css" />
    <script class='remove'>
      var respecConfig = {
          specStatus: "none",
          shortName:  "shacl-axiomatic",
          editors: [
					      {   name:       "Jose Emilio Labra Gayo",
                    url:        "http://www.di.uniovi.es/~labra/",
                    company:    "WESO research group",
                    companyURL: "http://www.weso.es" }
          ],
          wg:           "RDF Data Shapes Working Group",
          wgURI:        "https://www.w3.org/2014/data-shapes",
          wgPublicList: "public-rdf-shapes",
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status",
		};
    </script>
    <style>
.todo {  color: red; }
pre { tab-size: 4;  }
th { text-align: left; }
table.rule { background-color: #EBEBE0; }
table.rule td { text-align: center; }
td.up { border-bottom:1px solid black; }
table.definition { border: 1px solid black;
 border-collapse: collapse;  
}
table.definition td { border: 1px solid black; }

.comment {
 /* font-lock-comment-face */
 color: #b22222;
}

.constant {
/* font-lock-constant-face */
color: #008b8b;
}

.function-name {
/* font-lock-function-name-face */
color: #0000ff;
}
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .string {
        /* font-lock-string-face */
        color: #8b2252;
      }
      .type {
        /* font-lock-type-face */
        color: #228b22;
      }
      .example {
        display: inline-block;
      }
      .example.wrapper {
        background-color: #fff;
      }
      .example.wrapper pre {
        background-color: #fcfaee;
        margin-left: 0;
        line-height: 1.2;
      }
      .example.wrapper .fail {
        background-color: #fceefa
      }
      .verticalDivider {
        float: left;
        width: .5em;
        border:thin solid #fff; /* disappears without this */
      }
.highlight1     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 176, 0, .5); border-right: 5px solid rgba(176, 176, 0, .5); } /* font-weight: bold  ;  */
.highlight1.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
.highlight1.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 176, 0, .5);                                                } /* font-weight: bold  ;  */
.lowlight1      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid transparent; border-right: 5px solid transparent;                     } /* font-weight: normal;  */
.lowlight1.top  {    margin-top: -5px;                      border-top: 5px solid transparent;                                                          } /* font-weight: normal;  */
.lowlight1.bot  { margin-bottom: -5px;                   border-bottom: 5px solid transparent;                                                          } /* font-weight: normal;  */
.highlight2     { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(176, 0, 176, .5); border-right: 5px solid rgba(176, 0, 176, .5); } /* font-weight: bold  ;  */
.highlight2.top {    margin-top: -5px;                      border-top: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
.highlight2.bot { margin-bottom: -5px;                   border-bottom: 5px solid rgba(176, 0, 176, .5);                                                } /* font-weight: bold  ;  */
.lowlight2      { margin-left: -5px; margin-right: -5px;   border-left: 5px solid rgba(127, 127, 127, .07); border-right: 5px solid rgba(127, 127, 127, .07);         } /* font-weight: normal;  */
.lowlight2.top  {    margin-top: -5px;                      border-top: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */
.lowlight2.bot  { margin-bottom: -5px;                   border-bottom: 5px solid rgba(127, 127, 127, .07);                                                           } /* font-weight: normal;  */
.highlightBG1   { /* border: 5px solid transparent; */ background-color: #bb0; font-weight: bold; }
.lowlightBG1    { /* border: 5px solid transparent; */ font-weight: normal; }
.highlightBG2   { /* border: 5px solid transparent; */ background-color: #b00; font-weight: bold; }
.lowlightBG2    { /* border: 5px solid transparent; */ font-weight: normal; }
.new            { font-weight: bold; }
.errorSite      { color: red; }

</style>  		
 <script src="http://www.w3.org/2013/ShEx/demobits/jquery.min.js" type= "text/javascript"></script>
    <script type="text/javascript"><!--
function prepareHighlight (highlightables, onClass, offClass, slide) {
  if (slide === undefined)
    slide = $("body .namespace").last();
  $.each( highlightables, function( index, value ){
    var elts = slide.find( "."+value );
    elts
  	.mouseenter(function() {
  	    elts.removeClass(offClass).addClass(onClass);
  	})
  	.mouseleave(function() {
  	    elts.removeClass(onClass).addClass(offClass);
  	})
    .addClass(offClass);
  })
}
--> </script>
  </head>
  <body>
    <section id='abstract'>
      abstract 
    </section>

    <section id='sotd'>

      <p>
        Proposal to RDF Data Shapes WG
      </p>
    </section>

    <!-- taken from http://www.w3.org/2014/data-shapes/charter -->
    <section id="intro" class='informative'>
      <h2>Introduction</h2>
			<p>
				SHACL (Shapes Constraint Language) provides structural constraints for <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</a>.
				SHACL constraints are grouped into conjunctions called "shapes", which may also be referenced by constraints in other shapes.
				These constraints restrict the predicates of <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">triples</a> connecting nodes in the graph.
				SHACL can restrict the number of these triples and the permitted object datatype or object terms, require that the subject or object match some shape or lexical and datatype conditions.
			</p>

    </section>


<section id="FullSHACLSyntax">
<h2>SHACL syntax</h2>

<div class="todo">
 <p>This section should be removed from this document and be included in 
    the document about the high-level language</p> 
</div>

<p>A schema is a list of Labels associated with shapes

<pre>
Schema ::= Label Shape *           // Schema associates a Label with a Shape
</pre>

<p>The basic language of shapes can be recursively defined as:</p>

<pre>
Shape ::= Empty                          // No constraint
        | BasicArc Cardinality           // Arc with predicate, value and cardinality
		| BasicArc "+"                   // 1 or more basic arcs
		| BasicArc "?"                   // 0 or 1 basic arcs
		| BasicArc "*"                   // 0 or more basic arcs
	    | And (Shape1,Shape2,...ShapeN)  // Matches if all the shapes match
	    | Or (Shape1, Shape2,...ShapeN)  // Matches if there is some shape that match 
</pre>

<p>Basic arcs can be direct arcs or inverse arcs.</p>

<pre>	
BasicArc ::= Arc Predicate Value     // Direct arc
           | InvArc Predicate Value  // Inverse arc
</pre>

<p>Cardinality defines the minimum and maximum cardinality. 
   The maximum cardinality can be <code>unbounded</code></p>

<pre>
Cardinality ::= {Int,Int | unbounded}  // Min,Max-cardinality
</pre>

<p>Value specifies if an object matches 
 with a set of values <i>v1,...,vN</i>, 
 if it has a type identified by <i>URI</i> 
 or if it is an node that conforms with the shape identified by <i>Label</i>
<pre>
Value ::= ValueSet (v1 v2 ... vN) // Matches a set of values v1...vN
        | ValueType URI           // Matches if the value belongs to the type denoted by URI
        | ValueRef Label          // Matches if the value is a node that conforms with the shape identified by Label 
</pre>

<div class="todo">
 <p>TODO: Value should be extended to handle kinds like URI, BNode, Literal, 
    and language tagged literals</p> 
</div>


<div class="issue" title="extended_language">
 <p>This section includes the basic language of shapes on which there is 
    an agreement. </p>
 <p>Further extension of this language are being considered to include:
    <ul>
    <li>Extensibility mechanism to call external processors that can evaluate 
        extra constraints. Those external processors can be SPARQL, Javascript or other
        languages and will have access to the current node that is being matched. 
        They could also have access to other nodes although the mechanism by which 
        those nodes are passed to those processors is not yet defined. 
        Those processors will return a boolean value that can be used to satisfy the constraint or not.   
          
    <li>Parameterized Macros that can be used to define new constraints</li> 
    
    <li>Other language features like negations, exclusive-or, etc. 
    </ul>
</div>

</section>
<section id="example">
<h2>Example</h2>

<div class="example wrapper">
	  
<pre class="schema turtle" style="float:left;">
<span class="comment"># shapes (Turtle)</span>
<span class="function-name">sh:IssueShape</span> <span class="keyword">a</span> <span class="type">ldom:</span><span class="constant">Shape</span> ;
    <span class="state      lowlight1 top"><span class="type">ldom:</span><span class="constant">property</span> [                                     </span>
    <span class="state      lowlight1    ">    <span class="type">ldom:</span><span class="constant">predicate</span> <span class="type">ex:</span><span class="constant">state</span> ;</span>
<div class="enumChoice collection">
 <span class="state      lowlight1    "><span class="type">ldom:</span><span class="constant">allowedValue</span> <span class="stateValue lowlight2 top bot">(<span class="type">ex:</span><span class="constant">unassigned</span> <span class="type">ex:</span><span class="constant">assigned</span>)</span> ; </span>
</div>
<div class="enumChoice objectlist">    <span class="state      lowlight1    ">    <span class="type">ldom:</span><span class="constant">allowedValue</span> <span class="stateValue lowlight2 top bot"><span class="type">ex:</span><span class="constant">unassigned</span> , <span class="type">ex:</span><span class="constant">assigned</span></span> ; </span>
</div>    <span class="state      lowlight1    ">    <span class="type">ldom:</span><span class="constant">minCount</span> 1 ; <span class="type">ldom:</span><span class="constant">maxCount</span> 1               </span>
    <span class="state      lowlight1 bot">] ;                                                 </span>
    <span class="reportedBy lowlight1 top"><span class="type">ldom:</span><span class="constant">property</span> [                                     </span>
    <span class="reportedBy lowlight1    ">    <span class="type">ldom:</span><span class="constant">predicate</span> <span class="type">ex:</span><span class="constant">reportedBy</span> ;                  </span>
    <span class="reportedBy lowlight1    ">    <span class="type">ldom:</span><span class="constant">valueShape</span> <span class="user lowlight2 top bot"><span class="function-name">sh:UserShape</span></span> ;                  </span>
    <span class="reportedBy lowlight1    ">    <span class="type">ldom:</span><span class="constant">minCount</span> 1 ; <span class="type">ldom:</span><span class="constant">maxCount</span> 1               </span>
    <span class="reportedBy lowlight1 bot">] <span class="keyword">.</span>                                                 </span>

<span class="user lowlight2 top bot"><span class="function-name">sh:UserShape</span></span> <span class="keyword">a</span> <span class="type">ldom:</span><span class="constant">Shape</span> ;
    <span class="name       lowlight1 top"><span class="type">ldom:</span><span class="constant">property</span> [                                     </span>
    <span class="name       lowlight1    ">    <span class="type">ldom:</span><span class="constant">predicate</span> <span class="type">foaf:</span><span class="constant">name</span> ;                      </span>
    <span class="name       lowlight1    ">    <span class="type">ldom:</span><span class="constant">valueType</span> <span class="string lowlight2 top bot"><span class="type">xsd:</span><span class="constant">string</span></span> ;                     </span>
    <span class="name       lowlight1    ">    <span class="type">ldom:</span><span class="constant">minCount</span> 1 ; <span class="type">ldom:</span><span class="constant">maxCount</span> 1               </span>
    <span class="name       lowlight1 bot">] ;                                                 </span>
    <span class="mbox       lowlight1 top"><span class="type">ldom:</span><span class="constant">property</span> [                                     </span>
    <span class="mbox       lowlight1    ">    <span class="type">ldom:</span><span class="constant">predicate</span> <span class="type">foaf:</span><span class="constant">mbox</span> ;                      </span>
    <span class="mbox       lowlight1    ">    <span class="type">ldom:</span><span class="constant">nodeType</span> <span class="IRI lowlight2 top bot"><span class="type">ldom:</span><span class="constant">IRI</span></span> ;                        </span>
    <span class="mbox       lowlight1    ">    <span class="oneOrMore lowlight2 top bot"><span class="type">ldom:</span><span class="constant">minCount</span> 1</span>                                 </span>
    <span class="mbox       lowlight1 bot">] <span class="keyword">.                                                 </span></span>
</pre>
</div>

<p>The example can be defined in the abstract syntax as:

<pre>
IssueShape 
 (And (Arc ex:state (ValueSet (ex:unasigned ex:asigned)) {1,1})
      (Arc ex:reportedBy (ValueRef sh:UserShape) {1,1})
 )

UserShape 
 (And (Arc foaf:name (ValueType xsd:string) {1,1})
      (Arc foaf:mbox (ValueType URI) {1,unbounded})
 )
</pre>
</section>

<section id="SimplificationSyntax">

<h2>Simplification rules</h2>
<p>The basic syntax of SHACL can be further simplified using the following rules:
<p>

<pre>
basicArc+ = basicArc { 1,unbounded }
basicArc? = basicArc { 0,1 }
basicArc* = basicArc { 0,unbounded }

And(e1,e2,...eN) = And(e1,And(e2,...And(eN,Empty)))
Or(e1,e2,...eN) = Or(e1,Or(e2,...Or(eN,Empty)))
</pre>
</p>

</section>
		
<section id="AbstractSyntax">
<h2>Simple syntax</h2>
<p>The full SHACL simplified syntax can be defined as
<pre>
Shape ::= Empty                   // No constraint
       | BasicArc Cardinality     // Basic arc with cardinality
       | And Shape Shape          // Matches if E and F match
       | Or Shape Shape           // Matches if either E or F match
</pre>

</section>
		
<section id="AxiomaticSemantics">

<h2>Formal semantics</h2>

<section id="Formalism">
<h2>Description of the Formal Semantics</h2>
<p>The semantics of a Shape schema consist of a 
specification of what nodes in an RDF graph match a specific shape
with respect to that schema. 
The semantics is described formally. 
The formalism uses axioms and inference rules. 
Axioms are propositions that are provable unconditionally. 
An inference rule consists of one or more antecedents and exactly one consequent. 
An antecedent is either positive or negative. 
If all the positive antecedents of an inference rule are provable and none of the negative 
antecedents are provable, then the consequent of the inference rule is provable. </p>

<p>
The notation for inference rules separates the antecedents from the consequent 
by a horizontal line: 
the antecedents are above the line; 
the consequent is below the line. 
If an antecedent is of the form <i>not(p)</i>, 
then it is a negative antecedent; 
otherwise, it is a positive antecedent. </p>
<p>The formal semantics presented follows the same formalism as the one used for 
 <a href="http://relaxng.org/spec-20011203.html">RelaxNG</a>
</section>

<section id="Preliminaries">
<h2>Preliminaries</h2>

<section id="RDFGraphs">
<h2>RDF graphs</h2>
<p>The natural semantics infers a typing for a resource in an RDF graph. 

<p>We represent RDF graphs as sets of RDF triples, where an RDF triple is 
<i>&lt;subject,predicate,object&gt;</i>
such that 
<i>subject</i> is a <i>URI</i> or a <i>BNode</i>, 
<i>predicate</i> is a <i>URI</i> and 
<i>object</i> is a <i>URI</i>, <i>BNode</i> or <i>Literal</i>.
<p>A node is a <i>subject</i> or an <i>object</i>.

For our purposes, an RDF graph has the following operations:

<table class="definition">
<tr>
<td>{}</td><td>Empty graph (empty set of triples)</td>
</tr>
<tr>
<td>{<i>t</i>}</td>
<td>Singleton graph with triple t</td>
</tr>

<tr>
<td>g1 &cup; g2</td>
<td>Union of graphs <i>g1</i> and <i>g2</i>
</td>
</tr>

<tr>
<td>g1 &cap; g2</td>
<td>Intersection of graphs <i>g1</i> and <i>g2</i>
</tr>

<tr>
<td><i>addTriple(t,ts)</i></td>
<td>The set of triples that results of adding triple <i>t</i> to 
    the set of triples <i>ts</i>
    <p>addTriple(t,ts) = {t} &cup; ts
</td> 
</tr>

<tr>
<td><i>removeTriple(ts)</i></td>
<td>
<p>A pair <i>(t,ts')</i> where <i>t</i> is a triple removed 
   from the set of triples <i>g</i> and <i>g'</i> is the remaining triples
<p>removeTriple(ts) &isin; {(t,ts')| {t} &cup; ts' = ts &and; t &notin; ts' } 
</td>
</tr>

<tr>
<td>g.triplesAround(node)</td>
<td>
Selects the triples that contain <i>node</i> as subject or as object in graph <i>g</i>
<p>g.triplesAround(node) = { &lt;s,p,o&gt; &isin; g | s = node &or; o = node }</p>
</td>
</tr>
</table>

</section>

<section id="Typings">
<h2>Typings</h2>
<p>The semantics of SHACL consists of assigning typings to nodes in an RDF graph. 
A typing is a map from RDF nodes (iri's or bNodes) to sets of labels in a Schema.
<p> 
We define the following operations on shape typings:

<table>
<tr>
<td>{}</td><td>empty shape typing</td>
</tr>
<tr>
<td><i>addType(node,label,typing)</i></td>
<td>the result of associating type <i>label</i> 
    to <i>node</i> in <i>typing</i></td>
</tr>
<tr>
<td><i>combineTypings(t1, t2)</i></td>
<td>combination of typings <i>t1</i> and <i>t2</i></td>
</tr>
<tr>
<td><i>contains(t,node,label)</i></td>
<td>succeeds if typing <i>t</i> asserts that <i>node</i> has shape <i>label</i></td>
</tr>

</table>
</section>
		 
<section id="Context">
<h2>Context</h2>
<p>The shape schema validator acts in a context.
A context is a tuple <i>(s, g, t)</i> where
 <i>s</i> is a Schema, 
 <i>g</i> is an RDF Graph and
 <i>t</i> is a Typing. 
</p> 

We define the following operations on contexts:

<table>
<tr>
<td><i>ctx.typing</i></td><td>current typing in <i>ctx</i></td>
</tr>
<tr>
<td><i>ctx { node -> label }</i></td>
<td>Given a context with typing <i>t</i>,  
   represents the same context where typing is <i>addType(node,label,t)</i></td>
</tr>
</table>

</section>
</section>

		 
<section id="MatchNode">
<h2>matchNode</h2>

<i>ctx |- matchNode(node, label)</i> checks if a <i>node</i> conforms
 with the shape associated with <i>label</i> in context <i>ctx</i>. 
 If it conforms, it evaluates to <i>(t,cs,rs)</i> where 
<i>t</i> is a typing, 
<i>cs</i> is a set of checked triples, 
<i>rs</i> is a set of remaining triples.

<table class="rule">
<tr>
<td rowspan="2">matchNode</td>
<td class="up">
 ctx.schema(label) = shape &nbsp;&nbsp;&nbsp; 
 ctx.graph.triplesAround(node) = ts &nbsp;&nbsp;&nbsp;
 ctx { node -> label } |- matchShape(ts, shape) = (t,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchNode(node,label) = (t,cs,rs)</td></tr>
</table>
</section>


<section id="MatchShape">
<h2>matchShape</h2>
<p>
<i>ctx |- matchShape(triples, shape)</i> checks if a set of triples <i>triples</i> conforms
 with <i>shape</i> in context <i>ctx</i>. 
 If it conforms, it evaluates to <i>(t,cs,rs)</i> where 
<i>t</i> is a typing, 
<i>cs</i> is a set of checked triples, 
<i>rs</i> is a set of remaining triples.
</p>

<p>The empty shape matches any set of triples without any constraint.</p>
<table class="rule">
<tr>
<td rowspan="2">Empty</td>
<td class="up">
 &nbsp;
</td>
</tr>
<tr><td>ctx |- matchShape(ts,Empty) = (ctx.typing,{},ts)</td></tr>
</table>

<p>We distinguish 6 cases for basic arcs depending on the cardinality. </p>

<ul>

<li>
<p>When the cardinality is {0,unbounded} 
 and there is no arc that matches it matches the set of triples without 
 consuming any triple</p>
<table class="rule">
<tr>
<td rowspan="2">BasicArc_unbounded2</td>
<td class="up">
 ctx |- noMatchAny(ts,basicArc) &nbsp;&nbsp;&nbsp;
</td>
</tr>
<tr><td>ctx |- matchShape(ts,basicArc {0,unbounded}) = (ctx.typing,{},ts)</td></tr>
</table>

<li>
<p>When the cardinality is {0,unbounded} 
 and there is some arc that matches it consumes it</p>
<table class="rule">
<tr>
<td rowspan="2">BasicArc_unbounded3</td>
<td class="up">
 remove(ts) = (t,ts') &nbsp;&nbsp;&nbsp;
 ctx |- matchBasicArc(t,basicArc) = t1 &nbsp;&nbsp;&nbsp;
 ctx |- matchBasicArc(ts',basicArc {0,unbounded}) = (t2,cs,rs) 
</td>
</tr>
<tr><td>ctx |- matchShape(ts,basicArc {0,unbounded}) = (combineTypings(t1,t2),addTriple(t,cs),rs)</td></tr>
</table>

<li>
<p>When the cardinality is <i>{m,unbounded}</i> for <i>m > 0</i> it matches if
 there is one triple that matches and if the rest of triples matches 
 with a cardinality of <i>{m - 1, unbounded}</i></p>
<p>Notice that it only matches if there is at least one triple</p>

<table class="rule">
<tr>
<td rowspan="2">BasicArc_unbounded3</td>
<td class="up">
m > 0 &nbsp;&nbsp;&nbsp;
removeTriple(ts) = (t,ts') &nbsp;&nbsp;&nbsp;
ctx |- matchArc(t,basicArc) = t1 &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts',basicArc {m - 1,unbounded}) = (t2,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, basicArc {m,unbounded}) = (combineTypings(t1,t2),addTriple(t,cs),rs)</td></tr>
</table>

<li>

<p>When the cardinality is <i>{0, n}</i> for <i>n >= 0</i> it can match if there 
is not triple that matches or if there 
is one triple that matches and the rest of triples matches with a cardinality of <i>{0, n-1}</i></p>

<table class="rule">
<tr>
<td rowspan="2">BasicArc_bounded1</td>
<td class="up">
n >= 0 &nbsp;&nbsp;&nbsp;
ctx |- noMatchAny(ts,basicArc)) 
</td>
</tr>
<tr><td>ctx |- matchShape(ts, basicArc {0, n}) = (ctx.typing,{},ts)</td></tr>
</table>

<li> 
<table class="rule">
<tr>
<td rowspan="2">BasicArc_bounded2</td>
<td class="up">
n > 0 &nbsp;&nbsp;&nbsp;
removeTriple(ts) = (t,ts') &nbsp;&nbsp;&nbsp;
matchArc(t,basicArc) = t1  &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts', basicArc {0, n - 1}) = (t2,cs,rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, basicArc {0, n}) = (combineTypings(t1,t2), addTriple(t,cs), rs)</td></tr>
</table>

<li>
<p>If the cardinality if <i>{m, n}</i> it matches if there is one triple that matches 
 and if the rest of triples match with the cardinality <i>{m - 1, n - 1}</i></p>
 
<table class="rule">
<tr>
<td rowspan="2">BasicArc_bounded3</td>
<td class="up">
m > 0, n >= m &nbsp;&nbsp;&nbsp;
removeTriple(ts) = (t,ts') &nbsp;&nbsp;&nbsp;
matchBasicArc(t, basicArc) = t1  &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts', basicArc {m-1, n-1} ) = (t2, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, basicArc {m, n}) = (combineTypings(t1,t2), addTriple(t,cs), rs)</td></tr>
</table>

</ul>

<p>If the shape is a conjunction it matches if it matches the first element and 
   then, the second with the remaining triples</p>

<table class="rule">
<tr>
<td rowspan="2">And</td>
<td class="up">
ctx |- matchShape(ts, e1) = (t1, cs1, rs1) &nbsp;&nbsp;&nbsp;
ctx |- matchShape(ts, e2) = (t2, cs2, rs2)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, And(e1, e2) = (combineTypings(t1,t2), cs1 union cs2, rs1 intersection rs2)</td></tr>
</table>

<p>If the shape is a disjunction it matches if either the first element matches or the second one does</p>

<table class="rule">
<tr>
<td rowspan="2">Or_1</td>
<td class="up">
ctx |- matchShape(ts, e1) = (t, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Or(e1,e2) = (t, cs, rs)</td></tr>
</table>

<table class="rule">
<tr>
<td rowspan="2">Or_2</td>
<td class="up">
ctx |- matchShape(ts, e2) = (t, cs, rs)
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Or(e1,e2) = (t, cs, rs)</td></tr>
</table>

</section>

<section id="MatchBasicArc">
<h2>matchBasicArc</h2>
<p>This section covers how to match a basic Arc:
<i>ctx|-matchBasicArc(triple,basicArc)</i>. 
<p> There are two cases: direct arcs match the value with the object of the triple 
  while inverse arcs match the value with the subject the triple</p>

<table class="rule">
<tr>
<td rowspan="2">ObjectArc</td>
<td class="up">
ctx |- matchValue(o,v) = t
</td>
</tr>
<tr><td>ctx |- matchBasicArc(&lt;s,p,o&gt;, Arc p v) = t</td></tr>
</table>

<table class="rule">
<tr>
<td rowspan="2">SubjectArc</td>
<td class="up">
ctx |- matchValue(s,v) = t
</td>
</tr>
<tr><td>ctx |- matchBasicArc(&lt;s,p,o&gt;, InvArc p v) = t</td></tr>
</table>

</section>

<section id="MatchValue">
<h2>matchValue</h2>

<table class="rule">
<tr>
<td rowspan="2">valueSet</td>
<td class="up">
x &in; set
</td>
</tr>
<tr><td>ctx |- matchValue(x, ValueSet(set)) = ctx.typing</td></tr>
</table>

<div class="todo">
<p><i>noValueType</i> needs more work to handle different possibilities</p>
</div>

<table class="rule">
<tr>
<td rowspan="2">valueType</td>
<td class="up">
hastype(x,t)
</td>
</tr>
<tr><td>ctx |- matchValue(x, ValueType(t)) = ctx.typing</td></tr>
</table>

<p>ValueRef handles references to shapes. There are two cases, 
  the first initial case, when the context already contains the declaration
  that <i>x</i> has shape <i>label</i> just evaluates to the current typing.</p>
  
<table class="rule">
<tr>
<td rowspan="2">valueRef_1</td>
<td class="up">
 contains(ctx.typing, x, label)
</td>
</tr>
<tr><td>ctx |- matchValue(x, ValueRef(label)) = ctx.typing</td></tr>
</table>

<p>The second case, when the context does not contain the declaration that <i>x</i> has the shape <i>label</i>
 is solved by trying to match <i>x</i> with shape <i>label</i> in the graph.</p>
 
<table class="rule">
<tr>
<td rowspan="2">valueRef_2</td>
<td class="up">
not(contains(ctx, x, label)) &nbsp; &nbsp; &nbsp;
ctx |- matchNode(x,v) = (t,_,_)
</td>
</tr>
<tr><td>ctx |- matchValue(x, ValueRef(label)) = t</td></tr>
</table>

</section>

<section id="noMatchAny">
<h2>noMatchAny</h2>
<p><i>noMatchArcAny</i> takes a set of triples and a basic arc and checks that there is no
 triple that matches the basic arc
</p>
 
<p>It has two possibilities. 

<table class="rule">
<tr>
<td rowspan="2">noMatchAny_1</td>
<td class="up">
 &nbsp; 
</td>
</tr>
<tr><td>ctx |- noMatchAny({}, basicArc)</td></tr>
</table>
 
<table class="rule">
<tr>
<td rowspan="2">noMatchAny_2</td>
<td class="up">
removeTriple(ts) = (t,ts') &nbsp;&nbsp;&nbsp;
ctx |- noMatchBasicArc(t,basicArc) &nbsp;&nbsp;&nbsp;
ctx |- noMatchAny(ts',basicArc)
</td>
</tr>
<tr><td>ctx |- noMatchAny(ts, basicArc)</td></tr>
</table>

</section> <!-- noMatchAny -->


<section id="noMatchBasicArc">
<h2>noMatchBasicArc</h2>
<p><i>noMatchBasicArc</i> 
</p>

<p>If the predicates are different, then it succeeds

<table class="rule">
<tr>
<td rowspan="2">noMatchBasicArc_1</td>
<td class="up">
p &ne; p'
</td>
</tr>
<tr><td>ctx |- noMatchBasicArc(&lt;s,p,o&gt;, Arc p' v)</td></tr>
</table>

<p>If the predicates are the same it succeeds if the value doesn't match. There are two cases 
 depending on direct/inverse arcs 
 
<table class="rule">
<tr>
<td rowspan="2">noMatchSubjectArc</td>
<td class="up">
ctx |- noMatchValue(o,v)
</td>
</tr>
<tr><td>ctx |- noMatchBasicArc(&lt;s,p,o&gt;, Arc p v)</td></tr>
</table>

<table class="rule">
<tr>
<td rowspan="2">noMatchObjectArc</td>
<td class="up">
ctx |- noMatchValue(s,v)
</td>
</tr>
<tr><td>ctx |- noMatchBasicArc(&lt;s,p,o&gt;, InvArc p v)</td></tr>
</table>
 
</section> <!-- noMatchBasicArc -->

<section id="noMatchValue">

<h2>noMatchValue</h2>
<p>It succeeds if the value doesn't match with the node.

<table class="rule">
<tr>
<td rowspan="2">noValueSet</td>
<td class="up">
x &notin; set
</td>
</tr>
<tr><td>ctx |- matchValue(x, ValueSet(set))</td></tr>
</table>

<div class="todo">
<p><i>noValueType</i> needs more work to handle different possibilities</p>
</div>
<table class="rule">
<tr>
<td rowspan="2">noValueType</td>
<td class="up">
hasNoType(x,t)
</td>
</tr>
<tr><td>ctx |- matchValue(x, ValueType(t))</td></tr>
</table>

<p><i>noValueRef</i> succeeds if the the system can not 
  determine that the node <i>x</i> has shape <i>label</i>.
  
<table class="rule">
<tr>
<td rowspan="2">noValueRef</td>
<td class="up">
 ctx |- matchValue(x, ValueRef(label)) = ctx.typing &nbsp;&nbsp;&nbsp; 
 notContains(ctx.typing, x, label)
</td>
</tr>
<tr><td>ctx |- noMatchValue(x, ValueRef(label))</td></tr>
</table>

</section> <!-- noMatchValue -->

</section> <!-- AxiomaticSemantics -->
		
<section id="Extension">
<h2>Extended features</h2>
<p>The core SHACL language can be extended with the following constructs:

<pre>
Shape ::= Not Shape                // Matches if the shape does not match
	    | Close Shape              // Matches if it matches the shape and there are no remaining triples
		| Xor Shape Shape          // Matches if either the first shape or the second match, but not both
</pre>

<p>The axiomatic definition of these constructs are:

<p>If the shape is a negation of a shape it matches if the shape does not match</p>

<table class="rule">
<tr>
<td rowspan="2">Not</td>
<td class="up">
ctx |- not(matchShape(ts,e))
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Not(e)) = (t, ts, {})</td></tr>
</table>

<p>A set of triples matches a closed shape if the set of triples matches the shape
 and there are no remaining triples</p>

<table class="rule">
<tr>
<td rowspan="2">Close</td>
<td class="up">
ctx |- matchShape(ts,e) = (t,cs,{})
</td>
</tr>
<tr><td>ctx |- matchShape(ts, Closed(e)) = (t, cs, {})</td></tr>
</table>

<p>The XOr construct is defined in terms of negation as:</p>

<pre>
Xor(e1,e2) = Or(And(e1,not(e2)),And(e2,not(e2)))
</pre>

</section>
<section class='appendix'>
<h2>Acknowledgements</h2>
<p>
We would like to acknowledge the contributions of 
 Peter F. Patel-Schneider, Eric Prud'hommeaux, Iovka Boneva 
 and the other members of the W3c Data Shapes Working group.
</p>
</section>

<section id='tof'></section>    		
</body>
</html>

