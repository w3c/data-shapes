<!DOCTYPE html>
<html>
	<head>
		<title>Shapes Constraint Language (SHACL)</title>
		<meta charset="utf-8">
		<script src="https://www.w3.org/Tools/respec/respec-w3c-common" async class="remove"></script>
		<script class="remove">
			var respecConfig = {
				edDraftURI: "http://w3c.github.io/data-shapes/shacl/",
				issueBase: "http://www.w3.org/2014/data-shapes/track/issues/",
				specStatus: "ED",
				previousPublishDate: "2016-08-14",
				previousMaturity: "WD",
				shortName:  "shacl",
				editors: [
					{
						name:       "Holger Knublauch",
						url:        "http://knublauch.com/",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/",
						w3cid:      46500
					},
					{
						name:       "Dimitris Kontokostas",
						url:        "http://Kontokostas.com",
						company:    "University of Leipzig",
						companyURL: "http://informatik.uni-leipzig.de/",
						w3cid:      58399
					}
				],
				wg:           "RDF Data Shapes Working Group",
				wgURI:        "https://www.w3.org/2014/data-shapes/",
				wgPublicList: "public-rdf-shapes",
				wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/73865/status",
				noHighlightCSS: true
			};
		</script>
		<style>

			pre {
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			td {
				vertical-align: top;
			}
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.def-sparql {
			}
			
			.def-sparql-body {
				margin-top: 0px;
				margin-bottom: 0px;
			}
			
			.def-text {
			}
			
			.def-text-body {
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.focus-node-selected {
				color: blue;
			}
			.focus-node-error {
				color: red;
			}

			.triple-can-be-skipped {
				color: grey;
			}
			.focus-node-error {
				color: red;
			}
			
			.component-class {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameter-context {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameters {
				font-weight: bold;
				font-size: 16px;
			}

			.part-header {
				font-weight: bold;
			}
		
			.term {
				font-style: italic;
			}
			
			.term-def-header {
				font-style: italic;
				font-weight: bold;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}

			.term-table td, th {
				border-width: 1px;
				border-style: solid;
				padding: 5px;
			}
		
			.todo {
				color: red;
			}

			/* example pre taken / adapted from R2RML */
			pre.example-shapes, pre.example-data, pre.example-results { margin-left: 0; padding: 0 2em; margin-top: 1.5em; padding: 1em; }
			pre.example-shapes:before, pre.example-data:before, pre.example-results:before { background: white; display: block; font-family: sans-serif; margin: -1em 0 0.4em -1em; padding: 0.2em 1em; }
			pre.example-shapes { background: #deb; }
			pre.example-shapes, pre.example-shapes:before { border: 1px solid #bbb; }
			pre.example-shapes:before { color: #888; content: "Example shapes graph"; width: 13em; }
			pre.example-data { background: #eeb; }
			pre.example-data, pre.example-data:before { border: 1px solid #cc9; }
			pre.example-data:before { color: #996; content: "Example data graph"; width: 13em; }
			.example-results { background: #edb; }
			.example-results, .example-results:before, .example-results th, .example-results td { border: 1px solid #aca; }
			pre.example-results:before { color: #797; content: "Example validation results"; width: 13em; }

			/* our syntax menu for switching */
			div.syntaxmenu {
				border: 1px dotted black;
				padding:0.5em;
				margin: 1em; 
			}

			@media print {
				div.syntaxmenu { display:none; }
			}
		</style>
	</head>
	<body>

		<section id="abstract">
			<p>
				This document defines the SHACL Shapes Constraint Language, a language for validating RDF graphs against a set of conditions.
				These conditions are provided as shapes and other constructs expressed in the form of an RDF graph.
				RDF graphs that are used in this manner are called "shapes graphs" in SHACL and
				the RDF graphs that are validated against a shapes graph are called "data graphs".
				As SHACL shape graphs are used to validate that data graphs satisfy a set of conditions
				they can also be viewed as a description of the data graphs that do satisfy these conditions.
				Such descriptions may be used for a variety of purposes beside validation, including
				user interface building, code generation and data integration.
			</p>
		</section>

		<section id="sotd">
		</section>
		<section class='introductory'>
		  <h2>Revision History</h2>
			<p>
				The detailed list of changes and their diffs can be found in the <a href="https://github.com/w3c/data-shapes/commits/gh-pages/shacl/index.html">Git repository</a>.
			</p>
			<ul>
				<li><b>2016-10-20</b>: Remove the sh:hasShape SPARQL function (<a href="http://www.w3.org/2014/data-shapes/track/issues/131">ISSUE-131</a>)</li>
				<li><b>2016-10-12</b>: Generalized sh:message so that it can also be used in constraint (instances) (<a href="http://www.w3.org/2014/data-shapes/track/issues/178">ISSUE-178</a>)</li>
				<li><b>2016-09-27</b>: Change several constraint components such as sh:minCount / sh:maxCount and ASK-based validators to operate on value node sets because property paths may return duplicates</li>
				<li><b>2016-09-27</b>: Removed shapesGraph argument from sh:hasShape</li>
				<li><b>2016-09-15</b>: Added proposed SPARQL prefix handling section (<a href="http://www.w3.org/2014/data-shapes/track/issues/105">ISSUE-105</a>)</li>
				<li><b>2016-09-15</b>: Added sh:languageIn (<a href="http://www.w3.org/2014/data-shapes/track/issues/137">ISSUE-137</a>)</li>
				<li><b>2016-08-26</b>: Remove special treatment of sh:Violation (<a href="http://www.w3.org/2014/data-shapes/track/issues/150">ISSUE-150</a>)</li>
				<li><b>2016-08-23</b>: Added Appendix enumerating the optional features of SHACL</li>
				<li><b>2016-08-05</b>: Renamed scope to target, sh:scopeProperty -> sh:scopeSubjectsOf, etc <a href="http://www.w3.org/2014/data-shapes/track/issues/175">ISSUE-175</a>)</li>
				<li><b>2016-08-01</b>: Deleted sh:classIn and sh:datatypeIn <a href="https://www.w3.org/2016/07/28-shapes-minutes.html#resolution07">resolution on ISSUE-141</a></li>
				<li><b>2016-07-28</b>: Drop sh:defaultValueType according to <a href="https://www.w3.org/2016/06/16-shapes-minutes.html#resolution03">resolution</a></li>
				<li><b>2016-07-23</b>: Change abstract and adopt <a href="https://lists.w3.org/Archives/Public/public-rdf-shapes/2016May/0008.html">Peter's proposal</a>)</li>
				<li><b>2016-07-23</b>: Changes to accommodate universal applicability <a href="http://www.w3.org/2014/data-shapes/track/issues/139">ISSUE-139</a>)</li>
				<li><b>2016-07-05</b>: Generalized inverseProperty into property paths, added generalized sh:validator <a href="http://www.w3.org/2014/data-shapes/track/issues/41">ISSUE-41</a>)</li>
				<li><b>2016-06-17</b>: Applied resolution that SHACL leaves recursion to implementations (<a href="http://www.w3.org/2014/data-shapes/track/issues/22">ISSUE-22</a>)</li>
				<li><b>2016-06-12</b>: added explanations of sh:shapesGraph for ontologies / vocabularies</li>
				<li><b>2016-06-03</b>: Removed sh:AllObjectsScope and sh:AllSubjectsScope (<a href="http://www.w3.org/2014/data-shapes/track/issues/148">ISSUE-148</a>)</li>
				<li><b>2016-05-27</b>: Renamed sh:sparql into sh:ask and sh:select. Spawned off sh:sparql from sh:constraint. sh:constraint is now for node constraints only (<a href="http://www.w3.org/2014/data-shapes/track/issues/133">ISSUE-133</a>)</li>
				<li><b>2016-05-27</b>: Changed syntax of property scopes to sh:scopeProperty and sh:scopeInverseProperty (<a href="http://www.w3.org/2014/data-shapes/track/issues/148">ISSUE-148</a>)</li>
				<li><b>2016-05-27</b>: Generalized sh:valueShape into sh:shape (<a href="http://www.w3.org/2014/data-shapes/track/issues/160">ISSUE-160</a>)</li>
				<li><b>2016-05-17</b>: New example in section 1.3</li>
				<li><b>2016-05-13</b>: terminology changes, use SHACL instance, SHACL sub/superclass and SHACL type in the spec</li>
				<li><b>2016-05-13</b>: swap sections 3 with section 4</li>
				<li><b>2016-05-12</b>: sh:and,or,not now also apply to property/inverseProperty constraints (<a href="http://www.w3.org/2014/data-shapes/track/issues/135">ISSUE-135</a>)</li>
				<li><b>2016-05-12</b>: Remove sh:abstract  (<a href="http://www.w3.org/2014/data-shapes/track/issues/78">ISSUE-78</a>)</li>
				<li><b>2016-05-09</b>: SPARQL query at sh:derivedValues must now be proper SELECT queries, to allow PREFIX declarations</li>
				<li><b>2016-05-06</b>: Deleted sh:directType (<a href="http://www.w3.org/2014/data-shapes/track/issues/123">ISSUE-123</a>)</li>
				<li><b>2016-04-22</b>: Switched from graph-based prefixes to sh:prefix (this is a proposal only!) (<a href="http://www.w3.org/2014/data-shapes/track/issues/105">ISSUE-105</a>)</li>
				<li><b>2016-04-20</b>: Significant rework of the advanced sections, based on metamodel Proposal 3 (<a href="http://www.w3.org/2014/data-shapes/track/issues/95">ISSUE-95</a>)</li>
				<li><b>2016-04-18</b>: sh:stem definition</li>
				<li><b>2016-04-18</b>: Renamed sh:sourceTemplate to sh:sourceConstraintComponent</li>
				<li><b>2016-04-18</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-04-15</b>: Allowing multi-occurrence of constraint parameters <a href="http://www.w3.org/2014/data-shapes/track/issues/133">ISSUE-133</a></li>
				<li><b>2016-04-10/16/18</b>: Updated text for <a href="http://www.w3.org/2014/data-shapes/track/issues/144">ISSUE-144</a></li>
				<li><b>2016-04-10</b>: Fixed SPARQL query of sh:minExclusive <a href="http://www.w3.org/2014/data-shapes/track/issues/145">ISSUE-145</a></li>
				<li><b>2016-04-08</b>: Updated the definition and use of sh:hasShape <a href="http://www.w3.org/2014/data-shapes/track/issues/131">ISSUE-131</a></li>
				<li><b>2016-04-08</b>: Renamed sh:notEquals to sh:disjoint <a href="http://www.w3.org/2014/data-shapes/track/issues/136">ISSUE-136</a></li>
				<li><b>2016-04-07</b>: Added section on Invalid Shapes Graphs for <a href="http://www.w3.org/2014/data-shapes/track/issues/134">ISSUE-134</a></li>
				<li><b>2016-03-25</b>: rearrange cleanup sections 2 and 4, better definition of shape validation</li>
				<li><b>2016-03-25</b>: entailment regime - fix the graph IRI issue</li>
				<li><b>2016-03-25</b>: $shapesGraph warnings</li>
				<li><b>2016-03-22</b>: Cleaned up generic mechanism to define constraint components applied to 3.1</li>
				<li><b>2016-03-21</b>: SHACL does not assume that the data graph is an RDF dataset</li>
				<li><b>2016-03-21</b>: updated some definitions for shapes, scopes and filters</li>
				<li><b>2016-03-21</b>: Re-organized the sections on the various constraint properties, introducing the term constraint component</li>
				<li><b>2016-03-21</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-03-14</b>: Added three new node kinds as resolved (<a href="http://www.w3.org/2014/data-shapes/track/issues/99">ISSUE-99</a>)</li>
				<li><b>2016-03-12</b>: Added issue warning regarding recursion</li>
				<li><b>2016-03-04</b>: Simplified the definition of sh:class (<a href="http://www.w3.org/2014/data-shapes/track/issues/99">ISSUE-99</a>)</li>
				<li><b>2016-02-24</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-02-19</b>: Clarified that support for <code>$shapesGraph</code> is optional (<a href="http://www.w3.org/2014/data-shapes/track/issues/47">ISSUE-47</a>)</li>
				<li><b>2016-02-19</b>: Clarified that the SHACL graph URI includes the # (<a href="http://www.w3.org/2014/data-shapes/track/issues/129">ISSUE-129</a>)</li>
				<li><b>2016-02-18</b>: Removed reference to the proposed class <code>sh:QCC</code>(<a href="http://www.w3.org/2014/data-shapes/track/issues/92">ISSUE-92</a>)</li>
				<li><b>2016-02-12</b>: Added a paragraph on the limits of the core vocabulary, highlighting how rdf:Lists can be handled by the extension mechanism (<a href="http://www.w3.org/2014/data-shapes/track/issues/119">ISSUE-119</a>)</li>
				<li><b>2016-02-10</b>: Added <code>sh:partition</code>. (<a href="http://www.w3.org/2014/data-shapes/track/issues/92">ISSUE-92</a>)</li>
				<li><b>2016-02-05</b>: Removed value type constraints on various constraint properties such as sh:class (<a href="http://www.w3.org/2014/data-shapes/track/issues/117">ISSUE-117</a>)</li>
				<li><b>2016-01-29</b>: Clarified that validation results must be based on the data graph only. (<a href="http://www.w3.org/2014/data-shapes/track/issues/118">ISSUE-118</a>)</li>
				<li><b>2016-01-25</b>: Clarified direction of property path. Remove comment about consistency. (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-22</b>: Switched closed shapes syntax to sh:closed (<a href="http://www.w3.org/2014/data-shapes/track/issues/115">ISSUE-115</a>)</li>
				<li><b>2016-01-21</b>: Limit definition of shapes that are also classes to the shapes graph (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-19</b>: Describe scoping of shapes that are also classes (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-18</b>: Stated starting point for recursion (<a href="http://www.w3.org/2014/data-shapes/track/issues/22">ISSUE-22</a>)</li>
				<li><b>2016-01-18</b>: Clarified the meaning of filter shapes (<a href="http://www.w3.org/2014/data-shapes/track/issues/49">ISSUE-49</a>)</li>
				<li><b>2016-01-11</b>: Deleted operations section (<a href="http://www.w3.org/2014/data-shapes/track/issues/108">ISSUE-108</a>)</li>
				<li><b>2016-01-11</b>: Added derived properties (<a href="http://www.w3.org/2014/data-shapes/track/issues/97">ISSUE-97</a>)</li>
				<li><b>2016-01-11</b>: Dropped sh:ShapeClass (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>), elaborated on possible sh:scopeClass rule</li>
				<li><b>2016-01-10</b>: Added sh:order (<a href="http://www.w3.org/2014/data-shapes/track/issues/100">ISSUE-100</a>) and sh:group (<a href="http://www.w3.org/2014/data-shapes/track/issues/114">ISSUE-114</a>)</li>
				<li><b>2016-01-10</b>: Introduced sh:datatypeIn and sh:classIn, deleted sh:text (<a href="http://www.w3.org/2014/data-shapes/track/issues/104">ISSUE-104</a>)</li>
				<li><b>2016-01-09</b>: Syntax simplifications: Switched to sh:not, sh:and, sh:or, sh:equals, sh:notEquals, sh:lessThan, sh:lessThanOrEquals (<a href="http://www.w3.org/2014/data-shapes/track/issues/103">ISSUE-103</a>)</li>
				<li><b>2015-12-02</b>: Fixed <a href="https://github.com/w3c/data-shapes/issues/9">minor mistake in spec - ex:unsinged</a>.</li>
				<li><b>2015-11-20</b>: Switched from rdfs:label/rdfs:comment at property constraints to sh:name/sh:description (ISSUE-112)</li>
				<li><b>2015-11-06</b>: Renamed sh:nodeShape to sh:scopeNode, clarified that its triples are expected in shapes graph (ISSUE-61)</li>
				<li><b>2015-10-30</b>: Deleted sh:cachable, removed the option for sh:sparql to be a query fragment in sh:scope</li>
				<li><b>2015-10-29</b>: Improved wording in the definition of sh:in.</li>
				<li><b>2015-10-28</b>: Separated definitions of sh:qualifiedMinCount and sh:qualifiedMaxCount</li>
				<li><b>2015-10-22</b>: Define sh:minLength, sh:maxLength, sh:qualifiedMinCount, and sh:qualifiedMaxCount without reference to default values</li>
				<li><b>2015-10-22</b>: Replaced ex:bornIn with ex:residentIn in Section 2.2</li>
				<li><b>2015-10-16</b>: Added sh:SPARQLConstraint and sh:SPARQLScope (part of ISSUE-98)</li>
				<li><b>2015-10-16</b>: Renamed sh:valueClass to sh:class, sh:allowedValues to sh:in, sh:directValueType to sh:directType (part of ISSUE-98)</li>
				<li><b>2015-10-15</b>: Define sh:minCount and sh:maxCount without reference to default values</li>
				<li><b>2015-10-15</b>: Use real-world names in examples 3, 4 and 5</li>
				<li><b>2015-10-15</b>: Changed SPARQL definition of sh:AllObjects, implementing resolution to ISSUE-90</li>
				<li><b>2015-10-09</b>: Added sh:flags and sh:uniqueLang</li>
				<li><b>2015-09-23</b>: Multiple minor stylistic edits and corrections</li>
				<li><b>2015-09-21</b>: Added button to show or hide SPARQL definitions (thanks to Simon)</li>
				<li><b>2015-09-18</b>: Deleted <code>sh:XorConstraint</code> as resolved, renamed <code>sh:Error</code> to <code>sh:Violation</code></li>
				<li><b>2015-09-17</b>: Added missing definition of <code>sh:class</code>, editorial changes, renamed sh:ClosedShape to sh:Closed, added sh:sourceTemplate</li>
				<li><b>2015-09-15</b>: Restructured Part 2, with new examples, integrated SPARQL binding and rewritten Operations section</li>
				<li><b>2015-09-14</b>: Added SPARQL definitions for each constraint type, added description of sh:hasShape function</li>
				<li><b>2015-09-11</b>: Restructured constraint section, cleaned up results vocabulary</li>
				<li><b>2015-09-10</b>: Added sh:shapesGraph property (<a href="http://www.w3.org/2014/data-shapes/track/issues/44">ISSUE-44</a>)</li>
				<li><b>2015-09-09</b>: Rewritten introduction, dropped Profile section, word-smithing on sh:class</li>
				<li><b>2015-09-04</b>: Applied resolution to <a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a></li>
				<li><b>2015-09-03</b>: Many editorial changes, restructured section 5 (scopes and filters) into section 2 (Shapes)</li>
				<li><b>2015-09-01</b>: Minor changes and clarifications</li>
				<li><b>2015-08-24</b>: Added section on sh:defaultValueType (<a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a>)</li>
				<li><b>2015-08-21</b>: Added support for validation functions (<a href="http://www.w3.org/2014/data-shapes/track/issues/79">ISSUE-79</a>)</li>
				<li><b>2015-08-14</b>:
					Added qualified cardinality restrictions (<a href="http://www.w3.org/2014/data-shapes/track/issues/72">ISSUE-72</a>),
					added sh:ignoredProperties to sh:ClosedShape (<a href="http://www.w3.org/2014/data-shapes/track/issues/58">ISSUE-58</a>),
					editorial improvements to terminology, added Glossary to appendix
				</li>
				<li><b>2015-08-07</b>: Extended the use of sh:severity to template constraints, split sh:source into sh:sourceConstraint and sh:sourceShape, renamed sh:root to sh:focusNode</li>
				<li><b>2015-07-31</b>: Added sh:text as the union of xsd:string and rdf:langString</li>
				<li><b>2015-07-30</b>: Integrated sh:InversePropertyScope and sh:AllObjects</li>
				<li><b>2015-07-24</b>: Added details of XSD-like facets (<a href="http://www.w3.org/2014/data-shapes/track/issues/64">ISSUE-64</a>)</li>
				<li>
					<b>2015-07-17</b>: Rewritten scope and filter mechanism (<a href="http://www.w3.org/2014/data-shapes/track/issues/62">ISSUE-62</a>),
					suggestion for generalized execution language interface (<a href="http://www.w3.org/2014/data-shapes/track/issues/60">ISSUE-60</a>)
				</li>
				<li><b>2015-07-13</b>: Replaced Appendix with references to SHACL-REF document</li>
				<li><b>2015-07-03</b>: Editorial fixes, started revision history</li>
			</ul>
		</section>
		<section class="introductory">
			<h2>Document Outline</h2>
			<p>
				The introduction includes a <a href="#terminology">Terminology</a> section.
			</p>
			<p>
				The sections 2 - 4 cover the <a>SHACL Core</a> language and may be read independently from the later sections.
			</p>
			<p>
				The sections 5 onwards are about the additional features that <a>SHACL Full</a> has in addition to the Core language.
				These advanced features include SPARQL-based constraints, constraint components, targets and functions.
			</p>
			<p>
				The examples in this document use Turtle [[!turtle]].
				The reader should be familiar with basic RDF concepts [[!rdf11-concepts]] such as triples and, for the advanced concepts of SHACL, with SPARQL [[!sparql11-overview]].			<p>
			</p>
		</section>


	
		<section id="introduction">
			<h2>Introduction</h2>
			<p>
				This document specifies SHACL (Shapes Constraint Language), a language for describing and validating RDF graphs.
				This section introduces SHACL with an overview of the key terminology and an example to illustrate basic concepts.
			</p>
			<section id="terminology">
				<h3>Terminology</h3>
				<p>
					Throughout this document, the following terminology is used.
				</p>
				<div class="def" id="rdf-terminology">
					<div class="term-def-header">Basic RDF Terminology</div>
					<div>
						This document uses the terms 
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph"><dfn data-lt="graph|graphs|RDF graphs">RDF graph</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple"><dfn data-lt="triple|triples">RDF triple</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri"><dfn data-lt="IRI|IRIs">IRI</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal"><dfn data-lt="literal|literals">literal</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node"><dfn data-lt="blank node|blank nodes">blank node</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-node"><dfn data-lt="node|nodes">node</dfn></a> of an RDF graph,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term"><dfn>RDF term</dfn></a>, and
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-subject"><dfn data-lt="subject|subjects">subject</dfn></a>,
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-predicate"><dfn data-lt="predicate|predicates">predicate</dfn></a>, and
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-object"><dfn data-lt="object|objects">object</dfn></a> of RDF triples, and
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-datatype"><dfn data-lt="datatypes">datatype</dfn></a>
						as defined in RDF 1.1 Concepts and Abstract Syntax [[!rdf11-concepts]].
						</div>
				</div>
				<div class="def">
					<div class="term-def-header">Property Value and Path</div>
					<div>
						The <dfn data-lt="value|property value|property values">values</dfn> of a property <code>p</code> for a <a>node</a> <code>n</code> in an <a>RDF graph</a> are the
						<a>objects</a> of the <a>triples</a> in the <a>graph</a> that have <code>n</code> as <a>subject</a> and <code>p</code> as <a>predicate</a>.
						A <dfn data-lt="path|property paths">property path</dfn> is a possible route in a <a>graph</a> between two graph <a>nodes</a>.
						SHACL supports a subset of the property path syntax from <a href="https://www.w3.org/TR/sparql11-query/#pp-language">SPARQL 1.1</a>,
						including inverse paths and sequences.
						The values of a property path <code>path</code> for a given node <code>s</code> are the distinct bindings produced by a SPARQL processor for the variable <code>o</code> from a
						<a href="https://www.w3.org/TR/sparql11-query/#rTriplesBlock"><code>TriplesBlock</code></a> of the form <code>s path ?o</code>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">RDF Lists</div>
					<div>
						In this document, an <dfn data-lt="RDF lists">RDF list</dfn> is an <a>IRI</a> or <a>blank node</a>
						that is either <code>rdf:nil</code>, or has exactly one <a>value</a> for the property <code>rdf:first</code>
						and exactly one <a>value</a> for the property <code>rdf:rest</code> that is also an RDF list.
						<code>rdf:nil</code> cannot have any value for either <code>rdf:first</code> or <code>rdf:rest</code>.
						The <a>values</a> of the <a>path</a> <code>rdf:rest*/rdf:first</code> starting from a given list node
						are called the <dfn data-lt="member">members</dfn> of the list.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Binding, Solution</div>
					<div>
						In this document, a <dfn data-lt="bindings">binding</dfn> is a pair (<a href="https://www.w3.org/TR/sparql11-query/#defn_QueryVariable">variable</a>, <a>RDF term</a>), consistent with the term's use in <a href="https://www.w3.org/TR/sparql11-query/">SPARQL</a>.
					    A <dfn data-lt="solutions">solution</dfn> is a set of bindings, one row in the body of the result table of a SPARQL query.
					    Variables are not required to be bound in a solution.
					    The results table is a <a href="https://www.w3.org/TR/sparql11-query/#defn_sparqlSolutionSequence">SolutionSequence</a>, a list of solutions, possibly unordered.
					</div>
				</div>
				<div class="def">
				<div class="term-def-header">SHACL Subclass, SHACL superclass</div>
					<div>
						A <a>node</a> <code>Sub</code> in an <a>RDF graph</a> is a <dfn data-lt="subclasses|subclass|SHACL subclasses">SHACL subclass</dfn> of another <a>node</a> <code>Super</code>
						in the <a>graph</a> if there is a sequence of <a>triples</a> in the <a>graph</a> each with predicate <code>rdfs:subClassOf</code> such that the <a>subject</a> of the first <a>triple</a> is <code>Sub</code>,
						the <a>object</a> of the last triple is <code>Super</code>, and the <a>object</a> of each <a>triple</a> except the last is the <a>subject</a> of the next.
						If <code>Sub</code> is a <a>SHACL subclass</a> of <code>Super</code> in an <a>RDF graph</a> then <code>Super</code>
						is a <dfn data-lt="superclass|superclasses|SHACL superclasses|">SHACL superclass</dfn> of <code>Sub</code> in the <a>graph</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Type</div>
					<div>
						The <dfn data-lt="type|types|SHACL type">SHACL types</dfn> of a <a>node</a> in an <a>RDF graph</a> are its <a>values</a> for <code>rdf:type</code> in the
						<a>graph</a> as well as the <a>SHACL superclasses</a> of these <a>values</a> in the <a>graph</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Class</div>
					<div>
						<a>Nodes</a> in an <a>RDF graph</a> that are subclasses, superclasses, or types of <a>nodes</a> in the <a>graph</a> are often referred to as <dfn data-lt="class|classes|SHACL classes">SHACL class</dfn>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Class Instance</div>
					<div>
						A <a>node</a> in an <a>RDF graph</a> is a <dfn data-lt="SHACL instance|SHACL instances">SHACL instance</dfn> of a <a>SHACL class</a> in the <a>graph</a>
						if one of its <a>SHACL types</a> is the <a>class</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Expected Type</div>
					<div>
						In a <a>shapes graph</a>, the non-lieral <a>values</a> of a property or a property path can have an <dfn>expected type</dfn>.
						These nodes are treated as <a href="https://www.w3.org/TR/rdf-schema/#ch_classes">RDFS instances</a> of specific classes, even when these nodes are not <a>SHACL instances</a> of these classes.
						For example, the objects of triples with <code>sh:shape</code> as predicate have <code>sh:Shape</code> as expected type and
						there does not need to be a triple with the object node as the subject, <code>rdf:type</code> as predicate and <code>sh:Shape</code> as object in the shapes graph.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Constraint</div>
					<div>
						A <dfn data-lt="constraint|constraints">constraint</dfn> is a <a>node</a> in the <a>shapes graph</a> that determines how to validate
						<a>focus nodes</a> based on the <a>values</a> of properties and other characteristics of the <a>node</a>.
						Constraints can, for example, require that a focus node be an IRI or that a focus node has a particular value for a property and also a minimum number of values for the property.
						Constraints that are about a particular property or <a>path</a> and its <a>values</a> for the focus node are called <dfn data-lt="property constraint">property constraints</dfn>.
						Constraints that are about the <a>focus node</a> itself are called <dfn>focus node constraints</dfn>.
						Constraints can also have <dfn data-lt="non-validating property">non-validating properties</dfn> (such as names and default values) that do not lead to <a>validation results</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Constraint Component, Parameter</div>
					<div>
						A <dfn data-lt="constraint component|constraint components|components|component">constraint component</dfn> is an <a>IRI</a> in the <a>shapes graph</a>.
						Constraint components define one or more properties, called <dfn data-lt="parameter">parameters</dfn>, and define so-called <dfn data-lt="validator">validators</dfn>,
						which provide instructions (for example expressed via SPARQL queries) on how the parameters are used to validate data.
						For example, <code>sh:minCount</code> is a parameter for the component <code>sh:MinCountConstraintComponent</code> that represents the restriction
						that the <a>focus node</a> has at least a minimum number of <a>values</a> for a	particular property.
						Validating a <a>node</a> against a <a>constraint</a> involves validating the node against each of the <a>components</a> for which the constraint has parameter values for.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Core and SHACL Full</div>
					<div>
						The SHACL specification is divided into SHACL Core and SHACL Full.
						<dfn>SHACL Core</dfn> consists of frequently needed features for the representation of shapes, constraints and targets.
						All SHACL implementations must at least cover the Core.
						<dfn>SHACL Full</dfn> consists of all features of SHACL Core plus a collection of advanced features
						including SPARQL-based constraints, extension mechanisms to define new constraint components and target types,
						user-defined functions and derived properties.
					</div>
				</div>

			</section>

			<section id="conventions">
				<h3>Document Conventions</h3>
				<p>
					Within this document, the following namespace prefix bindings are used:
				</p>
				<table class="term-table">
					<tr>
						<th>Prefix</th>
						<th>Namespace</th>
					</tr>
					<tr>
						<td><code>rdf:</code></td>
						<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
					</tr>
					<tr>
						<td><code>rdfs:</code></td>
						<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
					</tr>
					<tr>
						<td><code>sh:</code></td>
						<td><code>http://www.w3.org/ns/shacl#</code></td>
					</tr>
					<tr>
						<td><code>xsd:</code></td>
						<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
					</tr>
					<tr>
						<td><code>ex:</code></td>
						<td><code>http://example.com/ns#</code></td>
					</tr>
				</table>
				<p>
					Note that the URI of the graph defining the SHACL vocabulary itself is equivalent to
					the namespace above, i.e. it includes the <code>#</code>.
					References to the SHACL vocabulary, e.g. via <code>owl:imports</code> SHOULD include the <code>#</code>. 
				</p>
				<p>
					Throughout the document, color-coded boxes containing RDF graphs in Turtle will appear.
					These fragments of Turtle documents use the prefix bindings given above.
				</p>
				<pre class="example-shapes">
# This box represents an input shapes graph

# Triples that can be omitted are marked as grey e.g.
<span class="triple-can-be-skipped">&lt;s&gt; &lt;p&gt; &lt;o&gt; .</span></pre>

				<pre class="example-data">
# This box represents an input data graph.
# When highlighting is used in the examples:

# Elements highlighted in blue are <a>focus nodes</a>
<span class="focus-node-selected">ex:Bob</span> a ex:Person .

# Elements highlighted in red are focus nodes that fail <a href="#validation">validation</a>
<span class="focus-node-error">ex:Alice</span> a ex:Person .</pre>

				<pre class="example-results">
# This box represents an output results graph</pre>

				<p>
					SHACL Definitions appear in blue boxes:
				</p>
				<div class="def def-sparql">
					<div class="def-header">SPARQL or TEXTUAL DEFINITIONS</div>
<pre class="def-sparql-body">
# This box contains SPARQL or textual definitions. </pre>
				</div>

			</section>

			<section id="conformance">
				<p>
					<span class="todo">TODO: needs more work.</span>
				</p>
				<p>
					This specification describes conformance criteria for:
				</p>
				<ul>
					<li><strong>SHACL Core</strong> language, also referred to as just <strong>SHACL</strong>, as described in Part A of this document</li>
					<li><strong>SHACL Full</strong> language that extends SHACL Core with constructs described in Part B of this document</li>
					<li>SHACL Shapes Graphs, as defined in <a href="#shapes-graph">section 3</a></li>
					<li>Validation of a data graph against a shapes graph, as defined in <a href="#validation">section 3</a></li>
					<li>Validation of an RDF node from a data graph against a shape from the shapes graph, as defined in <a href="#validation">section 3</a></li>
					<li><strong>SHACL Core processors</strong> as processors that support validation with the SHACL Core Language</li>
					<li><strong>SHACL Full processors</strong> as processors that support validation with the SHACL Full Language</li>
				</ul>

				<p>
					<span class="todo">TODO: link to test cases.</span>
				</p>
			</section>

			<section>
				<h3>SHACL Example</h3>
				<p>
					The following example <a>data graph</a> contains nine total <a>nodes</a>, out of which three <a>nodes</a> are <a>SHACL instances</a> of the <a>class</a> <code>ex:Person</code>.
				</p>
				<pre class="example-data">
ex:Alice
	a ex:Person ;
	ex:child ex:Calvin ;
	ex:ssn "987-65-432A" .
  
ex:Bob
	a ex:Person ;
	ex:child ex:Calvin ;
	ex:ssn "123-45-6789" ;
	ex:ssn "124-35-6789" .
  
ex:Calvin
	a ex:Person ;
	ex:school ex:TrinityAnglicanSchool .</pre>
				<p>
					SHACL can be used to define the following example <a>constraints</a>:
				<p>
				<ul>
					<li>
						A <a>SHACL instance</a> of <code>ex:Person</code> may have at most one <a>value</a> for the property <code>ex:ssn</code>,
						and this <a>value</a> must be a <a>literal</a> with the datatype <code>xsd:string</code> that matches
						a specified regular expression.
					</li>
					<li>
						A <a>SHACL instance</a> of <code>ex:Person</code> may have unlimited <a>values</a> for the property <code>ex:child</code>,
						and these <a>values</a> must be <a>IRIs</a> and they must be <a>SHACL instances</a> of <code>ex:Person</code>.
					</li>
					<li>
						A person's parents are represented using the property <code>ex:child</code> in the inverse direction.
						A <a>SHACL instance</a> of <code>ex:Person</code> may have at most 2 parents, i.e. may be the <a>object</a> of at most two <a>triples</a>
						where the <a>predicate</a> is <code>ex:child</code>.
					</li>
					<li>
						A <a>SHACL instance</a> of <code>ex:Person</code> may not have <a>values</a> for any other property apart from
						<code>ex:ssn</code>, <code>ex:child</code> and <code>rdf:type</code>.
					</li>
				</ul>
				<p>
					The <a>constraints</a> above can be represented using the following <a>shapes graph</a>:
				</p>
				<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:targetClass ex:Person ;    # Applies to all persons
	sh:property [
		sh:predicate ex:ssn ;     # Validates the values of the ex:ssn property
		sh:maxCount 1 ;
		sh:datatype xsd:string ;
		sh:pattern "^\\d{3}-\\d{2}-\\d{4}$" ;
	] ;
	sh:property [
		sh:predicate ex:child ;
		sh:class ex:Person ;
		sh:nodeKind sh:IRI ;
	] ;
	sh:property [
		rdfs:comment "A person's parents are represented via ex:child used in the inverse direction." ;
		sh:path [ sh:inversePath ex:child ] ;
		sh:name "parent" ;
		sh:maxCount 2 ;
	] ;
	sh:closed true ;
	sh:ignoredProperties ( rdf:type ) .</pre>
				<p>
					We can use the shape definition above to illustrate some of the key terminology used by SHACL.
					The <a>focus nodes</a> for the <a>shape</a> <code>ex:PersonShape</code> are all <a>SHACL instances</a> of the <a>class</a> <code>ex:Person</code>.
					These <a>focus nodes</a> are the <a>targets</a> of the <a>shape</a> and are defined using the property <code>sh:targetClass</code>.
					The <a>shape</a> defines three <a>property constraints</a> with the property <code>sh:property</code>,
					one of which uses a <a>path</a> expression.
					The <a>shape</a> defines a further constraint on the <a>focus nodes</a> using the <a>parameters</a> <code>sh:closed</code> and <code>sh:ignoredProperties</code>.
				</p>
				<p>
					Some of the <a>property constraints</a> specify parameters from multiple <a>constraint components</a> in order to
					restrict multiple aspects of the <a>property values</a>.
					For example, in the <a>property constraint</a> for <code>ex:ssn</code>, parameters from three <a>constraint components</a> are used.
					The <a>parameters</a> of these <a>constraint components</a> are <code>sh:datatype</code>, <code>sh:pattern</code> and <code>sh:maxCount</code>.
					For each <a>focus node</a> the <a>property values</a> of <code>ex:ssn</code> will be validated against all three components.
					The constraint on the inverse property values of <code>sh:child</code> uses only one <a>constraint component</a> identified by the <code>sh:maxCount</code> <a>parameter</a>.
					Note that this <a>constraint</a> uses the <a>non-validating property</a> <code>sh:name</code>
					to suggest a human-readable name for the property when used in the inverse direction.
				</p>
				<p>
					SHACL <a>validation</a> based on the provided <a>data graph</a> and <a>shapes graph</a> would produce the following <a>validation results</a>.
					See the section <a href="#validation-report">Validation Report</a> for details on the format.
				</p>
				<pre class="example-results">
[	a sh:ValidationResult ;
	sh:sourceConstraintComponent sh:RegexConstraintComponent ;
	sh:sourceShape ex:PersonShape ;
	sh:focusNode ex:Alice ;
	sh:path ex:ssn ;
	sh:value "987-65-432A" ;
	sh:severity sh:Violation ;
] .
[	a sh:ValidationResult ;
	sh:sourceConstraintComponent sh:MaxCountConstraintComponent ;
	sh:sourceShape ex:PersonShape ;
	sh:focusNode ex:Bob ;
	sh:path ex:ssn ;
	sh:severity sh:Violation ;
] .
[	a sh:ValidationResult ;
	sh:sourceConstraintComponent sh:ClosedConstraintComponent ;
	sh:sourceShape ex:PersonShape ;
	sh:focusNode ex:Calvin ;
	sh:path ex:school ;
	sh:value ex:TrinityAnglicanSchool ;
	sh:severity sh:Violation ;
] .</pre>
				<p>
					The first <a>validation result</a> is produced because <code>ex:Alice</code> has a <a>value</a> for <code>ex:ssn</code>
					that does not match the regular expression specified by the property <code>sh:regex</code>.
					The second <a>validation result</a> is produced because <code>ex:Bob</code> has more than the permitted number of <a>values</a>
					for the property <code>ex:ssn</code> as specified by the <code>sh:maxCount</code> of 1.
					The third <a>validation result</a> is produced because the <a>shape</a> <code>ex:PersonShape</code> has the	the property <code>sh:closed</code> set to <code>true</code>
					but <code>ex:Calvin</code> uses the property <code>ex:school</code> which is neither one of the predicates from any of the 
					<a>property constraints</a> of the shape, nor one of the properties listed using <code>sh:ignoredProperties</code>.
				</p>
			</section>
			
			<section id="shacl-rdfs">
				<h3>Relationship between SHACL and RDFS inferencing</h3>

				<!--p>
					SHACL uses RDF and RDFS vocabulary (in particular <code>rdf:type</code>, <code>rdfs:Class</code>, <code>rdfs:subClassOf</code>, <code>rdf:Property</code>, <code>rdf:List</code>,
					<code>rdf:langLiteral</code>, and <code>rdfs:Resource</code>) and concepts (notably classes, instances, and subclasses).
					However, SHACL does not always use this vocabulary or these concepts in exactly the way that they are formally defined in RDF and RDFS [[!rdf11-mt]].				
				</p>
				<p>
					When determining subclass and instance relationships SHACL only uses the transitive closure of <code>rdfs:subClassOf</code>,
					without requiring in particular the RDF axioms, the RDFS meaning of <code>rdfs:Resource</code>, the reflexivity of <code>rdfs:subClassOf</code>,
					the effect of subproperties of <code>rdfs:subClassOf</code>, and the effects of <code>rdfs:domain</code> and <code>rdfs:range</code>.
				</p>
				<p>
					Note that <code>rdfs:subClassOf</code> transitivity is only used when SHACL explicitly determines type and subclass relationships in the shapes graph and the data.
					Elsewhere, only triples that are explicitly present in the shapes graph or the data are considered.
					For example, SHACL property constraints on <code>rdf:type</code> and <code>rdfs:subClassOf</code> only utilize triples that are explicitly in the data.
					Similarly, subproperties of <code>rdfs:label</code> and <code>rdfs:commment</code> and subclasses of <code>rdf:List</code> are not recognized in the shapes graph.
				</p>
				<p>
					These design decisions mean that SHACL processors do not have to natively support full RDFS inferencing. -->
				<p>
					SHACL uses the RDF and RDFS vocabularies, but full RDFS inferencing is not required.
					However, SHACL processors MUST identify <a>SHACL instances</a> of a class both in the <a>data graph</a> and the <a>shapes graph</a> without modifying either graph during the <a href="#validation">validation process</a>.
					Furthermore, SHACL processors may operate on RDF graphs that include entailments - either pre-computed before being submitted to a SHACL processor or performed on the fly as part of SHACL processing.
					To support processing of entailments, SHACL includes the property <a href="#entailment"><code>sh:entailment</code></a> to indicate what inferencing is required by a given <a>shapes graph</a>.
					SHACL implementations may, but are not required to, support entailment regimes.
				</p>
			</section>
			
			<section id="shacl-sparql">
				<h3>Relationship between SHACL and SPARQL</h3>
				<p>
					This specification uses parts of SPARQL 1.1 in the normative definition of the semantics of the SHACL Core <a>constraints</a> and <a>targets</a>.
					However, SPARQL is not required for the implementation of the SHACL Core language.
				</p>
				<p>
					SPARQL variables using the <code>$</code> marker represent external <a>bindings</a> that must be <a>pre-bound</a> or, in the case of <code>$PATH</code>, substituted in the SPARQL query before execution.
				</p>
				<p>
					In some places, the specification assumes that the provided SPARQL engines are preserving the identity of <a>blank nodes</a>,
					so that repeated invocations of queries consistently identify and communicate the same <a>blank nodes</a>.
				</p>
				<p>
					The definition of some <a>constraints</a> requires or is simplified through access to the <a>shapes graph</a> during query execution.
					SHACL Full processors MAY <a>pre-bind</a> the variable <code>shapesGraph</code> to provide access to the <a>shapes graph</a>.
					Access to the <a>shapes graph</a> is not a requirement for supporting the SHACL Core language.
					The variable <code>shapesGraph</code> can also be used in <a href="#sparql-constraints">SPARQL-based constraints</a> and <a href="#constraint-components">SPARQL-based constraint components</a>.
					However, such <a>constraints</a> may not be interoperable across different SHACL Full processors or not applicable to remote RDF datasets.
				</p>
				<p>
					SHACL additionally introduces mechanisms to define <a>constraints</a>, <a>targets</a>, <a href="#derivedValues">derived values</a> and new functions in SPARQL.
					Implementations that cover only the SHACL Core features are not required to implement these mechanisms.
				</p>
				<div class="syntaxmenu">
					<p>The button below can be used to show or hide the SPARQL definitions.</p>
					<form>
						<p>
							<input id="hide-sparql" onclick="$('.def-sparql').css('display', 'none'); $('#hide-sparql').css('display', 'none'); $('#show-sparql').css('display', '');" type="button" value="Hide SPARQL Definitions" />
							<input id="show-sparql" onclick="$('.def-sparql').css('display', '');     $('#show-sparql').css('display', 'none'); $('#hide-sparql').css('display', '');" style="display:none" type="button" value="Show SPARQL Definitions" />
						</p>
					</form>
				</div>
			</section>
			
		</section>
		
		<div style="padding-top: 30px"> <!-- ALH: really??? -->
			<h1 id="part1" style="font-size: 160%; font-weight: bold">Part 1: SHACL Core</h1>
		</div>

		<section id="shapes">
			<h2>Shapes and Constraints</h2>
			<p>
				A <dfn data-lt="shape|shapes">shape</dfn> can be a <a>node</a> in a <a>shapes graph</a> that is
				a <a>SHACL instance</a> of <code>sh:Shape</code>;
				or it can be a node that the <a>expected type</a> of the node is <code>sh:Shape</code>.
			</p>
			<p>
				A shape provides a set of zero or more <a>targets</a>, <a>filters</a>, <a>constraints</a> and <a>parameters</a> of <a>constraint components</a>
				that specify how a set of nodes from the <a>data graph</a> are validated against the shape.
				Shapes can also provide <a href="#nonValidation">non-validating information</a>, such as labels and comments.
			</p>

			<section id="focusNodes">
				<h3>Focus Nodes</h3>
				<p>
					A <a>node</a> in the <a>data graph</a> that is <a>validated</a> against a <a>shape</a> is called a <dfn data-lt="focus node|focus nodes">focus node</dfn>.
				</p>
				<p>
					The set of <a>focus nodes</a> for a <a>shape</a> may be identified as follows:
				</p>
				<ul>
			    	<li>specified in a <a>shape</a> using <a>targets</a> and <a>filters</a>,</li>
					<li>specified in any <a>constraint</a> that references a <a>shape</a>
						in parameters of <a href="#constraints-shape">shape-based constraint components</a> (i.e. <code>sh:shape</code>) or
						<a href="#constraints-shape">logical constraint components</a> (i.e. <code>sh:or</code>),</li>
					<li>specified as input to the SHACL processor for validating specific nodes from the <a>data graph</a> against the shape</li>
				</ul>
			</section>

			<section id="targets">
				<h3>Targets</h3>

				<p>
					A <dfn data-lt="target|targets">target</dfn> provides one way to specify potential <a>focus nodes</a> for a <a>shape</a>.

				</p>

				<p>
					SHACL Core includes four kinds of targets:
					<a href="#targetNode">node targets</a>,
					<a href="#targetClass">class-based targets</a>,
					<a href="#targetSubjectsOf">subjects-of targets</a>, and
					<a href="#targetObjectsOf">objects-of targets</a>.

					The SHACL Full language additionally defines an advanced <a href="#sparql-targets">general target mechanism based on SPARQL</a>.
				</p>
				<p>
					Not all target nodes become focus nodes.
					When a shape includes <a>filters</a>, filters can remove nodes specified by targets.
				</p>

				<p>
					When multiple <a>targets</a> are provided in a <a>shape</a>, the target of a shape is the union of all nodes produced by these individual targets.
					Nodes specified by targets are not required to exist in the <a>data graph</a>.
				</p>
				<p>
					Targets MUST be ignored when a shape is processed as a value of parameters of
					<a href="#constraints-shape">shape-based constraint components</a> (i.e. <code>sh:shape</code>),
					<a href="#constraints-shape">logical constraint components</a> (i.e. <code>sh:or</code>), or
					<a href="#filterShape">filter shapes</a> (<code>sh:filterShape</code>).
				</p>
				
				<section id="targetNode">
					<h4>Node targets (sh:targetNode)</h4>
					<p>
						A <dfn>node target</dfn> is defined with the <code>sh:targetNode</code> predicate.
						Each <a>value</a> of <code>sh:targetNode</code> can be an <a>IRI</a> or a <a>literal</a>.
						Each value of a node target defines a node to validate in the data graph.
					</p>

					<p>
						With the example data below, only <code>ex:Alice</code> is the target of the provided shape:
					</p>
					<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:targetNode ex:Alice .</pre>

					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
ex:Bob a ex:Person .</pre>

					<p class="def-sparql">
						The following SPARQL query specifies the semantics of node targets.
						The variable <code>targetNode</code> is assumed to be <a href="#pre-binding">pre-bound</a> to the given value of <code>sh:targetNode</code>.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this    <span class="triple-can-be-skipped"># ?this is the focus node</span>
WHERE {
	BIND ($targetNode AS ?this)    <span class="triple-can-be-skipped"># $targetnote is <a href="#pre-binding">pre-bound</a> to ex:Alice</span>
}</pre>
					</div>
				</section>
				
				<section id="targetClass">
					<h4>Class-based Targets (sh:targetClass)</h4>
					<p>
						A <dfn>class target</dfn> is defined with the <code>sh:targetClass</code> predicate.
						Each value of <code>sh:targetClass</code> must be an <a>IRI</a>.
						For every value <code>c</code> of a class target, all <a>SHACL instances</a> of <code>c</code> in the data graph are validated
						against the <a>subject</a> of the <code>sh:targetClass</code> triple.
					</p>

					<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:targetClass ex:Person .</pre>

					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
<span class="focus-node-selected">ex:Bob</span> a ex:Person .
ex:NewYork a ex:Place .</pre>
					<p>
						In this example, only <code>ex:Alice</code> and <code>ex:Bob</code> are focus nodes.
						Note that, according to the <a>SHACL instance</a> definition, all the <code>rdfs:subClassOf</code> declarations needed to walk the class hierarchy must exist in the <a>data graph</a>.
						However, the <code>ex:Person a rdfs:Class</code> triple is not required to exist in either graphs.
					</p>
					<p>
						In the following example, the selected target node is only <code>ex:Who</code>.
					</p>
					<pre class="example-data">
ex:Doctor rdfs:subClassOf ex:Person .
<span class="focus-node-selected">ex:Who</span> a ex:Doctor .
ex:House a ex:Nephrologist .</pre>

					<p class="def-sparql">
						The following SPARQL query specifies the semantics of class targets.
						The variable <code>targetClass</code> is assumed to be <a href="#pre-binding">pre-bound</a> to the given value of <code>sh:targetClass</code>.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this    <span class="triple-can-be-skipped"># ?this is the focus node</span>
WHERE {
	?this rdf:type/rdfs:subClassOf* $targetClass .    <span class="triple-can-be-skipped"># $targetClass is <a href="#pre-binding">pre-bound</a> to ex:Person</span>
}</pre>
					</div>

					<section id="implicit-targetClass">
						<h4>Implicit Class Targets</h4>
						<p>
							When, in the <a>shapes graph</a>, a <a>shape</a> is a <a>SHACL instance</a> of both <code>sh:Shape</code> and <code>rdfs:Class</code>
							then the <a>shape</a> is a <a>class target</a> of itself.
						</p>
						<pre class="example-shapes">
ex:Person
	<b>a rdfs:Class</b>, sh:Shape .</pre>
						<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
ex:NewYork a ex:Place .</pre>
						<p>
							In this example, only <code>ex:Alice</code> is a focus node, because it is a <a>SHACL instance</a> of
							<code>ex:Person</code> which is both a class and a shape in the <a>shapes graph</a>.
						</p>
					</section>
				</section>
				
				<section id="targetSubjectsOf">
					<h5>Subjects-of targets (sh:targetSubjectsOf)</h5>
					<p>
						A <dfn>subjects-of target</dfn> is defined with the predicate <code>sh:targetSubjectsOf</code>,
						the <a>values</a> of which must be <a>IRIs</a>.
						For every value <code>p</code> of such a target, the validated nodes are defined as
						the set of <a>subjects</a> in the <a>data graph</a> that appear in a <a>triple</a> with <code>p</code> as a <a>predicate</a>.
					</p>

					<pre class="example-shapes">
ex:TargetSubjectsOfExampleShape
	a sh:Shape ;
	sh:targetSubjectsOf ex:knows .</pre>
					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> ex:knows ex:Bob .
ex:Bob ex:livesIn ex:NewYork .</pre>
					<p>
						In the example above, only <code>ex:Alice</code> is validated against the given shape,
						because it is the <a>subject</a> of a <a>triple</a> that has <code>ex:knows</code> as its <a>predicate</a>.
					</p>

					<p class="def-sparql">
						The following SPARQL query specifies the semantics of subjects-of targets.
						The variable <code>targetSubjectsOf</code> is assumed to be <a href="#pre-binding">pre-bound</a> to the given value of <code>sh:targetSubjectsOf</code>.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this    <span class="triple-can-be-skipped"># ?this is the focus node</span>
WHERE {
	?this $targetSubjectsOf ?any .    <span class="triple-can-be-skipped"># $targetSubjectsOf is <a href="#pre-binding">pre-bound</a>to ex:knows</span>
}</pre>
					</div>
				</section>
				
				<section id="targetObjectsOf">
					<h5>Objects-of targets (sh:targetObjectsOf)</h5>
					<p>
						An <dfn>objects-of target</dfn> is defined with the predicate <code>sh:targetObjectsOf</code>,
						the <a>values</a> of which must be <a>IRIs</a>.
						For every value <code>p</code> of such a target, the validated nodes are defined as
						the set of <a>objects</a> in the <a>data graph</a> that appear in a <a>triple</a> with <code>p</code> as a <a>predicate</a>.
					</p>

					<pre class="example-shapes">
ex:TargetObjectsOfExampleShape
	a sh:Shape ;
	sh:targetObjectsOf ex:knows .</pre>
					<pre class="example-data">
ex:Alice ex:knows <span class="focus-node-selected">ex:Bob</span> .
ex:Bob ex:livesIn ex:NewYork .</pre>
					<p>
						In the example above, only <code>ex:Bob</code> is validated against the given shape,
						because it is the <a>object</a> of a <a>triple</a> that has <code>ex:knows</code> as its <a>predicate</a>.
					</p>

					<p class="def-sparql">
						The following SPARQL query specifies the semantics of objects-of targets.
						The variable <code>targetObjectsOf</code> is assumed to be <a href="#pre-binding">pre-bound</a> to the given value of <code>sh:targetObjectsOf</code>.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this    <span class="triple-can-be-skipped"># ?this is the focus node</span>
WHERE {
	?any $targetObjectsOf ?this .    <span class="triple-can-be-skipped"># $targetObjectsOf is <a href="#pre-binding">pre-bound</a> to ex:knows</span>
}</pre>
					</div>
				</section>
			</section>
			
			<section id="filterShape">
				<h3>Filter Shapes</h3>
				<p>
					A <dfn data-lt="filter shape|filter shapes|filters">filter</dfn> is a <a>shape</a> in the <a>shapes graph</a>
					that further refines which nodes in the data graph are validated against a <a>constraint</a> or all the constraints of a <a>shape</a>.
					A filter is specified as an object in a triple with <code>sh:filterShape</code> as the predicate.
					The subjects of these triples can be constraints or shapes.
					Only those <a>nodes</a> that successfully validate against all the filters of a constraint or a shape become focus nodes for the constraint or the constraints of the shape.
					Note that during the validation against filter shapes, the <a href="#targets">targets</a> of these filters are ignored.
				</p>
				<p>
					The following example states that the <code>sh:minCount</code> constraint on <code>ex:email</code> is filtered to include only <a>SHACL instances</a> of <code>ex:Person</code> that are <code>ex:member</code>s of <code>ex:W3c</code>.
				</p>
				<pre class="example-shapes">
ex:ExampleFilteredShape
	a sh:Shape ;
	sh:targetClass ex:Person ;
	sh:filterShape [
		<span style="color: grey;">a sh:Shape ; # Optional triple</span>
		sh:property [
			sh:predicate ex:member ;
			sh:hasValue ex:W3c ;
		]
	] ;
	sh:property [
		sh:predicate ex:email ;
		sh:minCount 1 ;
	] .</pre>

<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person ;
	ex:member ex:W3c ;
	ex:email &lt;mailto:alice@example.org&gt; .
<span class="focus-node-selected">ex:John</span> a ex:Person ;
	ex:member ex:W3c .
ex:Bob a ex:Person ;
	ex:member ex:Acme .</pre>

				<pre class="example-results">
[  a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:John ;
	sh:path ex:email ;
	sh:message "sh:minCount for ex:email is '1'." ;
	sh:sourceConstraintComponent sh:MinCountConstraintComponent ;
	sh:sourceShape ex:ExampleFilteredShape ; 
] . </pre>

				<p>
					The following example shows a <code>sh:filterShape</code> that is defined for a specific <a>property constraint</a>, instead of the whole <a>shape</a>.
					In this scenario, the <code>sh:minCount</code> constraint is only applied to persons that are also member of <code>ex:W3c</code>.
				</p>

				<pre class="example-shapes">
ex:FilteredExampleShape
	a sh:Shape ;
	sh:targetClass ex:Person ;
	sh:property [
		sh:predicate ex:email ;
		sh:minCount 1 ;
		sh:filterShape [
			sh:property [
				sh:predicate ex:member ;
				sh:hasValue ex:W3c ;
			]
		] ;
	] .
</pre>

			</section>
			
			<section id="shape-constraints">
				<h3>Constraints</h3>
				<p>
					The SHACL Core language defines two types of constraints:
					a) constraints about a particular property or <a>path</a> and its <a>values</a> for the focus node (<a>property constraints</a>) and
					b) constraints about the <a>focus node</a> itself (<a>focus node constraints</a>).
					In addition to those, SHACL Full can be used to define
					<a href="#sparql-constraints">SPARQL-based constraints</a> or
					<a href="#constraint-components">SPARQL-based constraint components</a>.
					SHACL constraints are defined within shapes as specified by each constraint type.
					<code>sh:Constraint</code> is the <a>SHACL superclass</a> of all SHACL constraint types.
				</p>

				<p>
					Constraints may contain
					<a href="#nonValidation">non-validating</a> properties (such as <code>sh:description</code>) and
					<a>parameters</a> of <a>constraint components</a> (e.g. <code>sh:minCount</code>).
					<a>Constraint components</a> declare one or more <a>parameter</a> properties and <a>validation</a> instructions
					(such as those implemented as SPARQL queries) that can be used to perform the <a>validation</a> for the given <a>focus node</a> and parameter <a>values</a>.
					<!-- The relationship between a <a>constraint component</a> and the <span class="term">constraint types</span>
					that it can be used with is called the <dfn data-lt="contexts">context</dfn> of the component.
					For example, the <span class="term">context</span> of the component defining the <code><a href="#ClosedConstraintComponent">sh:closed</a></code> property is <code>sh:NodeConstraint</code>.
					This means that the property <code>sh:closed</code> can only be used in <a>SHACL instances</a> of <code>sh:NodeConstraint</code>.-->
					The list of predefined constraint components in SHACL Core is described in <a href="#constraints">section 4</a>.
				</p>

				<section id="property-constraints-section">
					<h4>Property Constraints (sh:predicate or sh:path)</h4>

					<p>
						<a>Property constraints</a> specify conditions that must be met with respect to <a>nodes</a> that can be reached from the
						<a>focus node</a> either by directly following a given property (specified using <code>sh:predicate</code>) or a given <a>property path</a> (specified using <code>sh:path</code>).
						<a>Property constraints</a> are defined in a <a>shape</a> with the property <code>sh:property</code>.
						Each value of <code>sh:property</code> must be an <a>IRI</a> or a <a>blank node</a>
						that is the <a>subject</a> of precisely one <a>triple</a> with
						either <a>predicate</a> <code>sh:predicate</code> or <code>sh:path</code>.
						The <a>values</a> of <code>sh:predicate</code> must be <a>IRIs</a>.
						The <a>values</a> of <code>sh:path</code> must be well-formed <a>property paths</a> following the <a href="#path-syntax">SHACL property path syntax rules</a>.
					</p>
					<p>
						The following example illustrates the two syntax variations of property constraints. 
					</p>
					<pre class="example-shapes">
ex:ExampleShapeWithPropertyConstraints
	a sh:Shape ;
	sh:property [
		sh:predicate ex:email ;
		sh:name "e-mail" ;
		sh:description "We need at least one email value" ;
		sh:minCount 1 ;
	] ;
	sh:property [
		sh:path (ex:knows ex:email) ;
		sh:name "Friend's e-mail" ;
		sh:description "We need at least one email for everyone you know" ;
		sh:minCount 1 ;
	] .</pre>
					<p>
						<code>sh:PropertyConstraint</code> is the class of property constraints.
						The objects of triples with <code>sh:property</code> as predicate have <code>sh:PropertyConstraint</code> as <a>expected type</a>.
					</p>

				</section>

				<section id="focus-node-constraints-section">
					<h4>Focus Node Constraints</h4>

					<p>
						<a>Focus node constraints</a> specify conditions that must be met by the <a>focus node</a> itself.
						Since focus node constraints operate directly on the input focus nodes they impose some limitations in comparison to <a>property constraints</a>.
						In particular, constraint <a>parameters</a> that operate on value sets, such as <code>sh:hasValue</code> and <code>sh:equals</code>, are not applicable to focus node constraints.
					</p>
					<p>
						The class <code>sh:Shape</code> is defined as <code>rdfs:subClassOf sh:Constraint</code>.
						Thus, every shape is also a focus node constraint.
					</p>

					<pre class="example-shapes">
ex:ExampleShapeWithFocusNodeConstraint
	a sh:Shape ;
	sh:targetClass ex:Person ;
	sh:stem "https://www.w3.org/People/" .</pre>

				</section>

				<section id="multiple-parameter-constraints-section">
					<h4>Multiple Parameters</h4>
					<p>
						Some constraint components declare only a single parameter.
						For example <a href="#ClassConstraintComponent"><code>sh:ClassConstraintComponent</code></a> has the single parameter <code>sh:class</code>.
						These parameters may be used multiple times in the same constraint node.
						The interpretation of such declarations is conjunction, i.e. all constraints apply.
						In the following example this technique is used to restrict the values of <code>ex:customer</code> to be <a>SHACL instances</a> of both
						<code>ex:Customer</code> and <code>ex:Person</code>.
					</p>
					<pre class="example-shapes">
ex:InvoiceShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:customer ;
		sh:class ex:Customer ;
		sh:class ex:Person ;
	] .</pre>
					<p>
						Some constraint components such as <a href="#PatternConstraintComponent"><code>sh:PatternConstaintComponent</code></a> declare more than one parameter.
						Constraints are not allowed to have more than one value for any of the parameters of such components.
					</p>
				</section>

				<section id="path-syntax">
					<h4>Property Paths</h4>
					<p>
						SHACL includes an RDF vocabulary to represent <a>property paths</a> that is equivalent to a subset of <a href="https://www.w3.org/TR/sparql11-query/#pp-language">SPARQL 1.1 property paths</a>.
						In particular, SHACL supports the following SPARQL 1.1 property path constructs:
						<code>PredicatePath</code>, <code>InversePath</code>, <code>SequencePath</code>, <code>AlternativePath</code>,
						<code>ZeroOrMorePath</code>, <code>OneOrMorePath</code> and <code>ZeroOrOnePath</code>.

						A valid <dfn>SHACL property path</dfn> <code>p</code> is an <a>IRI</a> or a <a>blank node</a> that can be
						correctly traversed recursively using the following rules.
					</p>
					<ol>
						<li>
							If the graph contains a <a>triple</a> of the form <code>p sh:inversePath elt</code>
							then the path becomes an <code>InversePath</code> element of <code>elt</code> and <code>elt</code> must be a valid SHACL property path.
							Corresponding rules apply for
							<code>sh:zeroOrMorePath</code> (<code>ZeroOrMorePath</code>),
							<code>sh:zeroOrOnePath</code> (<code>ZeroOrOnePath</code>) and
							<code>sh:oneOrMorePath</code> (<code>OneOrMorePath</code>).
						</li>
						<li>
							If the graph contains a <a>triple</a> of the form <code>p rdf:first elt</code>,
							the path must be an <a>RDF list</a> with a at least two <a>members</a>.
							Each member must be valid SHACL property path that is converted into a sequence of either <code>SequencePath</code> or <code>AlternativePath</code> elements.
						</li>
						<li>
							If the graph contains a <a>triple</a> of the form <code>p sh:alternativePath elt</code>,
							the value of path must be an <a>RDF list</a> with a at least two <a>members</a>.
							All members must be valid SHACL property paths that become a series of <code>AlternativePath</code> elements.
						</li>
						<li>
							If <code>p</code> is an <a>IRI</a> then it is turned into a <code>PredicatePath</code>
							with value <code>p</code>.
						</li>

					</ol>
					<p>
						A SHACL property path is invalid if:
					</p>
					<ul>
						<li><code>p</code> is a <a>blank node</a> that is not handled by any of the above rules.</li>
						<li>During the path traversal the same node is reached more than once.</li>
						<li>There is a <a>value</a> for <code>p</code> with a predicate different from:
						<code>sh:inversePath</code>, <code>sh:alternativePath</code>, <code>sh:zeroOrMorePath</code>,
						<code>sh:zeroOrOnePath</code>, <code>sh:oneOrMorePath</code> or <code>rdf:first</code>.</li>
						<li>There are two or more <a>triples</a> with <code>p</code> as a subject.</li>
					</ul>
					<p>
						The following example illustrates some valid SHACL property paths, together with their SPARQL 1.1 equivalents.
					</p>
					<pre class="example-shapes">
# ex:parent
[] sh:path ex:parent .

# ^ex:parent
[] sh:path [ sh:inversePath ex:parent ] .

# ex:parent/ex:firstName
[] sh:path ( ex:parent ex:firstName ) .
					
# rdf:type/rdfs:subClassOf*
[] sh:path ( rdf:type [ sh:zeroOrMorePath rdfs:subClassOf ] ) .

# ex:father|ex:mother
[] sh:path [ sh:alternativePath ( ex:father ex:mother  ) ] .</pre>
				</section>

				<section>
					<h5>sh:path and sh:predicate</h5>
					<p>
						<code>sh:predicate</code> is a convention for declaring a simple predicate path of length one.
						In almost all cases, <code>sh:path</code> can be used in place of <code>sh:predicate</code> without changing the semantics of the property constraint.
						There are exceptions in cases when the value is a valid SHACL property path.
					</p>
					<pre class="example-shapes">
ex:ShapeWithIdenticalPath
	a sh:Shape ;
	sh:property [
		sh:predicate ex:mother .
	]
	sh:property [
		sh:path ex:mother .
	] .

ex:ShapeWithDifferentPath
	a sh:Shape ;
	sh:property [
		sh:predicate ex:parent .
	]
	sh:property [
		sh:path ex:parent .
	] .

ex:parent sh:alternativePath ( ex:father ex:mother  ) .</pre>
					<p>
						In the above example, both property constraints of <code>ex:ShapeWithIdenticalPath</code> declare an identical path to <code>ex:mother</code>.
						The property constraints in <code>ex:ShapeWithDifferentPath</code> denote different paths.
						The property constraint with <code>sh:predicate</code> denotes <code>ex:parent</code> while the property constraint with <code>sh:path</code> denotes the property path <code>(ex:father|ex:mother)</code>.
					</p>
				</section>
				<section id="severity">
					<h4>Declaring the Severity of a Constraint</h4>
					<p>
						Constraints may specify a <a>value</a> for the property <code>sh:severity</code> in the <a>shapes graph</a>.
						The values of this property must be <a>IRIs</a>.
						SHACL includes the three pre-defined IRIs to represent <dfn data-lt="severity">severities</dfn> listed in the table below.
						These are defined in the SHACL vocabulary as SHACL instances of <code>sh:Severity</code>.
					</p>
					<table class="term-table">
						<tr>
							<th>Severity</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>sh:Info</code></td>
							<td>A non-critical constraint violation indicating an informative message.</td>
						</tr>
						<tr>
							<td><code>sh:Warning</code></td>
							<td>A non-critical constraint violation indicating a warning.</td>
						</tr>
						<tr>
							<td><code>sh:Violation</code></td>
							<td>A constraint violation that should be fixed.</td>
						</tr>
					</table>
					<p>
						The specific values of <code>sh:severity</code> have no impact on the validation,
						but MAY be used by user interface tools to categorize validation results.
						The values of <code>sh:severity</code> are used by SHACL processors to populate the <code>sh:severity</code> field of
						validation results, see <a href="#results-severity">section on severity in validation results</a>.
						For every constraint, <code>sh:Violation</code> is the default if <code>sh:severity</code> is unspecified.
						The following example illustrates this.
					</p>
					<pre class="example-shapes">
ex:MyShape
	a sh:Shape ;
	sh:targetNode ex:MyInstance ;
	sh:property [
		# Violations of sh:minCount and sh:datatype are produced as warnings
		sh:predicate ex:myProperty ;
		sh:minCount 1 ;
		sh:datatype xsd:string ;
		sh:severity sh:Warning ;
	] ;
	sh:property [
		# The default severity here is sh:Violation
		sh:predicate ex:myProperty ;
		sh:maxLength 10 ;
		sh:message "Too many characters"@en ;
		sh:message "Zu viele Zeichen"@de ;
	] .</pre>
					<pre class="example-data">
ex:MyInstance
	ex:myProperty "http://toomanycharacters"^^xsd:anyURI .</pre>
					<pre class="example-results">
[
	a sh:ValidationResult ;
	sh:focusNode ex:MyInstance ;
	sh:path ex:myProperty ;
	sh:severity sh:Warning ;
	sh:sourceConstraintComponent sh:DatatypeConstraintComponent ;
	sh:sourceShape ex:MyShape ;
	sh:value "http://toomanycharacters"^^xsd:anyURI ;
] .
[
	a sh:ValidationResult ;
	sh:focusNode ex:MyInstance ;
	sh:message "Too many characters"@en ;
	sh:message "Zu viele Zeichen"@de ;
	sh:path ex:myProperty ;
	sh:severity sh:Violation ;
	sh:sourceConstraintComponent sh:MaxLengthConstraintComponent ;
	sh:sourceShape ex:MyShape ;
	sh:value "http://toomanycharacters"^^xsd:anyURI ;
] .</pre>
				</section>
				<section id="message-constraint">
					<h4>Defining Messages for a Constraint</h4>
					<p>
						Constraints may have values for the property <code>sh:message</code>, and
						these values must be <code>xsd:string</code> literals or literals with a language tag.
						If a constraint has at least one value for <code>sh:message</code> in the shapes graph, then
						all validation results produced as a result of the constraint will have exactly these messages
						as their value of <code>sh:message</code>, i.e. the values will be copied from the shapes graph
						into the results graph.
						A constraint SHOULD NOT have more than one value for <code>sh:message</code> with the same language tag.
					</p>
					<p>
						The example from the previous section uses this mechanism to supply the second validation result
						with two messages.
						See the <a href="#results-message">section on <code>sh:message</code> in the validation results</a>
						on further details on how the values of <code>sh:message</code> are populated.
					</p>
				</section>
				
			</section>
		</section>

		<section id="validation">
			<h2>Validation and Graphs</h2>
			<p>
				The definition for <dfn data-lt="validation|validates|validated|validate">validating</dfn> a <a>data graph</a>
				against a <a>shapes graph</a> as well as a <a>node</a> from the data graph against a <a>shape</a> from the shapes graph is provided below:
			</p>

			<div id="def-validation" class="def def-text">
				<div class="def-header">VALIDATION DEFINITION</div>
				<div class="def-text-body">
					Validation is the process of determining whether a <a>data graph</a>, or <a>nodes</a> in the <a>data graph</a>, validate against a <a>shapes graph</a>.
					<ul>
						<li>A <a>node</a> validates against a <a>shape</a> if and only if
							it does not validate against some <a>filter</a> of the shape
							and then none of the <a>constraints</a> in the shape produce
							a <a>validation result</a> or a <a>failure</a> for the node.
							Thus, filter shapes are validated and valid nodes are passed on
							for validation with respect to the associated shapes or constraints.
						</li>
						<li>A <a>data graph</a> validates against a <a>shape</a> if and only if
							each node that is in any of the <a>targets</a> of the shape validates against the shape.
						</li>
						<li>A <a>data graph</a> validates against a <a>shapes graph</a> if and only if
							the data graph validates against each <a>shape</a> in the shapes graph.
						</li>
					</ul>
				</div>
			</div>

			<p>
				After validation, SHACL processors MUST return a <a>validation report</a> containing all <a>validation results</a>.
				For simpler validation scenarios, SHACL processors SHOULD provide an additional validation interface that returns only
				<code>true</code> for valid or <code>false</code> for invalid.
				Only SHACL implementations that can return all of the mandatory properties of the <a>Validation Results Vocabulary</a> are standards-compliant.
			</p>
			<p>
				A validation may also result in a <dfn>failure</dfn>, which is reported by a SHACL processor to indicate that a request could not be handled.
				Failures are not represented as part of the validation report but through implementation-specific channels.
			</p>
			<p>
				To validate a data graph against the shapes graph, a SHACL processor requires the shapes graph and the data graph as arguments for the validation process.
				Optionally, two additional arguments may be provided for validating a specific node from the data graph against a specific shape from the shapes graph.
			</p>
			<p>
				SHACL can be used with RDF graphs that are obtained by any means, e.g. from the file system, HTTP requests, or <a href="http://www.w3.org/TR/rdf11-concepts/#section-dataset">RDF datasets</a>.
				SHACL makes no assumptions about whether a graph contains triples that are entailed from the graph under any RDF entailment regime.
			</p>
			<p>
				During validation, the <a>data graph</a> and the <a>shapes graph</a> MUST remain immutable, i.e. both graphs at the end of the validation must be identical to the graph at the beginning of validation.
				SHACL processors MUST NOT change the graphs that they use to construct the shapes graph or the data graph,
				even if these graphs are part of an RDF store that allows changes to its stored graphs.
				SHACL processors MAY store the graphs that they create, such as a graph containing validation results,
				and this operation MAY change existing graphs in an RDF store, but not any of the graphs that were used to construct the shapes graph or the data graph.
				SHACL processing is thus idempotent.
			</p>

			<section id="shapes-graph">
				<h3>Shapes Graph</h3>
				<p>
					The <dfn data-lt="shapes graphs">shapes graph</dfn> is an RDF graph that contains shape definitions that a <a>data graph</a> can be tested against.
					Shapes graphs can be reusable validation modules that can be cross-referenced with the predicate <a href="http://www.w3.org/TR/owl2-syntax/#Imports"><code>owl:imports</code></a>.
					As a pre-validation step, SHACL processors SHOULD extend the originally provided <a>shapes graph</a> by transitively following and importing all referenced <a>shapes graphs</a>
					through the <a href="http://www.w3.org/TR/owl2-syntax/#Imports"><code>owl:imports</code></a> predicate.
					The resulting graph forms the input <a>shapes graph</a> for validation and MUST NOT be further modified during the validation process.
				</p>
				<p>
					In addition to shape definitions, the shapes graph may contain additional information for the SHACL processor such as <a href="#entailment">entailment</a> directives.
				</p>
				<section id="shapes-recursion">
					<h4>Recursive shapes</h4>
					<p id="recursion">
						A <dfn>recursive shape</dfn> is a shape whose constraints refer to the shape directly or transitively via the parameters of
						<a href="#constraints-shape">shape-based constraint components</a> (e.g. <code>sh:shape</code>),
						<a href="#constraints-logical">logical constraint components</a> (e.g. <code>sh:or</code>) or
						<a href="#filterShape">filter shapes</a> (<code>sh:filterShape</code>).

						The handling of recursive shapes is not defined in SHACL and is left to SHACL processor implementations.
					</p>
				</section>

			</section>
			
			<section id="data-graph">
				<h3>Data Graph</h3>
				<p>
					The <dfn data-lt="data graphs">data graph</dfn> is an RDF graph that a SHACL processor can <a>validate</a>.
					SHACL processors treats it as a general RDF graph and makes no assumption about its nature.
					For example, it can be an in-memory graph or a named graph from an RDF dataset or a SPARQL endpoint.
				</p>
				<p>
					The data graph is expected to include all the ontology axioms related to the data and especially all the <code>rdfs:subClassOf</code> triples in order for SHACL to correctly identify class targets and validate Core SHACL constraints.
				</p>
			</section>
			
			<section id="sh-shapes-graph">
				<h3>Linking to shapes graphs (sh:shapesGraph)</h3>
				<p>
					A <a>data graph</a> can include triples used to suggest one or more graphs to a SHACL processor with the predicate <code>sh:shapesGraph</code>.
					Every <a>value</a> of this property is an <a>IRI</a> representing a graph that should be included into the <a>shapes graph</a> used to validate the <a>data graph</a>.
				</p>
				<p>
					In the following example, a SHACL processor may use the union of <code>ex:graph-shapes1</code> and <code>ex:graph-shapes2</code> graphs (and their <code>owl:imports</code>) as the <a>shapes graph</a> when validating the given graph.
				</p>

				<pre class="example-data">
&lt;http://example.com/myDataGraph&gt;
	sh:shapesGraph ex:graph-shapes1 ;
	sh:shapesGraph ex:graph-shapes2 .</pre>

				<p>
					SHACL provides a way for schema (i.e. ontology or vocabulary) creators to suggest a set of <a>shapes graphs</a> for validating <a>data graphs</a> that uses that schema.
					These suggestions MAY be taken into account by users for specifying a shapes graph in order to validate a data graph.
					The suggestions are instantiated in the <a href="https://www.w3.org/TR/owl2-syntax/#Ontology_Documents">schema documents</a>
					where every value for the property <code>sh:shapesGraph</code> denotes a suggested <a>shapes graph</a>.
					When the schema is identified by a <a href="https://www.w3.org/TR/owl2-syntax/#Ontology_IRI_and_Version_IRI">schema IRI or a version IRI</a>,
					this IRI SHOULD be the subject of these triples.
				</p>
			</section>

			<section id="validation-report">
				<h3>Validation report</h3>
				<p>
					The <dfn data-lt="validation report|report">validation report</dfn> is the result of the validation process and includes a set of zero or more <dfn data-lt="validation result|result">validation results</dfn>.
					The properties of the SHACL <dfn>Validation Results Vocabulary</dfn> are defined in this section.
					This vocabulary defines the RDF properties to represent structural information that may provide guidance on how to identify or fix a violation.
				</p>
				<p>
					The validation results produced by a SHACL processor MUST be the product of validation of the <a>data graph</a> only.
					Some SHACL processors MAY also report errors in the <a>shapes graph</a>, but those errors MUST NOT be included in the data validation results.
				</p>
				<p>
					The following graph represents an example of a validation result.
					Note that the specific value of <code>sh:message</code> is not mandated by SHACL and considered implementation-specific.
				</p>
			<pre class="example-results">
ex:ExampleConstraintViolation
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:Bob ;
	sh:path ex:age ;
	sh:value "twenty two" ;
	sh:message "ex:age expects a literal of datatype xsd:integer." ;
	sh:sourceConstraintComponent sh:DatatypeConstraintComponent ;
	sh:sourceShape ex:PersonShape .</pre>
				<p>
					Validation results must be <a>SHACL instances</a> of the class <code>sh:ValidationResult</code>.
					Its <a>SHACL superclass</a>, <code>sh:AbstractResult</code>, defines the properties described in the remaining sub-sections of this section.
					SHACL implementations may use other <a>SHACL subclasses</a> of <code>sh:AbstractResult</code>, for example
					to report successfully completed constraint checks or accumulated results.
					The properties <code>sh:focusNode</code> and <code>sh:severity</code> are the only properties that are mandatory for all validation results.
					The property <code>sh:sourceConstraintComponent</code> is mandatory for validation results produced by violations of <a>constraint components</a>.
				</p>
				<section id="results-focus-node">
					<h4>Focus node (sh:focusNode)</h4>
					<p>
						Validation results must have a single value for the property <code>sh:focusNode</code> to point to a
						<a>node</a> that has caused the result.
						This is the <a>focus node</a> that was validated when the validation result was produced.
					</p>
				</section>
				<section id="results-path">
					<h4>Path (sh:path)</h4>
					<p>
						Validation results may have a value for the property <code>sh:path</code> pointing at a well-formed <a>property path</a> starting with the given <code>sh:focusNode</code>.
						For results produced by a <a>property constraint</a>, this <a>path</a> is always identical to either the <code>sh:predicate</code> or <code>sh:path</code> of the constraint.
					</p>
				</section>
				<section id="results-value">
					<h4>Value (sh:value)</h4>
					<p>
						Validation results may include, as a <a>value</a> of the property <code>sh:value</code>,
						a specific node that has caused the result.
						The values of <code>sh:value</code> are populated by a SHACL processor based on the rules
						outlined in the section on <a href="#constraints">Core Constraint Components</a>.
						In most of these cases, the values of <code>sh:value</code> are the <a>value nodes</a> that have violated a constraint.
						For SPARQL-based constraints, the values of <code>sh:value</code> are derived using a <a href="#sparql-constraints-variables">Mapping of SPARQL Result Variables</a>.
					</p>
				</section>
				<section id="results-source-shape">
					<h4>Source (sh:sourceConstraint, sh:sourceShape)</h4>
					<p>
						Validation results may link to the IRI of the <a>constraint</a> that has caused
						the result, specified via the property <code>sh:sourceConstraint</code>,
						and at the IRI of the shape defining the constraint, via <code>sh:sourceShape</code>.
					</p>
				</section>
				<section id="results-source-constraint-component">
					<h4>Constraint Component (sh:sourceConstraintComponent)</h4>
					<p>
						For validation results produced as a result of a <a>constraint component</a>,
						the property <code>sh:sourceConstraintComponent</code> must have as its object value the IRI of the <a>constraint component</a> that caused the result.
						For example, results produced due to a violation of a constraint based on a value of <code>sh:minCount</code> would have the value <code>sh:MinCountConstraintComponent</code>.
					</p>
				</section>
				<section id="results-detail">
					<h4>Detail (sh:detail)</h4>
					<p>
						The property <code>sh:detail</code> may link a (parent) result with one or more other
						(child) results that provide further details about the cause of the (parent) result.
						Depending on the capabilities of the SHACL processor, this may include violations of
						nested constraints that have been evaluated via <code>sh:shape</code>.
					</p>
				</section>
				<section id="results-message">
					<h4>Message (sh:message)</h4>
					<p>
						Validation results may have values for the property <code>sh:message</code> to communicate
						additional textual details to humans.
						While <code>sh:message</code> may have multiple values, there SHOULD not be two values with the same language tag.
						These values are produced by a validation engine based on the values of <code>sh:message</code> of the constraints
						in the shapes graph, see <a href="#message-constraint">Defining Messages for a Constraint</a>.
						In cases where a constraint does not define any values of <code>sh:message</code> in the shapes graph the
						following policy applies:
					</p>
					<ul>
						<li>
							For validation results produced as a result of SPARQL-based constraints and constraint components,
							the messages are derived from a <a href="#sparql-constraints-variables">Mapping of SPARQL Result Variables</a>.
						</li>
						<li>
							For validation results produced as a result of constraint components from the SHACL Core,
							a SHACL processor MAY automatically generate other values for <code>sh:message</code>.
						</li>
					</ul>
				</section>
				<section id="results-severity">
					<h4>Severity (sh:severity)</h4>
					<p>
						Each validation result must have exactly one <a>value</a> for the property <code>sh:severity</code>, and this value must be a <a>IRI</a>.
						The values are derived from the <a>shapes graph</a> as described in the section <a href="#severity">Declaring the Severity of a Constraint</a>.
					</p>
				</section>
			</section>
		</section>

		<section id="constraints">
			<h2>Core Constraint Components</h2>
			<p>
				This section defines the built-in SHACL Core <a>constraint components</a> that MUST be supported by all SHACL Core processors.
				Each constraint component is identified by an IRI that is referenced in the validation results via <code>sh:sourceConstraintComponent</code>.
			</p>
			<p>
				The choice of constraint components that are defined by the SHACL Core was made based on
				the requirements collected by the [[shacl-ucr]] document.
				Special attention was paid to the balance between trying to cover as many common use cases as possible
				and keeping the size of the Core language manageable.
				Not all use cases (such as describing constraints on members of an <code>rdf:List</code>) can be expressed by the Core language alone.
				Instead, SHACL Full provides an extension mechanism, described in the second part of this specification.
				It is expected that additional reusable libraries of <a>constraint components</a> will be maintained by third parties.
			</p>
			<p>
				All constraint components can be used both in <a>property constraints</a> and <a>focus node constraints</a>.
				However, some components may always result in violations in a particular constraint type.
				For example, <a href="#ClosedConstraintComponent">sh:closed</a> does not make sense in <a>property constraints</a>
				or <a href="#HasValueConstraintComponent">sh:hasValue</a> in <a>focus node constraints</a>.
			</p>
			<p>
				The textual description of each component refers to the concept of <dfn data-lt="value node">value nodes</dfn>
				which is defined as follows, including rules for the creation of validation results:
			</p>
			<ul>
				<li>
					For <a>property constraints</a> that have a <code>sh:predicate</code> the <span class="term">value nodes</span> are the <a>objects</a> of the <a>triples</a> that have the <a>focus node</a> as <a>subject</a> and the <code>sh:predicate</code> value as <a>predicate</a>.
					Each produced <a>validation result</a> must have the <a>focus node</a> as its <code>sh:focusNode</code>,
					the <code>sh:predicate</code> as its <code>sh:path</code> and, if applicable, the respective violating value node as its <code>sh:value</code>.
				</li>
				<li>
					For <a>property constraints</a> that have a <code>sh:path</code> the <span class="term">value nodes</span> is the set of <a>nodes</a> in the <a>data graph</a>
					that can be reached from the <a>focus node</a> with the provided <a>SHACL property path</a>.
					Each produced <a>validation result</a> must have the <a>focus node</a> as its <code>sh:focusNode</code>,
					and, if applicable, the respective violating value node as its <code>sh:value</code>.
					The value of <code>sh:path</code> of each validation result must point to a <a>SHACL property path</a> that <a href="#path-syntax">represents</a> an equivalent path like the one provided in the constraint.
				</li>
				<li>
					For <a>focus node constraints</a> the <span  class="term">value nodes</span> are the individual <a>focus nodes</a>, forming a set of exactly one node.
				</li>
			</ul>
			<section id="constraints-sparql-definitions" class="def-sparql">
				<h3>SPARQL definitions for built-in constraint components</h3>
				<p>
					The SPARQL definitions in this section represent potential <a href="#constraint-components-validators">validators</a>.
					Many constraint components are written as SPARQL ASK queries.
					These queries are interpreted against each <a>value node</a>, bound to the variable <code>value</code>.
					If an ASK query does not evaluate to <code>true</code> for a <a>value node</a>, a <a>validation result</a> is produced based on the rules outlined in
					the <a href="#SPARQLAskValidator">section on ASK-based validators</a>.
					Constraint components that are described using a SELECT query are interpreted based on the rules outlined in
					the <a href="#SPARQLSelectValidator">section on SELECT-based validators</a>.
					In particular, for <a>property constraints</a>, the variable <code>PATH</code> is substituted with a <a>path</a> expression
					based on the values of either <code>sh:predicate</code> or <code>sh:path</code> in the constraint.
					All SPARQL queries also assume the variable bindings and result variable mapping rules detailed in the
					<a href="#sparql-constraints">section on SPARQL-based Constraints</a>.
					The variable <code>this</code> represents the currently validated <a>focus node</a>.
					Based on the parameter IRIs on the tables, <a>pre-bound</a> variables are defined using the <a>parameter names</a>.
				</p>
			</section>

			<section id="constraints-value-type">
				<h3>Value Type Constraint Components</h3>
				<p>
					The constraint components in this section have in common that they define restrictions
					on the type of the nodes.
					Note that it is possible to represent multiple value type options using <a href="#OrConstraintComponent">sh:or</a>.
				</p>
				<section id="ClassConstraintComponent">
					<h4>sh:class</h4>
					<p>
						The property <code>sh:class</code> can be used to verify that each <a>value node</a> is a <a>SHACL instance</a> of a given type.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:ClassConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:class</code></td>
							<td>Type of all value nodes</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:class</code> must be IRIs.
							A <a>validation result</a> must be produced for each <a>value node</a>
							that is either a <a>literal</a>, or a non-literal that is not a <a>SHACL instance</a> of the given <a>class</a> in the <a>data graph</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	$value rdf:type/rdfs:subClassOf* $class .
}</pre>
					</div>
					<pre class="example-shapes">
ex:ClassExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob, ex:Alice, ex:Carol ;
	sh:property [
		sh:predicate ex:knows ;
		sh:class ex:Person ;
	] .</pre>

					<pre class="example-data">
ex:Alice a ex:Person .
ex:Bob ex:knows ex:Alice .
<span class="focus-node-error">ex:Carol</span> ex:knows ex:Bob .</pre>
				</section>
				
				<section id="DatatypeConstraintComponent">
					<h4>sh:datatype</h4>
					<p>
						The property <code>sh:datatype</code> can be used to restrict the datatype of all <a>value nodes</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:DatatypeConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:datatype</code></td>
							<td>Datatype of all value nodes (e.g., <code>xsd:integer</code>)</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:datatype</code> must be the <a>IRIs</a> of <a>datatypes</a>, such as <code>xsd:string</code>.
							A <a>validation result</a> must be produced for each <a>value node</a>
							that is not a <a>literal</a>, or is a <a>literal</a> with a mismatching datatype.
							A <a>literal</a> matches a datatype if the <a>literal</a>'s datatype has the same <a>IRI</a>
							and, for the datatypes supported by SPARQL 1.1, is not an <a href="https://www.w3.org/TR/rdf11-concepts#section-Graph-Literal">ill-typed</a> literal.
						</div>
					</div>
					<pre class="example-shapes" title="Shape with sh:datatype property constraint">
ex:DatatypeExampleShape
	a sh:Shape ;
	sh:targetNode ex:Alice, ex:Bob, ex:Carol ;
	sh:property [
		sh:predicate ex:age ;
		sh:datatype xsd:integer ;
	] .</pre>

					<pre class="example-data">
ex:Alice ex:age "23"^^xsd:integer .
<span class="focus-node-error">ex:Bob</span> ex:age "twenty two" .
<span class="focus-node-error">ex:Carol</span> ex:age "23"^^xsd:int .</pre>
				</section>
				
				<section id="NodeKindConstraintComponent">
					<h4>sh:nodeKind</h4>
					<p>
						The property <code>sh:nodeKind</code> is used to restrict the RDF node kind of each <a>value node</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:NodeKindConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:nodeKind</code></td>
							<td>Node kind (IRI, blank node, literal or combinations of these) of all value nodes</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:nodeKind</code> must be one of the following six instances of the class <code>sh:NodeKind</code>:
							<code>sh:BlankNode</code>, <code>sh:IRI</code> and <code>sh:Literal</code> as well as the
							following values that represent combinations of the former three, i.e. either-or:
							<code>sh:BlankNodeOrIRI</code>, <code>sh:BlankNodeOrLiteral</code> and <code>sh:IRIOrLiteral</code>.
							A <a>validation result</a> must be produced for each <a>value node</a>
							that does not match the given node kind.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER ((isIRI($value) &amp;&amp; $nodeKind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ) ) ||
		(isLiteral($value) &amp;&amp; $nodeKind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ) ) ||
		(isBlank($value)   &amp;&amp; $nodeKind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ) )) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:NodeKindExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob, ex:Alice ;
	sh:property [
		sh:predicate ex:knows ;
		sh:nodeKind ex:IRI ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:knows ex:Alice .
<span class="focus-node-error">ex:Alice</span> ex:knows "Bob" .</pre>
				</section>
			</section>

			<section id="constraints-count">
				<h3>Cardinality Constraint Components</h3>
				<p>
					The following <a>constraint components</a> represent restrictions on the number of
					<a>values</a> that the <a>focus node</a> may have for the given property or property path.
					SHACL has no default cardinality restrictions on properties.
					Focus node constraints have a cardinality always equal to 1 by design.
				</p>
				<section id="MinCountConstraintComponent">
					<h4>sh:minCount</h4>
					<p>
						The property <code>sh:minCount</code> restricts the minimum number of <a>value nodes</a>.
						If the minimum cardinality value is 0 then this constraint is always satisfied and so may be omitted.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:MinCountConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minCount</code></td>
							<td>The minimum cardinality.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:minCount</code> must be literals with datatype <code>xsd:integer</code>.
							A <a>validation result</a> must be produced if the number of
							<a>value nodes</a> is less than the value of <code>sh:minCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this
WHERE {
	OPTIONAL {
		$this $PATH ?value .
	}
} 
GROUP BY $this
HAVING (COUNT(DISTINCT ?value) &lt; $minCount)</pre>
					</div>
					<pre class="example-shapes">
ex:MinCountExampleShape
	a sh:Shape ;
	sh:targetNode ex:Alice, ex:Bob ;
	sh:property [
		sh:predicate ex:name ;
		sh:minCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:Alice ex:name "Alice" .
<span class="focus-node-error">ex:Bob</span> ex:givenName "Bob"@en .</pre>
				</section>
				
				<section id="MaxCountConstraintComponent">
					<h4>sh:maxCount</h4>
					<p>
						The property <code>sh:maxCount</code> restricts the maximum number of <a>value nodes</a>.
						If this parameter is omitted then there is no limit on the number of triples.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:MaxCountConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:maxCount</code></td>
							<td>The maximum cardinality.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:maxCount</code> must be literals with datatype <code>xsd:integer</code>.
							A <a>validation result</a> must be produced if the number of
							<a>value nodes</a> is greater than the value of <code>sh:maxCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this
WHERE {
	$this $PATH ?value .
}
GROUP BY $this
HAVING (COUNT(DISTINCT ?value) > $maxCount)</pre>
					</div>
					<pre class="example-shapes">
ex:MaxCountExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob ;
	sh:property [
		sh:predicate ex:birthDate ;
		sh:maxCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:birthDate "May 5th 1990" .</pre>
				</section>
			</section>
			
			<section id="constraints-range">
				<h3>Value Range Constraint Components</h3>
				<p>
					The following constraint components represent range restrictions on nodes that are comparable
					via operators such as <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.
				</p>
				<section id="range-property-constraints">
					<h4>sh:minExclusive, sh:minInclusive, sh:maxExclusive, sh:maxInclusive</h4>
					<p>
						The properties from the following table restrict the range of <a>value nodes</a>.
						The supported datatypes of these nodes are <code>xsd:string</code>, <code>xsd:boolean</code>, <code>xsd:dateTime</code> and all numeric datatypes such as <code>xsd:integer</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRIs:</span> <code>sh:MinExclusiveConstraintComponent</code>, <code>sh:MinInclusiveConstraintComponent</code>, <code>sh:MaxExclusiveConstraintComponent</code>, <code>sh:MaxInclusiveConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
							<th>Definition</th>
						</tr>
						<tr id="MinExclusiveConstraintComponent">
							<td><code>sh:minExclusive</code></td>
							<td>The minimum exclusive value</td>
							<td><code>&lt;</code></td>
						</tr>
						<tr id="MinInclusiveConstraintComponent">
							<td><code>sh:minInclusive</code></td>
							<td>The minimum inclusive value</td>
							<td><code>&lt;=</code></td>
						</tr>
						<tr id="MaxExclusiveConstraintComponent">
							<td><code>sh:maxExclusive</code></td>
							<td>The maximum exclusive value</td>
							<td><code>&gt;</code></td>
						</tr>
						<tr id="MaxInclusiveConstraintComponent">
							<td><code>sh:maxInclusive</code></td>
							<td>The maximum inclusive value</td>
							<td><code>&gt;=</code></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							that does not match the literal range specified by the table above,
							using the semantics of the SPARQL operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.
							A <a>validation result</a> must also be produced if the node cannot be compared to the specified range.
						</div>
					</div>
					<p>
						Note that if the comparison cannot be performed, for example when someone compares a string with an integer,
						then the SHACL processor will produce a validation result.  This is different from, say, a plain SPARQL query, in
						which such failures would silently not lead to any results.
					</p>
					<p class="def-sparql">
						The following SPARQL definition covers <code>sh:minExclusive</code> - the other variations can be derived by replacing the <code>&lt;</code> operator and the <code>minExclusive</code> variable.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER ($minExclusive &lt; $value)
}</pre>
					</div>
					<pre class="example-shapes">
ex:NumericRangeExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob, ex:Alice, ex:Ted ;
	sh:property [
		sh:predicate ex:age ;
		sh:minInclusive 0 ;
		sh:maxInclusive 150 ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:age 23 .
<span class="focus-node-error">ex:Alice</span> ex:age 220 .
<span class="focus-node-error">ex:Ted</span> ex:age "twenty one" .</pre>
				</section>
			</section>

			<section id="constraints-string">
				<h3>String-based Constraint Components</h3>
				<p>
					The constraint components in this section have in common that they are representing
					restrictions on the string representation of certain nodes.
				</p>
				<section id="MinLengthConstraintComponent">
					<h4>sh:minLength</h4>
					<p>
						The property <code>sh:minLength</code> restricts the string length of <a>value nodes</a>.
						This can be applied to any <a>literals</a> and <a>IRIs</a>, but not to <a>blank nodes</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:MinLengthConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minLength</code></td>
							<td>The minimum length. If the value is 0 then there is no restriction on the string length but this constraint is still violated if the node is a blank node.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:minLength</code> must be literals with datatype <code>xsd:integer</code>.
							A <a>validation result</a> must be produced for each <a>value node</a>
							where the length of its string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							is less than the specified minimum length, or if the node is a <a>blank node</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER (STRLEN(str($value)) >= $minLength) .
}</pre>
					</div>
				</section>
				
				<section id="MaxLengthConstraintComponent">
					<h4>sh:maxLength</h4>
					<p>
						The property <code>sh:maxLength</code> restricts the string length of <a>value nodes</a>
						This can be applied to any <a>literals</a> and <a>IRIs</a>, but not to <a>blank nodes</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:MaxLengthConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:maxLength</code></td>
							<td>The maximum length. If this constraint is omitted then there is no restriction on the string length and no requirement that the node is a literal or IRI.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:maxLength</code> must be literals with datatype <code>xsd:integer</code>.
							A <a>validation result</a> must be produced for each <a>value node</a>
							where the length of its string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							is greater than the specified maximum length, or if the node is a <a>blank node</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER (STRLEN(str($value)) &lt;= $maxLength) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:PasswordExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob, ex:Alice ;
	sh:property [
		sh:predicate ex:password ;
		sh:minLength 8 ;
		sh:maxLength 10 ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:password "123456789" .
<span class="focus-node-error">ex:Alice</span> ex:password "1234567890ABC" .</pre>
				</section>
				
				<section id="PatternConstraintComponent">
					<h4>sh:pattern</h4>
					<p>
						The property <code>sh:pattern</code> can be used to verify that every <a>value nodes</a> matches a given regular expression.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:PatternConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:pattern</code></td>
							<td>Regular expression that all value nodes must match</td>
						</tr>
						<tr>
							<td><code>sh:flags</code></td>
							<td>An optional string of flags, interpreted as in <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL 1.1 REGEX</a></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:pattern</code> must be literals with datatype <code>xsd:string</code> that are
							valid pattern arguments for the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>.
							A <a>validation result</a> must be produced for each <a>value node</a> that is a <a>blank node</a> or
							where the string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							does not match the given regular expression (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>).
							If <code>sh:flags</code> is present then this must be a literal with datatype <code>xsd:string</code> that is interpreted according to the third argument of the SPARQL REGEX function. 
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER (!isBlank($value) &amp;&amp; IF(bound($flags), regex(str($value), $pattern, $flags), regex(str($value), $pattern)))
}</pre>
					</div>
					<pre class="example-shapes">
ex:PatternExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob, ex:Alice, ex:Carol ;
	sh:property [
		sh:predicate ex:bCode ;
		sh:pattern "^B" ;    # starts with 'B'
		sh:flags "i" ;       # Ignore case
	] .</pre>
					<pre class="example-data">
ex:Bob ex:bCode "b101" .
ex:Alice ex:bCode "B102" .
<span class="focus-node-error">ex:Carol</span> ex:bCode "C103" .</pre>
				</section>
				
				<section id="StemConstraintComponent">
					<h4>sh:stem</h4>
					<p>
						The property <code>sh:stem</code> can be used to verify that every <a>value node</a> in an IRIs and the IRI starts with a given string value.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:StemConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:stem</code></td>
							<td>String value that an IRI must start with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:stem</code> must be literals with datatype <code>xsd:string</code>.
							A <a>validation result</a> must be produced for each <a>value node</a>
							that is not an <a>IRI</a> or the <a href="https://www.w3.org/TR/sparql11-query/#func-str">string representation</a> of the <a>IRI</a> does not <a href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#func-strstarts">start with</a> the given string.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER (isIRI($value) &amp;&amp; STRSTARTS(str($value), $stem))
}</pre>
					</div>
					<pre class="example-shapes">
ex:StemExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob, ex:Alice, ex:Carol ;
	sh:property [
		sh:predicate ex:w3cHomepage ;
		sh:stem "https://www.w3.org/People/" ;
	] .</pre>
					<pre class="example-data">
ex:Alice ex:w3cHomepage &lt;https://www.w3.org/People/Alice&gt; .
<span class="focus-node-error">ex:Bob</span> ex:w3cHomepage &lt;https://example.com/People/Bob&gt; .
<span class="focus-node-error">ex:Carol</span> ex:w3cHomepage "https://www.w3.org/People/Carol" .</pre>
				</section>
				
				<section id="LanguageInConstraintComponent">
					<h4>sh:languageIn</h4>
					<p>
						The property <code>sh:languageIn</code> can be used to enumerate language tags that all <a>value nodes</a> must have.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:LanguageInConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:languageIn</code></td>
							<td>An <a>RDF list</a> of language ranges</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:languageIn</code> must be <a>RDF lists</a>.
							The <a>members</a> of these lists must be literals with datatype <code>xsd:string</code>.
							A <a>validation result</a> must be produced for each <a>value node</a>
							that is either not a <a>literal</a> or that does not have a language tag
							matching any of the provided language ranges following the filtering schema defined by
							the <a href="https://www.w3.org/TR/sparql11-query/#func-langMatches">SPARQL langMatches</a> function.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	BIND (lang($value) AS ?valueLang) .
	FILTER (bound(?valueLang) &amp;&amp; EXISTS {
			GRAPH $shapesGraph {
				$languageIn (rdf:rest*)/rdf:first ?lang .
				FILTER (langMatches(?valueLang, ?lang))
			} 
		} )
}</pre>
					</div>
					<p>
						The following example shape states that all values of <code>ex:prefLabel</code>
						must be either in English or Māori.
					</p>
					<pre class="example-shapes">
ex:NewZealandLanguagesShape
	a sh:Shape ;
	sh:targetNode ex:Mountain, ex:Berg ;
	sh:property [
		sh:predicate ex:prefLabel ;
		sh:languageIn ( "en" "mi" ) ;
	] .</pre>
					<p>
						From the example instances, <code>ex:Berg</code> will lead to constraint violations for all
						of its labels.
					</p>
					<pre class="example-data">
ex:Mountain
	ex:prefLabel "Mountain"@en ;
	ex:prefLabel "Hill"@en-NZ ;
	ex:prefLabel "Maunga"@mi .

<span class="focus-node-error">ex:Berg</span>
	ex:prefLabel "Berg" ;
	ex:prefLabel "Berg"@de ;
	ex:prefLabel ex:BergLabel .</pre>
				</section>
				
				<section id="UniqueLangConstraintComponent">
					<h4>sh:uniqueLang</h4>
					<p>
						The property <code>sh:uniqueLang</code> can be set to <code>true</code> to specify that no pair of <a>value nodes</a> may use the same language tag.
						The values of <code>sh:uniqueLang</code> must be <code>xsd:boolean</code>s.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:UniqueLangConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:uniqueLang</code></td>
							<td><code>true</code> to activate this constraint</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:uniqueLang</code> must be literals with datatype <code>xsd:boolean</code>.
							If <code>sh:uniqueLang</code> is set to <code>true</code> then a <a>validation result</a> must be produced for each non-empty language tag that is
							used by at least two <a>value nodes</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT DISTINCT $this ?lang
WHERE {
	{
		FILTER ($uniqueLang) .
	}
	$this $PATH ?value .
	BIND (lang(?value) AS ?lang) .
	FILTER (bound(?lang) &amp;&amp; ?lang != "") . 
	FILTER EXISTS {
		$this $PATH ?otherValue .
		FILTER (?otherValue != ?value &amp;&amp; ?lang = lang(?otherValue)) .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:UniqueLangExampleShape
	a sh:Shape ;
	sh:targetNode ex:Alice, ex:Bob ;
	sh:property [
		sh:predicate ex:label ;
		sh:uniqueLang true ;
	] .</pre>

					<pre class="example-data">
ex:Alice
	ex:label "Alice" ;
	ex:label "Alice"@en ;
	ex:label "Alice"@fr .

<span class="focus-node-error">ex:Bob</span>
	ex:label "Bob"@en ;
	ex:label "Bobby"@en .</pre>
				</section>
			</section>
			
			<section id="constraints-property-pairs">
				<h3>Property Pair Constraint Components</h3>
				<p>
					The constraint components in this section restrict the sets of <a>value nodes</a> in relation to other properties.
					<a>Value nodes</a> of focus node constraints are always defined as a set of size 1
					and may produce unexpected results when used with constraint components of this category.
				</p>
				
				<section id="EqualsConstraintComponent">
					<h3>sh:equals</h3>
					<p>
						<code>sh:equals</code> can be used to verify that the set of <a>value nodes</a> is equal to the set of nodes that have the focus node as subject and the value of <code>sh:equals</code> as predicate.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:EqualsConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:equals</code></td>
							<td>Property to compare with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:equals</code> must be <a>IRIs</a>.
							A <a>validation result</a> must be produced
							for each <a>value node</a> that does not exist as <a>value</a> at the focus node of the property specified using <code>sh:equals</code> and
							for each <a>value</a> of the property specified using <code>sh:equals</code> that does not exist as <a>value node</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT DISTINCT $this ?value
WHERE {
	{
		$this $PATH ?value .
		MINUS {
			$this $equals ?value .
		}
	}
	UNION
	{
		$this $equals ?value .
		MINUS {
			$this $PATH ?value .
		}
	}
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:equals</code> in a shape to verify
						that certain nodes must have the same set of values for <code>ex:firstName</code> and <code>ex:givenName</code>.
					</p>
					<pre class="example-shapes">
ex:EqualExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob ;
	sh:property [
		sh:predicate ex:firstName ;
		sh:equals ex:givenName ;
	] .</pre>
					<pre class="example-data">
ex:Bob
	ex:firstName "Bob" ;
	ex:givenName "Bob" .</pre>
				</section>
				
				<section id="DisjointConstraintComponent">
					<h3>sh:disjoint</h3>
					<p>
						<code>sh:disjoint</code> can be used to verify that the set of <a>value nodes</a> is disjoint with the the set of nodes that have the focus node as subject and the value of <code>sh:equals</code> as predicate.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:DisjointConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:disjoint</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:disjoint</code> must be <a>IRIs</a>.
							A <a>validation result</a> must be produced for each <a>value node</a>
							that also exists as <a>value</a> of the property specified using <code>sh:disjoint</code> at the given <a>focus node</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT DISTINCT $this ?value
WHERE {
	$this $PATH ?value .
	$this $disjoint ?value .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:disjoint</code> in a shape to verify
						that certain nodes must not share any values for <code>ex:prefLabel</code> and <code>ex:altLabel</code>.
					</p>
					<pre class="example-shapes">
ex:DisjointExampleShape
	a sh:Shape ;
	sh:targetNode ex:USA, ex:Germany ;
	sh:property [
		sh:predicate ex:prefLabel ;
		sh:disjoint ex:altLabel ;
	] .</pre>
					<pre class="example-data">
ex:USA
	ex:prefLabel "USA" ;
	ex:altLabel "United States" .

<span class="focus-node-error">ex:Germany</span>
	ex:prefLabel "Germany" ;
	ex:altLabel "Germany" .</pre>
				</section>
				
				<section id="LessThanConstraintComponent">
					<h3>sh:lessThan</h3>
					<p>
						<code>sh:lessThan</code> can be used to verify that every <a>value node</a> is smaller than all the nodes that have the focus node as subject and the value of <code>sh:lessThan</code> as predicate.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:LessThanConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:lessThan</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:lessThan</code> must be <a>IRIs</a>.
							A <a>validation result</a> must be produced for each pair of <a>value nodes</a> and
							the values of the property specified using <code>sh:lessThan</code> at the given <a>focus node</a>, where
							the first <a>value</a> is not less than the second <a>value</a>, based on SPARQL's <code>&lt;</code> operator.
							A validation result must also be produced if the two <a>values</a> cannot be compared.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT DISTINCT $this ?value
WHERE {
	$this $PATH ?value .
	$this $lessThan ?otherValue .
	FILTER (!(?value &lt; ?otherValue)) .
}</pre>
					</div>
					<p class="todo">TODO: Decide what should happen if values are not comparable, i.e. &lt; fails, similar to minExclusive etc.</p>
					<p>
						The following example illustrates the use of <code>sh:lessThan</code> in a shape to verify
						that all values of <code>ex:startDate</code> must be "before" the values of <code>ex:endDate</code>.
					</p>
					<pre class="example-shapes">
ex:LessThanExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:startDate ;
		sh:lessThan ex:endDate ;
	] .</pre>
				</section>
				
				<section id="LessThanOrEqualsConstraintComponent">
					<h3>sh:lessThanOrEquals</h3>
					<p>
						<code>sh:lessThanOrEquals</code> can be used to verify that every <a>value node</a> is smaller than or equal to all the nodes that have the focus node as subject and the value of <code>sh:lessThanOrEquals</code> as predicate.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:LessThanOrEqualsConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:lessThanOrEquals</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:lessThanOrEquals</code> must be <a>IRIs</a>.
							A <a>validation result</a> must be produced for each pair of <a>value nodes</a> and
							the values of the property specified using <code>sh:lessThanOrEquals</code> at the given <a>focus node</a>, where
							the first <a>value</a> is not less than or equal to the second <a>value</a>, based on SPARQL's <code>&lt;=</code> operator.
							A validation result must also be produced if the two <a>values</a> cannot be compared.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT DISTINCT $this ?value
WHERE {
	$this $PATH ?value .
	$this $lessThan ?otherValue .
	FILTER (!(?value &lt;= ?otherValue)) .
}</pre>
					</div>
				</section>
			</section>				
	
			<section id="constraints-logical">
				<h3>Logical Constraint Components</h3>
				<p>
					The constraint components in this section implement the common logical operators <span class="term">and</span>,
					<span class="term">or</span> and <span class="term">not</span>.
				</p>
				<section id="NotConstraintComponent">
					<h3>sh:not</h3>
					<p>
						SHACL supports a negation constraint component that can be used to verify that a <a>value node</a> does not validate against a <a>shape</a>.
						This is comparable to a logical "not" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:NotConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:not</code></td>
							<td>The shape to negate</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:not</code> must be <a>IRIs</a> or <a>blank nodes</a>.
							The <a>expected type</a> of these nodes is <code>sh:Shape</code>.
							A <a>validation result</a> must be produced for each <a>value node</a> that produces no validation results for the shape given via <code>sh:not</code>.
							A <a>failure</a> must be reported if the validation of the shape produces a <a>failure</a>.
						</div>
					</div>
					<p>
						The following example illustrates the use of <code>sh:not</code> in a shape to verify
						that certain nodes cannot have any value of <code>ex:property</code>.
					</p>
					<pre class="example-shapes">
ex:NotExampleShape
	a sh:Shape ;
	sh:targetNode ex:InvalidInstance1 ;
	sh:not [
		a sh:Shape ;
		sh:property [
			sh:predicate ex:property ;
			sh:minCount 1 ;
		] ;
	] .</pre>
					<pre class="example-data">
<span class="focus-node-error">ex:InvalidInstance1</span> ex:property "Some value" .</pre>
				</section>
				
				<section id="AndConstraintComponent">
					<h3>sh:and</h3>
					<p>
						SHACL supports a conjunctive constraint component that can be used to test whether a <a>value node</a> validates against all provided shapes.
						This is comparable to a logical "and" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:AndConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:and</code></td>
							<td><a>RDF list</a> of shapes to validate the value nodes against</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:and</code> must be <a>RDF lists</a> where the <a>members</a> must be <a>IRIs</a> or <a>blank nodes</a>.
							The <a>expected type</a> of these members is <code>sh:Shape</code>.
							A <a>validation result</a> must be produced for each <a>value node</a> if the following condition is false:
							The validation of the <a>value node</a> against all of the <a>members</a> of the <a>RDF list</a> that is the value of <code>sh:and</code> produces a <a>validation result</a> for at least one <a>member</a>.
							A <a>failure</a> must be produced if the validation of one of the <a>members</a> produces a <a>failure</a>.
						</div>
					</div>
					<p>
						Note that although <code>sh:and</code> has an <code>rdf:List</code> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:and</code> in a shape to verify
						that certain nodes have exactly one value of <code>ex:property</code>.
						This is achieved via the conjunction of a separate named shape (<code>ex:SuperShape</code>) which defines
						the minimum count, and a blank node shape that additionally defines the maximum count.
						As shown here, <code>sh:and</code> can be used to implement a specialization mechanism between shapes.
					</p>
					<pre class="example-shapes">
ex:SuperShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:minCount 1 ;
	] .

ex:ExampleAndShape
	a sh:Shape ;
	sh:targetNode ex:ValidInstance, ex:InvalidInstance ;
	sh:and (
		ex:SuperShape
		[
			a sh:Shape ;
			sh:property [
				sh:predicate ex:property ;
				sh:maxCount 1 ;
			]
		]
	) .</pre>

<pre class="example-data">
ex:ValidInstance
	ex:property "One" .

# Invalid: more than one property
<span class="focus-node-error">ex:InvalidInstance</span>
	ex:property "One" ;
	ex:property "Two" .</pre>
				</section>
				
				<section id="OrConstraintComponent">
					<h3>sh:or</h3>
					<p>
						SHACL supports a high-level syntax for disjunctive constraints that can be used to test whether a <a>value node</a> validates against at least one out of several provided shapes.
						This is comparable to a logical "or" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:OrConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:or</code></td>
							<td><a>RDF list</a> of shapes to validate the value nodes against</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:or</code> must be <a>RDF lists</a> where the <a>members</a> must be <a>IRIs</a> or <a>blank nodes</a>.
							The <a>expected type</a> of these members is <code>sh:Shape</code>.
							A <a>validation result</a> must be produced for each <a>value node</a> if the following condition is false:
							The validation of the <a>value node</a> against all of the <a>members</a> in the <a>RDF list</a> that is the value of <code>sh:or</code> produces no <a>validation results</a> for at least one <a>member</a>.
							A <a>failure</a> must be produced if the <a>validation</a> of one of the <a>members</a> produces a <a>failure</a>.
						</div>
					</div>
					<p>
						Note that although <code>sh:or</code> has an <code>rdf:List</code> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:or</code> in a shape to verify
						that certain nodes have at least one value of <code>ex:firstName</code>
						or at least one value of <code>ex:givenName</code>.
					</p>
					<pre class="example-shapes">
ex:OrConstraintExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob ;
	sh:or (
		[
			sh:property [
				sh:predicate ex:firstName ;
				sh:minCount 1 ;
			]
		]
		[
			sh:property [
				sh:predicate ex:givenName ;
				sh:minCount 1 ;
			]
		]
	) .</pre>
					<pre class="example-data">
ex:Bob ex:firstName "Robert" .</pre>
					<p>
						The next example shows how <code>sh:or</code> can be used in a <a>property constraint</a> to state that the values of
						the given property <code>ex:address</code> may be either literals with datatype <code>xsd:string</code>
						or <a>SHACL instances</a> of the class <code>ex:Address</code>.
					</p>
					<pre class="example-shapes">
ex:PersonAddressShape
	a sh:Shape ;
	sh:targetClass ex:Person ;
	sh:property [
		sh:predicate ex:address ;
		sh:or (
			[
				sh:datatype xsd:string ;
			]
			[
				sh:class ex:Address ;
			]
		)
	] .</pre>
					<pre class="example-data">
ex:Bob ex:address "123 Prinzengasse, Vaduz, Liechtenstein" .</pre>
				</section>
			</section>
	
			<section id="constraints-shape">
				<h3>Shape-based Constraint Components</h3>
				<p>
					The constraint components in this section can be used to represent complex restrictions
					based on applying shape definitions on value nodes. 
				</p>
				
				<section id="ShapeConstraintComponent">
					<h4>sh:shape</h4>
					<p>
						<code>sh:shape</code> can be used verify that all <a>value nodes</a> validate against the given shape.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:ShapeConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:shape</code></td>
							<td>All value nodes must validate against the given shape</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:shape</code> must be <a>IRIs</a> or <a>blank nodes</a>.
							The <a>expected type</a> of these values is <code>sh:Shape</code>.
							A <a>validation result</a> must be produced for each <a>value node</a>
							where validating the value node against the shape specified by <code>sh:shape</code> 
							produces any validation results.
							A <a>failure</a> must be produced if the validation of any <a>value node</a> has produced a <a>failure</a>.
						</div>
					</div>
					<p>
						In the following example, all values of the property <code>ex:someProperty</code> will validate with no results for the shape
						specified by a blank node that ensures that the property <code>ex:nestedProperty</code> has at least one value.
					</p>
					<pre class="example-shapes">
ex:ShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:shape [
			a sh:Shape ;   # Optional
			sh:property [
				sh:predicate ex:nestedProperty ;
				sh:minCount 1 ;
			]
		]
	] .</pre>

					<pre class="example-data">
ex:ShapeExampleValidResource
	ex:someProperty [
		ex:nestedProperty 42 ;
	] .</pre>
				</section>
				
				<section id="QualifiedValueShapeConstraintComponent">
					<h4>sh:qualifiedValueShape, sh:qualifiedMinCount, sh:qualifiedMaxCount</h4>
					<div class="issue" data-number="92" title="Relationship of QCRs with Partitions">
						Feature at risk:
						There is an ongoing proposal (see sh:partition) that strongly overlaps with the QCRs proposed here.
						The WG may decide to support only one of these options, but not both.
					</div>
					<p>
						The property <code>sh:qualifiedValueShape</code> can be used verify that a specified number of <a>value nodes</a> validate against the given shape.
						For each <code>sh:qualifiedValueShape</code> there must be either one <code>sh:qualifiedMinCount</code> or one <code>sh:qualifiedMaxCount</code>, or one of each, at the same <a>subject</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:QualifiedValueShapeConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:qualifiedValueShape</code></td>
							<td>A specified number of value nodes must validate against the given shape</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMinCount</code></td>
							<td>The minimum number of value nodes that can validate against the shape. If this constraint is omitted then there is no minimum number of values required.</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMaxCount</code></td>
							<td>The maximum number of value nodes that can validate against the shape. If this constraint is omitted then there is no maximum number of values required.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMinCount</div>
						<div class="def-text-body">
							The values of <code>sh:qualifiedValueShape</code> must be <a>IRIs</a> or <a>blank nodes</a>.
							The <a>expected type</a> of these values is <code>sh:Shape</code>.
							The values of <code>sh:qualifiedMinCount</code> must be literals with datatype <code>xsd:integer</code>.
							Let <code>C</code> be the number of <a>value nodes</a> where
							validating the node against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no <a>validation results</a>.
							A <a>failure</a> must be produced if the validation of any of the value nodes produces a <a>failure</a>.
							A <a>validation result</a> must be produced if <code>C</code>
							is less than the specified <code>sh:qualifiedMinCount</code>.
						</div>
					</div>

					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMaxCount</div>
						<div class="def-text-body">
							The values of <code>sh:qualifiedMaxCount</code> must be literals with datatype <code>xsd:integer</code>.
							Let <code>C</code> be the number of <a>value nodes</a> where
							validating the node against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no <a>validation results</a>.
							A <a>failure</a> must be produced if the validation of any of the <a>value nodes</a> produces a <a>failure</a>.
							A <a>validation result</a> must be produced if <code>C</code>
							is greater than the specified <code>sh:qualifiedMaxCount</code>.
						</div>
					</div>

					<p>
						In the following example, the property <code>ex:parent</code> must have exactly two values,
						and at least one of them needs to be female.
					</p>
					<pre class="example-shapes">
ex:QualifiedValueShapeExampleShape
	a sh:Shape ;
	sh:targetNode ex:QualifiedValueShapeExampleValidResource ;
	sh:property [
		sh:predicate ex:parent ;
		sh:minCount 2 ;
		sh:maxCount 2 ;
		sh:qualifiedValueShape [
			a sh:Shape ;   # Optional
			sh:property [
				sh:predicate ex:gender ;
				sh:hasValue ex:female ;
			]
		] ;
		sh:qualifiedMinCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:QualifiedValueShapeExampleValidResource
	ex:parent ex:John ;
	ex:parent ex:Jane .

ex:John
	ex:gender ex:male .

ex:Jane
	ex:gender ex:female .</pre>
				</section>
				
				<section id="PartitionConstraintComponent">
					<h4>sh:partition</h4>
					<p>
						In some cases a given property may be multi-valued and it may be required that the set of values
						be partitioned into two or more subsets, each of which satisfies certain constraints.
					</p>
					<p>
						For example, suppose that in the Library of Congress BIBFRAME (<code>bf:</code>) Cultural Heritage vocabulary each person (<code>bf:Person</code>) must be identified by 
						(<code>bf:identifiedBy</code>) exactly one identifier from <code>id.loc.gov</code> and may have another identifier
						from <code>viaf.org</code>. No other identifiers are allowed. Thus the set of all identifiers is partitioned into
						two subsets, the first of which contains exactly one member and the second of which contains zero or one members.
						The following example shows a snippet of some valid BIBFRAME data.
					</p>
					<pre class="example-data" title="Valid BIBFRAME Data">&lt;bf_Person1>
  	bf:identifiedBy &lt;http://id.loc.gov/authorities/names/n80103961#RWO> ;
 	bf:identifiedBy &lt;https://viaf.org/viaf/268367832/#Knape,_Joachim> .</pre>
					<p>
						The following example shows a snippet of some invalid BIBFRAME data.
					</p>
					<pre class="example-data" title="Invalid BIBFRAME Data">&lt;bf_Person1>
  	bf:identifiedBy &lt;http://id.loc.gov/authorities/names/n80103961#RWO> ;
 	bf:identifiedBy &lt;https://viaf.org/viaf/268367832/#Knape,_Joachim> ;
	bf:identifiedBy "this is a mistake" . # should be an error</pre>
					<p>
						Qualified cardinality constraints provide a basis for expressing this type of partitioning requirement, but using them imposes a burden on the shapes author. In the BIBFRAME example the author would need to express the requirement that the set of all identifiers that are from neither <code>id.loc.gov</code> nor <code>viaf.org</code> is empty, i.e. it has a maximum cardinality of 0. Clearly, as more subsets of values are involved, the burden on the author increases.
						The <code>sh:partition</code> constraint makes it easier to express this type of requirement than it would be to use 
						multiple qualified cardinality constraints.
						In effect, <code>sh:partition</code> chains together a sequence of qualified cardinality constraints and removes the set of value nodes matched by each from further consideration. If every value node gets matched in this process, then
						the <code>sh:partition</code> constraint reports no violations. Otherwise, any value nodes remaining are reported as
						violations of the constraint.
						The BIBFRAME example constraint is expressed as follows.
					</p>
					<pre class="example-shapes" title="BIBFRAME constraint expressed using sh:partition">
ex:BibframeShape a sh:Shape ;
	sh:property [
		sh:predicate bf:identifiedBy ;
		sh:partition (
			[sh:minCount 1; sh:maxCount 1; sh:pattern "^http://id.loc.gov/"]
			[sh:maxCount 1; sh:pattern "^https://viaf.org/"]
		)
] .</pre>
					<p>
						The value of the <code>sh:partition</code> constraint parameter MUST be an <a>RDF list</a> that has zero or more <a>members</a>.
						Each <a>member</a> of the list defines conditions on a subset of the value nodes and may contain the following parameters:
					</p>
					<ul>
						<li>zero or one <code>sh:minCount</code>. This defines the minimum cardinality of the corresponding subset.</li>
						<li>zero or one <code>sh:maxCount</code>. This defines the maximum cardinality of the corresponding subset.</li>
						<li>any combination of parameters associated with node validation constraints. A node validation constraint
							is any constraint defined by a boolean function on nodes. 
							These include the built-in constraints defined by <code>sh:nodeKind</code>, <code>sh:partition</code>,
							<code>sh:minExclusive</code>, etc.
							The corresponding subset consists of those remaining nodes for which the boolean function is <code>true</code>.</li>
					</ul>
					<p>
						Note that a node that contains no parameters matches all nodes. Such a node is useful as the last <a>member</a> of the list where it acts as a default matching rule in the case where nodes that do not match any of the preceeding constraints are allowed. 
						Note also that a qualified cardinality constraint defined using <code>sh:qualifiedValueShape</code>,
						<code>sh:qualifiedMinCount</code>, and <code>sh:qualifiedMaxCount</code> is equivalent to a <code>sh:partition</code> constraint that contains two nodes with the first one containing the corresponding parameters and the last one being the default matching rule that matches any set of nodes.
					</p>
					<p>
						Each <a>member</a> of the list is used by the SHACL processor to match a subset of the value nodes.
						The SHACL processor matches as many nodes as possible and then compares the result with the specified
						minimum and maximum cardinalities if specified. This is referred to as a <em>greedy</em> matching algorithm.
						Greedy pattern matching is commonly used with textual regular expressions.
						Nodes that match are removed from further matching. Thus the set of all value nodes becomes partitioned by 
						the matching algorithm. The following paragraphs define this algorithm more precisely.
					</p>
					<p>
						Let D be a data graph and let F be a focus node in D. Let S be a shapes graph, let T be a shape in S, 
						and let C be a <code>sh:partition</code> constraint in T. 
						Let N be the set of value nodes for C in D at F. Recall that N depends on how C is related to T. 
					</p>
					<ul>
						<li>If (T, <code>sh:constraint</code>, C) is in S then N consists of just the node F.</li>
						<li>If (T, <code>sh:property</code>, C) and (C, <code>sh:predicate</code>, P) are in S 
							then N consists of all the nodes X such that (F, P, X) is in D.</li>
					</ul>
					<p>
						Let the value of the <code>sh:partition</code> parameter be the <a>RDF list</a> with <a>members</a> (Q<sub>1</sub>, ..., Q<sub>n</sub>).
						The SHACL processor MUST perform the following steps to validate the constraint C at F.
					</p>
					<ol>
						<li>Let R denote the set of remaining value nodes. Initialize R to N.</li>
						<li>Repeat the following for Q = Q<sub>1</sub>, ..., Q<sub>n</sub>
						<ol>
							<li>Let P be the conjunction of all the node validation constraints in Q.</li>
							<li>Compute R' to be the set of all nodes in R that satisfy P, i.e. R' = {X in R | P(X) = true}</li>
							<li>If Q contains a minimum cardinality m<sub>min</sub> and the number of nodes in R' is less than m<sub>min</sub>,
							i.e. m<sub>min</sub> > #R', then report a constraint violation and exit the loop.</li>
							<li>If Q contains a maximum cardinality m<sub>max</sub> and the number of nodes in R' is greater then m<sub>max</sub>,
							i.e. m<sub>max</sub> &lt; #R', then report a constraint violation and exit the loop.</li>
							<li>Remove R' from R, i.e. set R = R \ R'.</li>
						</ol>
						</li>
						<li>If R is non-empty and no violations have been reported yet then report a violation.</li>
					</ol>
					<p>
						Note that the order of nodes within the RDF list is significant.
						<span class="TODO">TODO: This currently violates our definition of rdf:List members.</span> 
						In general, if the members of the RDF list are reordered then different value node sets will be matched
						and different violation results will be reported.
					</p>
				</section>
			</section>
			
			<section id="constraints-others">
				<h3>Other Constraint Components</h3>
				<p>
					This section enumerates Core constraint components that did not fit into the other categories.
				</p>
				
				<section id="ClosedConstraintComponent">
					<h3>sh:closed, sh:ignoredProperties</h3>
					<p>
						The RDF data model offers a huge amount of flexibility.
						Any node can in principle have values for any property.
						However, in some cases it makes sense to restrict which properties can be applied to nodes.
						The SHACL Core language includes a property called <code>sh:closed</code> that can be assigned to
						a shape via the property <code>sh:constraint</code> to indicate that valid nodes must only have
						values for those properties that have been explicitly declared via <code>sh:property</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:ClosedConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:closed</code></td>
							<td>Set to <code>true</code> to close the shape</td>
						</tr>
						<tr>
							<td><code>sh:ignoredProperties</code></td>
							<td>Optional <a>RDF list</a> of properties that are also permitted in addition to those explicitly enumerated via <code>sh:property</code></td>
						</tr>
					</table>
					<div id="def-ClosedShape-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:closed</code> must be literals with datatype <code>xsd:boolean</code>.
							If <code>sh:closed</code> is <code>true</code> then
							a <a>validation result</a> must be produced for each <a>triple</a> that has the <a>focus node</a> as its
							<a>subject</a> and a <a>predicate</a> that is not explicitly enumerated as a <code>sh:predicate</code>
							in any of the <code>sh:property</code> constraints at the surrounding shape.
							If the parameter <code>sh:ignoredProperties</code> is present then its values must be <a>RDF lists</a>
							where all <a>members</a> are <a>IRIs</a>, and the properties enumerated in this <a>RDF list</a> are also permitted for the <a>subject</a>.
							The produced <a>validation result</a> must have the predicate of the triple as its <code>sh:path</code>,
							and the object of the triple as its <code>sh:value</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results)</div>
<pre class="def-sparql-body">
SELECT $this (?predicate AS ?path) ?value
WHERE {
	{
		FILTER ($closed) .
	}
	$this ?predicate ?value .
	FILTER (NOT EXISTS {
		GRAPH $shapesGraph {
			$currentShape sh:property/sh:predicate ?predicate .
		}
	} &amp;&amp; (!bound($ignoredProperties) || NOT EXISTS {
		GRAPH $shapesGraph {
			$ignoredProperties rdf:rest*/rdf:first ?predicate .
		}
	}))
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:closed</code> in a shape to verify
						that certain nodes only have values for <code>ex:exampleProperty1</code> and <code>ex:exampleProperty2</code>.
						The "ignored" property <code>rdf:type</code> would also be allowed.
					</p>
					<pre class="example-shapes">
ex:ClosedShapeExampleShape
	a sh:Shape ;
	sh:targetNode ex:Alice, ex:Bob ;
	sh:closed true ;
	sh:ignoredProperties (rdf:type) ;
	sh:property [
		sh:predicate ex:firstName ;
	] ;
	sh:property [
		sh:predicate ex:lastName ;
	] .</pre>

					<pre class="example-data">
ex:Alice
	ex:firstName "Alice" .

<span class="focus-node-error">ex:Bob</span>
	ex:firstName "Bob" ;
	ex:middleInitial "J" .</pre>
				</section>
				
				<section id="HasValueConstraintComponent">
					<h4>sh:hasValue</h4>
					<p>
						The property <code>sh:hasValue</code> can be used to verify that one of the <a>value nodes</a> is a given RDF node.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:HasValueConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:hasValue</code></td>
							<td>A specific required value</td>
						</tr>
					</table>
					<div id="def-hasValue-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced if the node specified by <code>sh:hasValue</code> is not among the <a>value nodes</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this
WHERE {
	FILTER NOT EXISTS { $this $PATH $hasValue }
}</pre>
					</div>
					<pre class="example-shapes">
ex:StanfordGraduate
	a sh:Shape ;
	sh:targetNode ex:Alice ;
	sh:property [
		sh:predicate ex:alumniOf ;
		sh:hasValue ex:Stanford ;
	] .</pre>

					<pre class="example-data">
ex:Alice
	ex:alumniOf ex:Harvard ;
	ex:alumniOf ex:Stanford .</pre>
				</section>
				
				<section id="InConstraintComponent">
					<h4>sh:in</h4>
					<p>
						The property <code>sh:in</code> exclusively enumerates the permitted <a>value nodes</a>.
						For example when specified as part of a <a>property constraint</a>, then each <a>value</a> of the given property must be a <a>member</a> of the specified <a>RDF list</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component IRI</span>: <code>sh:InConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:in</code></td>
							<td><a>RDF list</a> that has the allowed values as <a>members</a></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:in</code> must be <a>RDF lists</a>.
							The <a>members</a> of those RDF lists must be <a>literals</a> or <a>IRIs</a>.
							A <a>validation result</a> must be produced for every <a>value node</a>
							that is not a member of the given RDF list.
							Matching of literals needs to be exact, e.g. <code>"04"^^xsd:byte</code> does not match <code>"4"^^xsd:integer</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	GRAPH $shapesGraph {
		$in (rdf:rest*)/rdf:first $value .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:InExampleShape
	a sh:Shape ;
	sh:targetNode ex:RainbowPony ;
	sh:property [
		sh:predicate ex:color ;
		sh:in ( ex:Pink ex:Purple ) ;
	] .</pre>

					<pre class="example-data">
ex:RainbowPony ex:color ex:Pink .</pre>
				</section>
			</section>
				
			<section id="nonValidation">
				<h4>Non-Validating Constraint Characteristics</h4>
				<p>
					While the previous sections introduced properties that represent validation conditions,
					this section covers properties that are ignored by SHACL processors.
					The use of these properties is entirely optional and not subject to formal interpretation contracts.
					They may be used for purposes such as form building or predictable printing of RDF files.
				</p>
				<p id="name">
					Property constraints may have one or more <a>values</a> for <code>sh:name</code> to provide human-readable labels for the property in the target where it appears.
					If present, tools SHOULD prefer those locally defined labels over globally defined labels at the <code>rdf:Property</code> itself.
					For example, if a form displays a node that is in the target of a given shape, and the shape defines a <code>sh:property</code> constraint with an <code>sh:name</code>, then the tool SHOULD use the provided name.
					Similarly, property constraints may have an <code id="description">sh:description</code> to provide a description of the property in the given context.
					Both <code>sh:name</code> and <code>sh:description</code> may have multiple <a>values</a>, but SHOULD only have one <a>value</a> per language tag.
				</p>
				<p id="order">
					Property constraints may have one <a>value</a> for the property <code>sh:order</code> to indicate the relative order of the property constraint for purposes such as form building.
					The values of <code>sh:order</code> must be decimals.
					<code>sh:order</code> is not used for validation purposes.
					If present, the recommended use of <code>sh:order</code> is to sort the property constraints in an ascending order, for example so that
					properties with smaller order are placed above (or to the left) of properties with larger order.
				</p>
				<p id="group">
					Property constraints may link to an <a>SHACL instance</a> of the class <code>sh:PropertyGroup</code> using the property <code>sh:group</code> to indicate that
					the constraint belongs to a group of related property constraints.
					Each group may have additional triples that serve application purposes, such as an <code>rdfs:label</code> for form building.
					Groups may also have an <code>sh:order</code> property to indicate the relative ordering of groups within the same form.
				</p>
				<p id="defaultValue">
					Property constraints may have a single value for <code>sh:defaultValue</code>.
					The default value does not have fixed semantics in SHACL, but MAY be used by user interface tools to pre-populate input widgets.
					The value type of the <code>sh:defaultValue</code> SHOULD align with the specified <code>sh:datatype</code> or <code>sh:class</code> of the same constraint.
				</p>
				<p>
					The following example illustrates the use of these various features together.
				</p>
				<pre class="example-shapes">
ex:PersonFormShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:firstName ;
		sh:name "first name" ;
		sh:description "The person's given name(s)" ;
		sh:order 0 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:predicate ex:lastName ;
		sh:name "last name" ;
		sh:description "The person's last name" ;
		sh:order 1 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:predicate ex:streetAddress ;
		sh:name "street address" ;
		sh:description "The street address including number" ;
		sh:order 11 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:predicate ex:locality ;
		sh:name "locality" ;
		sh:description "The suburb, city or town of the address" ;
		sh:order 12 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:predicate ex:postalCode ;
		sh:name "postal code" ;
		sh:name "zip code"@en-US ;
		sh:description "The postal code of the locality" ;
		sh:order 13 ;
		sh:group ex:AddressGroup ;
	] .

ex:NameGroup
	a sh:PropertyGroup ;
	sh:order 0 ;
	rdfs:label "Name" .

ex:AddressGroup
	a sh:PropertyGroup ;
	sh:order 1 ;
	rdfs:label "Address" .</pre>
				<p>
					A form building application may use the information above to display information as follows:
				</p>
				<div style="background: #f3f3f3; padding: 8px">
					<div style="font-size: 18px; color: #0000a0"><b>Name</b></div>
					<table>
						<tr>
							<td style="text-align: right; width: 160px"><b>first name:</b></td>
							<td>John</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>last name:</b></td>
							<td>Doe</td>
						</tr>
					</table>
					<div style="font-size: 18px; padding-top: 6px; color: #0000a0"><b>Address</b></div>
					<table>
						<tr>
							<td style="text-align: right; width: 160px"><b>street address:</b></td>
							<td>123 Silverado Ave</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>locality:</b></td>
							<td>Cupertino</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>zip code:</b></td>
							<td>54321</td>
						</tr>
					</table>
				</div>
			</section>
		</section>

		<div style="padding-top: 30px">
			<h1 id="part2" style="font-size: 160%; font-weight: bold">Part 2: SHACL Full</h1>
			<p>
				Part 1 of this specification introduced features that are built into the Core of SHACL.
				The goal of this Core was to provide a high-level vocabulary for common use cases to describe shapes.
				However, SHACL also provides mechanisms to go beyond the Core vocabulary and represent constraints and targets with greater flexibility.
				These mechanisms, called <a>SHACL Full</a>, are described in the following sections.
			</p>
		</div>
		
		<section id="sparql-constraints">
			<h2>SPARQL-based Constraints</h2>
			<p>
				SHACL Full supports two mechanisms to define constraints using SPARQL:
			</p>
			<ul>
				<li>Constraints based on a high-level vocabulary (<a href="#constraint-components">constraint components</a>), relying on a reusable SPARQL query in the background</li>
				<li>Constraints directly based on a SPARQL query</li>
			</ul>
			<p>
				The following sub-sections are about the latter.
			</p>
			<section id="sparql-constraints-syntax">
				<h3>Syntax of SPARQL-based Constraints</h3>
				<p>
					Shapes may have values for the property <code>sh:sparql</code>, and these values must be <a>IRIs</a> or <a>blank nodes</a>.
					The values of <code>sh:sparql</code> have the <a>expected type</a> <code>sh:SPARQLConstraint</code> which is an <code>rdfs:subClassOf sh:Constraint</code>
					and is the class of all <dfn>SPARQL-based constraints</dfn>.
					SPARQL-based constraints must have exactly one <a>value</a> for the property <code>sh:select</code> and this value must be a <a>literal</a> with datatype <code>xsd:string</code>.
					As elaborated in the section on <a href="#sparql-prefixes">prefix handling rules</a>, the value of <code>sh:select</code> must be transformable into
					a SPARQL 1.1 SELECT query.
					The remainder of this section is not normative.
				</p>
				<p>
					The following example illustrates the definition of a SPARQL-based constraint.
				</p>
				<pre class="example-data">
ex:ValidCountry a ex:Country ;
	ex:germanLabel "Spanien"@de .
  
<span class="focus-node-error">ex:InvalidCountry</span> a ex:Country ;
	ex:germanLabel "Spain"@en .</pre>
				<pre class="example-shapes" id="example-sparql-constraint">
ex:LanguageExampleShape
	a sh:Shape ;
	sh:targetClass ex:Country ;
	sh:sparql [
		a sh:SPARQLConstraint ;   # This triple is optional
		sh:message "Values must be literals with German language tag." ;
		sh:prefixes ex: ;
		sh:select """
			SELECT $this (ex:germanLabel AS ?path) ?value
			WHERE {
				$this ex:germanLabel ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), "de"))
			}
			""" ;
	] .</pre>
				<p>
					The target of the shape above includes all <a>SHACL instances</a> of <code>ex:Country</code>.
					For those RDF nodes (represented by the variable <code>this</code>), the SPARQL query walks through the values of <code>ex:germanLabel</code>
					and verifies that they are literals with a German language code.
					The validation results for the aforementioned data graph is shown below:
				</p>
				<pre class="example-results">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:InvalidCountry ;
	sh:path ex:germanLabel ;
	sh:value "Spain"@en ;
	sh:sourceShape ex:LanguageExampleShape ;
	...
]
</pre>
				<p>
					The SPARQL query returns result set <a>solutions</a> for all bindings of <code>?value</code> that violate the constraint.
					A validation result is produced for each <a>solution</a> in that result set, following the <a href="#sparql-constraints-variables">mapping rules</a> explained later:
					Each validation result will have <code>$this</code> as the <code>sh:focusNode</code>,
					<code>ex:germanLabel</code> as <code>sh:path</code> and the violating value as <code>sh:value</code>.
				</p>
			</section>
			<section id="sparql-prefixes">
				<h4>Prefix Declarations for SPARQL Queries</h4>
				<p>
					A <a>shapes graph</a> may include declarations of namespace prefixes so that these prefixes can be used to abbreviate the SPARQL queries derived from the same shapes graph.
					The syntax of such prefix declarations is illustrated by the following example.
				</p>
				<pre class="example-shapes">
ex:
	a owl:Ontology ;
	owl:imports sh: ;
	sh:declare [
		sh:prefix "ex" ;
		sh:namespace "http://example.com/ns#"^^xsd:anyURI ;
	] ;
	sh:declare [
		sh:prefix "schema" ;
		sh:namespace "http://schema.org/"^^xsd:anyURI ;
	] .</pre>
				<p>
					The property <code>sh:declare</code> is used to make individual prefix declarations.
					The SHACL vocabulary defines the class <code>sh:PrefixDeclaration</code> for the values of <code>sh:declare</code>
					although no <code>rdf:type</code> triple is required for them.
					The values of <code>sh:declare</code> must have exactly one value for the property <code>sh:prefix</code> (<a>literals</a> of datatype <code>xsd:string</code>)
					and exactly one value for the property <code>sh:namespace</code> (<a>literals</a> of datatype <code>xsd:anyURI</code>).
					Such a pair of values defines a single mapping of a prefix to a namespace.
				</p>
				<p>
					The recommended <a>subject</a> for values of <code>sh:declare</code> is the IRI of the graph defining the shapes that use the prefixes.
					These IRIs are often declared as an instance of <code>owl:Ontology</code>, but this is not required.
				</p>
				<p>
					Prefix declarations can be used by SPARQL-based constraints and similar SPARQL-based features such as
					the validators of <a href="#constraint-components">constraint components</a>,
					<a href="#derivedValues">derived values constraints</a>,
					<a href="#sparql-targets">target types</a> and <a href="#functions">functions</a>.
					These nodes can use the property <code>sh:prefixes</code> to define a set of prefix mappings.
					(An example use of the <code>sh:prefixes</code> property can be found in the
					<a href="#example-sparql-constraint">example</a> above.)
					The values of <code>sh:prefixes</code> must be <a>IRIs</a> or <a>blank nodes</a>.
					A SHACL processor collects a set of prefix mappings as the union of all
					single prefix mappings that can be reached by the property path <code>sh:prefixes/owl:imports*/sh:declare</code> starting at the SPARQL-based constraint.
					If such a collection of prefix declarations contains multiple namespaces for the same <code>sh:prefix</code>,
					then the <a>shapes graph</a> is invalid.
					A SHACL processor transforms the values of <code>sh:select</code> (and similar properties such as <code>sh:ask</code>)
					into SPARQL by prepending <a href="https://www.w3.org/TR/sparql11-query/#rPrefixDecl"><code>PREFIX</code></a> declarations
					for all namespace prefix mappings.
					Each value of <code>sh:prefix</code> is turned into the <code>PNAME_NS</code>, while each value of <code>sh:namespace</code> is turned
					into the <code>IRIREF</code> in the <code>PREFIX</code> declaration.
					For the example shapes graph above, a SHACL Full processor would produce lines such as <code>PREFIX ex: &lt;http://example.com/ns#&gt;</code>.
					The SHACL Full processor must produce a <a>failure</a> if the resulting SPARQL query string cannot be parsed into a valid SPARQL 1.1 query.
					In the rest of this document, the <code>sh:prefixes</code> statements may have been omitted for brevity.
				</p>
			</section>
			<section id="sparql-constraints-prebound">
				<h4>Pre-bound Variables in SPARQL Constraints ($this, $shapesGraph, $currentShape)</h4>
				<p>
					The following table enumerates variables that have special meaning in SPARQL constraints.
					When SPARQL constraints are executed, the SHACL Full processor <a>pre-binds</a> values for these variables.
				</p>
				<table class="term-table">
					<tr>
						<th>Variable</th>
						<th>Interpretation</th>
					</tr>
					<tr>
						<td><code>$this</code></td>
						<td>
							The <a>focus node</a>.
						</td>
					</tr>
					<tr>
						<td><code style="white-space: nowrap">$shapesGraph</code></td>
						<td>
							Can be used to query the shapes graph as in <code>GRAPH $shapesGraph { ... }</code>.
							If the shapes graph is a named graph in the same dataset as the data graph then it is the IRI of the shapes graph in the dataset.
							Not all SHACL Full processors need to support this variable.
							Processors that do not support <code>$shapesGraph</code> MUST report a <a>failure</a> if they encounter a query that references this variable.
							Use of <code>GRAPH $shapesGraph { ... }</code> should be handled with extreme caution.
							It may result in constraints that are not interoperable across different SHACL Full processors and that may not run on remote RDF datasets.
						</td>
					</tr>
					<tr>
						<td><code style="white-space: nowrap">$currentShape</code></td>
						<td>
							The current shape.  Typically used in conjunction with <code>$shapesGraph</code>.
							The same support policies as for <code>$shapesGraph</code> apply for this variable.
						</td>
					</tr>
				</table>
			</section>
			<section id="sparql-constraints-variables">
				<h4>Mapping of Result Variables to Validation Results</h4>
				<p>
					If one of the <a>solutions</a> of the result set produced by a SELECT query contains the binding <code>true</code>
					for the variable <code>failure</code>, then the SHACL Full processor must signal a <a>failure</a>.
				</p>
				<p>
					Otherwise, each row of the result set produced by a SELECT query must be converted into one validation result node.
					The properties of those nodes are derived by the following rules, through a combination of result variables and the properties linked to the constraint itself.
					The production rules are meant to be executed from top to bottom, so that the first bound value will be used.
				</p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Production Rules</th>
					</tr>
					<tr>
						<td><code>sh:severity</code></td>
						<td>
							<ol>
								<li>The value of <code>sh:severity</code> of the constraint node</li>
								<li><code>sh:Violation</code> as default</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:focusNode</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>focusNode</code></li>
								<li>The value of the variable <code>this</code></li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:path</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>path</code> (only supports property IRIs, no complex paths)</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:value</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>value</code></li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:message</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>message</code></li>
								<li>
									The values of <code>sh:message</code> of the subject of the <code>sh:select</code> or <code>sh:ask</code> triple.
									These string literals may reference any <a>binding</a> of the SELECT result variables via <code>{?varName}</code> or <code>{$varName}</code>.
									If the constraint is based on a <a href="#constraint-components">constraint component</a>, then the component's <a>parameter names</a> can also be used.
									The <code>{?varName}</code> blocks SHOULD be substituted with suitable string representations of the values of said variables.
								</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:sourceConstraint</code></td>
						<td>
							<ol>
								<li>The <a>constraint</a> that was validated against</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:sourceShape</code></td>
						<td>
							<ol>
								<li>The <a>shape</a> that was validated against</li>
							</ol>
						</td>
					</tr>
				</table>
			</section>
			<section id="sparql-constraints-annotations">
				<h4>Injecting Annotation Properties into Validation Results</h4>
				<p>
					It is possible to inject additional <span class="term">annotation properties</span> into the validation result nodes created for each <a>solution</a> of the SELECT result sets.
					Any such property needs to be declared via a value of <code>sh:resultAnnotation</code> at the subject holding the <code>sh:select</code> or <code>sh:ask</code> triple.
					The values of <code>sh:resultAnnotation</code> must be IRIs or blank nodes with the following properties:
				</p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Value type</th>
						<th>Count</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>sh:annotationProperty</code></td>
						<td><code>rdf:Property</code></td>
						<td><code>1&nbsp;(mandatory)</code></td>
						<td>The annotation property that shall be set</td>
					</tr>
					<tr>
						<td><code>sh:annotationVarName</code></td>
						<td><code>xsd:string</code></td>
						<td><code>0..1</code></td>
						<td>The name of the SPARQL variable to take the values from</td>
					</tr>
					<tr>
						<td><code>sh:annotationValue</code></td>
						<td></td>
						<td><code>0..unlimited</code></td>
						<td>Constant nodes that shall be used as default values</td>
					</tr>
				</table>
				<p>
					For each <a>solution</a> of a SELECT result set, a SHACL Full processor must walk through the declared result annotations.
					The mapping from result annotations to SPARQL variables uses the following rules:
				</p>
				<ol>
					<li>If a <code>sh:resultAnnotation</code> defines a <code>sh:annotationVarName</code> then the SHACL Full processor must look for the variable named after the <code>sh:annotationVarName</code></li>
					<li>Otherwise, the SHACL Full processor must derive a variable name from the value of <code>sh:annotationProperty</code> using the same <a>local name</a> mechanism as described earlier</li>
				</ol>
				<p>
					If a variable name could be determined, then the SHACL Full processor must copy the bindings for the given variable into the constructed validation results for the current <a>solution</a>.
					If the variable has no binding in the result set <a>solution</a>, then the value of <code>sh:annotationValue</code> must be used, if present.
				</p>
				<p>
					The values of <code>sh:annotationProperty</code> must not be from the SHACL namespace, to avoid clashes with variables that are already produced by other means.
				</p>
				<p>
					Here is a slightly complex example, illustrating the use of result annotations.
				</p>
				<pre class="example-shapes">
ex:ShapeWithPathViolationExample
	a sh:Shape ;
	sh:targetNode ex:ExampleRootResource ;
	sh:sparql [
		sh:resultAnnotation [
			sh:annotationProperty ex:time ;
			sh:annotationVarName "time"
		] ;
		sh:select """
			SELECT $this (ex:property1 AS ?path) (?first AS ?value) ?message ?time
			WHERE {
				$this ex:property1 ?first .
				?subject ex:property2 ?first .
				FILTER isBlank(?value) .
				BIND (CONCAT("The ", "message.") AS ?message) .
				BIND (NOW() AS ?time) .
			}
			""" ;
	] .</pre>

				<pre class="example-data">
ex:ExampleRootResource
	ex:property1 ex:ExampleIntermediateResource .

ex:ExampleValueResource
	ex:property2 ex:ExampleIntermediateResource .
</pre>
				<p>
					Which produces the following validation result nodes:
				</p>
				<pre class="example-results">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:ExampleRootResource ;
	sh:path ex:property1 ;
	sh:value ex:ExampleIntermediateResource ;
	sh:message "The message." ;
	sh:sourceConstraint [ the blank node of the sh:sparql above ] ;
	sh:sourceShape ex:ShapeWithPathViolationExample ;
	ex:time "2015-03-27T10:58:00"^^xsd:dateTime ;  # Example
] .</pre>
			</section>
		</section>
		
		<section id="constraint-components">
			<h2>SPARQL-based Constraint Components</h2>
			<p>
				SPARQL-based constraints as introduced in the previous section provide a lot of flexibility.
				However, SPARQL-based constraints may be hard to understand for some people or lead to repetition.
				<a>Constraint components</a> are a way to abstract the complexity of SPARQL and define high level reusable components similar to the <a href="#constraints">Core constraint components</a>.
				The definition of such constraint components can be represented in the SHACL RDF vocabulary and thus shared and reused.
			</p>
			<p>
				<code>sh:ConstraintComponent</code> is the <a>SHACL class</a> of all constraint components.
				Each constraint component must define:
			</p>
			<ul>
				<li>one or more <a href="#constraint-components-parameters">parameters</a> (e.g. <code>sh:class</code>, <code>sh:stem</code>)</li>
				<li>at least one <a href="#constraint-components-validators">validator</a></li>
			</ul>
			<section class="informative">
				<h3>An Example Constraint Component</h3>
				<p>
					The following example demonstrates how SPARQL can be used to define new constraint components using the SHACL Full language.
					The example implements <a href="#PatternConstraintComponent"><code>sh:pattern</code> and <code>sh:flags</code></a> using a <a href="#SPARQLAskValidator">SPARQL ASK</a> query to validate that each <a>value node</a> matches a given regular expression.
					Note that this is only an example implementation and should not be considered normative.
				</p>
				<pre class="example-shapes" title="Constraint component based on SPARQL">
sh:PatternConstraintComponent
	a sh:ConstraintComponent ;
	sh:parameter [
		sh:predicate sh:pattern ;
		sh:order 0 ;
	] ;
	sh:parameter [
		sh:predicate sh:flags ;
		sh:optional true ;
		sh:order 1 ;
	] ;
	sh:validator shimpl:hasPattern .

shimpl:hasPattern
	a sh:SPARQLAskValidator ;
	sh:message "Value does not match pattern {$pattern}" ;
	sh:ask "ASK { FILTER (!isBlank($value) &amp;&amp; IF(bound($flags), regex(str($value), $pattern, $flags), regex(str($value), $pattern))) }" .</pre>
				<p>
					The following sections introduce the properties that <a>constraint components</a> may have.
					Some of these properties are independent of SPARQL-based execution and apply
					to constraint components based on other potential extension languages such as JavaScript too.
				</p>
			</section>
			<section id="constraint-components-parameters">
				<h3>Parameters Declaration (sh:parameter)</h3>
				<p>
					The parameters of a <a>constraint component</a> are declared via the property <code>sh:parameter</code>.
					The objects of triples with <code>sh:parameter</code> as predicate have <code>sh:Parameter</code> as <a>expected type</a>.
				</p>
				<p class="issue" data-number="107" title="Specifying SPARQL variable name">
					There is an open issue about the relationship between SPARQL variable name and sh:predicate.
					Possible revisions may require an additional property similar to sh:annotationVarName.
				</p>
				<p>
					Each parameter must have exactly one value <code>p</code> for the property <code>sh:predicate</code> and the value must be an IRI.
					The <dfn data-lt="local names">local name</dfn> of an <a>IRI</a> is defined as the longest <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCNAME</a>
					at the end of the <a>IRI</a>, not immediately preceded by the first colon in the <a>IRI</a>.
					The <dfn data-lt="parameter names">parameter name</dfn> is defined as the <a>local name</a> of the <a>value</a> of <code>sh:predicate</code>.
					To ensure that a correct mapping from parameters into SPARQL variables is possible, every <a>parameter name</a>:
				</p>
				<ul>
					<li>Must be a valid <a href="http://www.w3.org/TR/sparql11-query/#rVARNAME">SPARQL VARNAME</a></li>
					<li>Must not be equal to <code>this</code>, <code>shapesGraph</code>, <code>currentShape</code>, <code>focusNode</code>, <code>predicate</code>, <code>path</code> or <code>value</code>.</li>
					<li>Must not be equal to another <a>parameter name</a> in the same <a>constraint component</a></li>
				</ul>
				<p>
					An <code>sh:Parameter</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the parameter is not mandatory.
					Every <a>constraint component</a> must have at least one non-optional parameter.
				</p>
				<p>
					The class <code>sh:Parameter</code> is defined as a <a>SHACL subclass</a> of <code>sh:PropertyConstraint</code>,
					and all properties that are applicable to property constraints may also be used for parameters.
					This includes descriptive properties such as <code>sh:name</code> and <code>sh:description</code>
					but also constraint parameters such as <code>sh:class</code>.
					Some implementations MAY use these constraint parameters to prevent the execution of constraint components with invalid parameter values.
				</p>
				<section id="constraint-components-parameter-pre-binding">
					<h4>Parameter pre-binding</h4>
					<p>
						Every <a>parameter name</a> defines a <a>pre-bound</a> variable for the <a>constraint component</a> the parameter belongs to.
						This variable can be used in the SPARQL definition of the <a>constraint component</a> and a SHACL Full processor MUST <a>pre-bind</a> it to the parameter value.
					</p>
				</section>
			</section>
			<section id="labelTemplate">
				<h3>Label Templates (sh:labelTemplate)</h3>
				<p>
					The property <code>sh:labelTemplate</code> can be used at any <a>constraint component</a> to suggest how they could be rendered to humans.
					The values of <code>sh:labelTemplate</code> must be strings (possibly with language tag) that can reference the values of the declared parameters using the syntax <code>{?varName}</code> or <code>{$varName}</code>,
					where <code>varName</code> is the name of the SPARQL variable that corresponds to the parameter.
					At display time, these <code>{...}</code> blocks SHOULD be substituted with the actual parameter values.
					There may be multiple label templates for the same subject, assuming they do not have the same language tags.
				</p>
			</section>
			<section id="constraint-components-validators">
				<h3>Validators</h3>
				<p>
					For every supported context (i.e., <a>property constraint</a> or <a>shape</a>)
					the constraint component must declare a suitable <a>validator</a>.
					For a given constraint, a validator is selected from the constraint component using the following rules:
				</p>
				<ol>
					<li>For <a>shapes</a>, use one of the values of <code>sh:shapeValidator</code>, if present.</li>
					<li>For <a>property constraints</a>, use one of the values of <code>sh:propertyValidator</code>, if present.</li>
					<li>Otherwise, use one of the values of <code>sh:validator</code>.
				</ol>
				<p>
					If no suitable validator can be found, a SHACL Full processor ignores the constraint.
					<span class="todo">The SHACL WG is seeking practical feedback on what the default behavior should be, and
					whether we should report violations in those cases.</span>
				</p>
				<p>
					SHACL Full includes two types of validators, based on <a href="#SPARQLSelectValidator">SPARQL SELECT</a> (for <code>sh:shapeValidator</code> and <code>sh:propertyValidator</code>)
					or <a href="#SPARQLAskValidator">SPARQL ASK</a> queries (for <code>sh:validator</code>).
				</p>
				<section id="SPARQLSelectValidator">
					<h3>Validators based on SPARQL SELECT Queries</h3>
					<p>
						Validators that are <a>SHACL instances</a> of <code>sh:SPARQLSelectValidator</code> must point at exactly one string representation of a SPARQL SELECT query via the property <code>sh:select</code>.
						The value of <code>sh:select</code> must be a valid SPARQL query using the aforementioned <a href="#sparql-prefixes">prefix handling rules</a>.
						This type of validator can be used as values of <code>sh:shapeValidator</code> or <code>sh:propertyValidator</code>.
					</p>
					<p>
						The following example illustrates the definition of a constraint component based on a SPARQL SELECT query.
						It is a generalized variation of the SPARQL-based example constraint from the <a href="#example-sparql-constraint">section on SPARQL-based constraints</a>.
						That SPARQL query included two constants: the specific property <code>ex:germanLabel</code> and the language tag <code>de</code>.
						Constraint components make it possible to generalize such scenarios, so that constants get <a>pre-bound</a> with <a>parameters</a>.
						This allows the query logic to be reused in multiple places, without having to write any new SPARQL.
					</p>
					<pre class="example-shapes" title="Constraint component based on SPARQL">
ex:LanguageConstraintComponentUsingSELECT
	a sh:ConstraintComponent ;
	rdfs:label "Language constraint component" ;
	sh:parameter [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:minLength 2 ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values must be literals with language \"{$lang}\"" ;
	sh:propertyValidator [
		a sh:SPARQLSelectValidator ;
		sh:message "Values must be literals with language \"{?lang}\"" ;
		sh:select """
			SELECT DISTINCT $this ?value
			WHERE {
				$this $PATH ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), $lang))
			}
			"""
	] .</pre>
					<p>
						Once a constraint component has been defined, its parameters can be used as illustrated in the following example.
					</p>
					<pre class="example-shapes" title="Shape definition using ex:LanguageConstraintComponent">
ex:LanguageExampleShape
	a sh:Shape ;
	sh:targetClass ex:Country ;
	sh:property [
		sh:predicate ex:germanLabel ;
		ex:lang "de" ;
	] ;
	sh:property [
		sh:predicate ex:englishLabel ;
		ex:lang "en" ;
	] .</pre>
					<p>
						The example shape above specifies that all values of <code>ex:germanLabel</code> must carry the language tag <code>de</code>
						while all values of <code>ex:englishLabel</code> must have <code>en</code> as their language.
						These details are specified via two property constraints that provide values for the <code>ex:lang</code> parameter required by the constraint component.
					</p>
					<p>
						SELECT queries used in the context of <a>property constraints</a> must use a special variable named <code>PATH</code> as a placeholder for the predicate or path
						used by the constraint.
						The only legal use of this variable is in the <a>predicate</a> position of a <a href="https://www.w3.org/TR/sparql11-query/#QSynTriples">triple pattern</a>.
						A query that uses the variable <code>PATH</code> in any other position is invalid.
						Furthermore, any query that uses the variable <code>this</code> as part of the Expression used in a SPARQL 1.1 <a href="https://www.w3.org/TR/sparql11-query/#rAggregate">Aggregate</a>
						is invalid. <!-- HK: This is because otherwise this would prevent implementations from injecting a loop over all target nodes into the beginning of the query -->
					</p>
					<p id="SPARQLSelectValidator-evaluation">
						A SHACL Full processor executes the provided SPARQL query on the data graph to produce validation results.
						In the context of <a>property constraints</a>, the SHACL Full processor will first substitute all occurrences of the variable <code>PATH</code>
						with the provided <a>property path</a> derived from the value of either <code>sh:predicate</code> or <code>sh:path</code> in the constraint.
						The resulting SPARQL query is then evaluated with the same <a>pre-bound variables</a>
						as outlined in the section for <a href="#sparql-constraints-prebound">SPARQL-based Constraints</a> (<code>$this</code> etc).
						Additionally, the value of each declared <a>parameter</a> of the constraint component needs to be pre-bound for
						the variable derived by the <a>local name</a> of the parameter's <code>sh:predicate</code>.
						For example, if a non-optional parameter declares <code>sh:predicate ex:lang</code> then the variable <code>lang</code> needs to be pre-bound.
						The result set of the SELECT query is turned into validation results using the same rules as outlined in the section for <a href="#sparql-constraints-variables">SPARQL-based Constraints</a>.
						In addition to the result properties listed in that section, the property <code>sh:sourceConstraintComponent</code> MUST point at the
						IRI of the constraint component that has been evaluated.
						Furthermore, a SPARQL select validator may declare additional <a href="#sparql-constraints-annotations">annotation properties</a> via <code>sh:resultAnnotation</code>.
					</p>
				</section>
				<section id="SPARQLAskValidator">
					<h3>Validators based on SPARQL ASK Queries</h3>
					<p>
						Many constraint components are of the form in which all <a>value nodes</a> are tested individually against some boolean condition.
						Writing SELECT queries for these becomes burdensome, especially if a constraint component can be used for both <a>property constraints</a> and <a>shapes</a>.
						SHACL Full provides an alternative, more compact syntax for validators based on ASK queries.
						This type of validators can be used as values of the property <code>sh:validator</code>.
					</p>
					<p>
						Validators that are <a>SHACL instances</a> of <code>sh:SPARQLAskValidator</code> must point at exactly one string representation of a SPARQL ASK query via the property <code>sh:ask</code>.
						The value of <code>sh:ask</code> must be a valid SPARQL query using the aforementioned <a href="#sparql-prefixes">prefix handling rules</a>.
						The ASK queries are expected to return <code>true</code> if a given <a>value node</a>
						(represented by the pre-bound variable <code>value</code>) is valid.
					</p>
					<p>
						Prior to evaluation, a SHACL Full processor transforms the provided ASK query into a SELECT query using the following templates.
						The resulting SELECT query can then be evaluated using the same algorithm as for <a href="#SPARQLSelectValidator-evaluation">SELECT-based validators</a>.
						The processor drops the ASK keyword, any top-level dataset clauses and solution modifiers, leaving only the <code>GroupGraphPattern</code> including the outermost <code>{...}</code> pair.
						This block then substitutes <code>...</code> in the template.
					</p>
					<p>Template for <code>sh:Shape</code> context:</p>
					<pre>
	SELECT $this ?value
	WHERE {
		BIND ($this AS ?value) .
		FILTER NOT EXISTS ...
	}</pre>
					<p>Template for <code>sh:PropertyConstraint</code> context:</p>
					<pre>
	SELECT DISTINCT $this ?value
	WHERE {
		$this $PATH ?value .
		FILTER NOT EXISTS ...
	}</pre>
					<p>
						Note that the template above includes a <code>DISTINCT</code> keyword because a SPARQL path expression may
						return the same <code>?value</code> multiple times, yet each <a>value node</a> is only validated once.
					</p>
					<p>
						Once the corresponding template has been applied, the resulting SELECT query will be evaluated using the same approach as outlined <a href="#SPARQLSelectValidator-evaluation">above</a>.
						Actual SHACL implementations may of course use a different approach internally, as long as the results are equivalent to the described approach.
					</p>
					<p>
						The following example defines a constraint component using an ASK query.
					</p>
					<pre class="example-shapes" title="Constraint component based on SPARQL">
ex:LanguageConstraintComponentUsingASK
	a sh:ConstraintComponent ;
	rdfs:label "Language constraint component" ;
	sh:parameter [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:minLength 2 ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values must be literals with language \"{$lang}\"" ;
	sh:validator ex:hasLang .
	
ex:hasLang
	a sh:SPARQLAskValidator ;
	sh:message "Values must be literals with language \"{$lang}\"" ;
	sh:ask """
		ASK {
			FILTER (isLiteral($value) &amp;&amp; langMatches(lang($value), $lang))
		}
		""" .</pre>
					<p>
						Note that the validation condition implemented by an ASK query is "in the inverse direction" from its SELECT counterpart:
						ASK queries return <code>true</code> for valid value nodes, while SELECT queries return the invalid value nodes.
					</p>
					<p class="todo">
						TODO: The TopBraid SHACL API uses such ASK constraint declarations to install new SPARQL functions.
						Time permitting we could standardize that too, so that people can reuse the same business logic in the queries.
					</p>
				</section>
			</section>

			<section>
				<h3>Evaluation</h3>
				<p>
					A constraint component is triggered for every <a>SHACL instance</a> of a context that defines all non-optional parameters.
					<span class="todo">TODO: This is unclear.</span>
				</p>
			</section>
		</section>

		<section id="sparql-targets">
			<h2>SPARQL-based Targets (sh:target)</h2>
			<p>
				SHACL Full provides facilities to define custom targets.
				Similar to constraints, targets may either be <a href="#SPARQLTarget"><span class="term">SPARQL-based targets</span></a> or
				<a href="#SPARQLTargetType"><span class="term">SPARQL-based target types</span></a> in a higher-level vocabulary.
				All subjects of <code>sh:target</code> triples must be IRIs.
			</p>
			<section id="SPARQLTarget">
				<h3>Targets using sh:SPARQLTarget</h3>
				<p>
					SPARQL-based targets must be <a>SHACL instances</a> of <code>sh:SPARQLTarget</code>, which is a <a>SHACL subclass</a> of <code>sh:Target</code>.
					The SPARQL queries linked to a <a>target</a> via <code>sh:select</code> must be of the query form <code>SELECT</code>.
					The SELECT queries must project to the result variable <code>this</code>.
					The resulting target consists of all distinct bindings for the variable <code>this</code>.
				</p>
				<p>
					The SELECT queries must also be executable when converted to an ASK query and with a pre-bound value for <code>?this</code>.
					The set of bindings for <code>?this</code> that return <code>true</code> for such ASK queries must be identical to the set produced by the SELECT query.
					This design makes sure that SHACL Full processors can validate whether a given shape applies to a given individual focus node.
				</p>
				<p>
					The following example illustrates a well-formed SPARQL-based target that produces all persons born in the USA:
				</p>
				<pre class="example-shapes" title="SPARQL-based target example">
ex:USCitizenShape
	a sh:Shape ;
	sh:target [
		a sh:SPARQLTarget ;
		sh:select """
			SELECT ?this
			WHERE {
				?this a ex:Person .
				?this ex:bornIn ex:USA .
			}
			""" ;
	] ;
	...</pre>
			</section>
			<section id="SPARQLTargetType">
				<h3>SPARQL-based Target Types</h3>
				<p>
					The class <code>sh:TargetType</code> can be used to define high-level vocabularies for targets.
					Similar to constraint components, such targets take <a>parameters</a> that are interpreted when the target is evaluated.
					The class <code>sh:SPARQLTargetType</code> is an <code>rdfs:subClassOf sh:TargetType</code> for target types that define a SPARQL SELECT query via the property <code>sh:select</code>.
					Similar to constraint components, the parameter values become <a href="#pre-binding">pre-bound variables</a> in such SPARQL queries.
					The parameter values of such targets must not be blank nodes.
					All parameters of target types are expected to have <code>sh:maxCount 1</code>.
					Similar to constraint components, target types may also have values for the property <a href="#labelTemplate"><code>sh:labelTemplate</code></a>.
				</p>
				<p>
					The following example defines a new SPARQL-based parameterizable target class that takes one parameter <code>ex:country</code>
					that gets mapped into the variable <code>country</code> in the corresponding SPARQL query to determine the resulting focus nodes.
				</p>
				<pre class="example-shapes" title="Parameterized target example">
ex:PeopleBornInCountryTarget
	a sh:SPARQLTargetType ;
	rdfs:subClassOf sh:Target ;
	sh:labelTemplate "All persons born in {$country}" ;
	sh:parameter [
		sh:predicate ex:country ;
		sh:name "country" ;
		sh:description "The country that the focus nodes must be born in." ;
		sh:class ex:Country ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
		sh:nodeKind sh:IRI ;
	] ;
	sh:select """
		SELECT ?this
		WHERE {
			?this a ex:Person .
			?this ex:bornIn $country .
		}
		""" .

ex:USCitizenShape
	a sh:Shape ;
	sh:target [
		a ex:BornInCountryTarget ;
		ex:country ex:USA ;
	] ;
	...</pre>
				<p>
					The set of target nodes produced by such a target type consists of all bindings of the variable <code>this</code> in the result set,
					when the SPARQL SELECT query has been executed with the pre-bound parameter values.
				</p>
			</section>
		</section>
		
		<section id="derivedValues">
			<h2>Derived Values Constraints</h2>
			<p>
				It is a common scenario that certain property values are derived from other values.
				For example, the area of a rectangle must be the product of width and height, or an uncle of a person is a male sibling of a parent.
				SHACL Full includes a constraint parameter <code>sh:derivedValues</code> that can be used with property constraints to define such constraints.
			</p>
			<p>
				<span class="component-class">Constraint Component IRI</span>: <code>sh:DerivedValuesConstraintComponent</code>
			</p>

			<div class="parameters">Parameters:</div>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><code>sh:derivedValues</code></td>
					<td>An object providing instructions on how to derive the values</td>
				</tr>
			</table>
			<p>
				The values of <code>sh:derivedValues</code> must be <a>SHACL instances</a> of a <a>SHACL subclass</a> of <code>sh:ValuesDeriver</code>.
				<code>sh:SPARQLValuesDeriver</code> is the only <a>SHACL subclass</a> of <code>sh:ValuesDeriver</code> defined by SHACL Full.
				Each <a>SHACL instance</a> of <code>sh:SPARQLValuesDeriver</code> must have exactly one <a>value</a> for the property <code>sh:select</code> that can be used to produce the values that the property is expected to have.
				The values of <code>sh:select</code> must be SPARQL SELECT queries that project into the variable <code>value</code> only.
				These queries can access the current focus node via the variable <code>this</code> and must produce bindings for the variable <code>value</code> for all derived values.
			</p>
			<div class="def def-text">
				<div class="def-header">TEXTUAL DEFINITION</div>
				<div class="def-text-body">
					Let S be the set of nodes produces by the values deriver for the <a>focus node</a>.
					A <a>validation result</a> must be produced for every <a>value node</a>
					that is not in S, and for every member of S that is not a <a>value node</a>.
					The produced <a>validation results</a> must have the <a>focus node</a> as its <code>sh:focusNode</code>,
					the <code>sh:predicate</code> or <code>sh:path</code> as its <code>sh:path</code>, and the missing or extra value as its <code>sh:value</code>.
				</div>
			</div>
			<p>
				The following example illustrates the use of <code>sh:derivedValues</code> to define a restriction
				so that the value of the property <code>ex:area</code> must be the product of the value of <code>ex:width</code> and <code>sh:height</code>.
			</p>
			<pre class="example-shapes" title="A property definition with derived values">
ex:RectangleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:width ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate ex:height ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate ex:area ;
		sh:datatype xsd:integer ;
		sh:derivedValues [
			a sh:SPARQLValuesDeriver ;
			sh:select """
				SELECT ?value
				WHERE {
					$this ex:width ?width .
					$this ex:height ?height .
					BIND (?width * ?height AS ?value) .
				}
				""" ;
		] ;
	] .</pre>
		</section>
		
		<section id="functions">
			<h2>SPARQL Functions</h2>
			<p>
				SHACL <dfn data-lt="function|SHACL function">functions</dfn> define operations that produce an RDF <a>node</a> based on zero or more <a>parameters</a> and an input RDF <a>graph</a> (or dataset).
				Functions can be called within SPARQL queries to encapsulate complex logic of other SPARQL queries, or executable logic in other languages such as JavaScript.
				However, the general declaration mechanism for SHACL functions is independent from SPARQL and may also be exploited by other environments.
			</p>
			<section id="sparql-functions-syntax">
				<h3>Syntax of SPARQL Functions</h3>
				<p>
					Functions that encapsulate a SPARQL query must be <a>SHACL instances</a> of <code>sh:SPARQLFunction</code>, which is a <a>SHACL subclass</a> of the more general class <code>sh:Function</code>.
					Such functions must provide exactly one <a>value</a> for either <code>sh:ask</code> or <code>sh:select</code>, linking to a SPARQL query.
				</p>
				<p>
					The following example illustrates the definition of a function based on a simple mathematical SPARQL query.
				</p>
				<pre class="example-shapes" title="SHACL function with a SPARQL body">
ex:exampleFunction
	a sh:SPARQLFunction ;
	rdfs:comment "Computes the sum of its two parameters ?op1 and ?op2." ;
	sh:parameter [
		sh:predicate ex:op1 ;
		sh:datatype xsd:integer ;
		sh:description "The first operand" ;
	] ;
	sh:parameter [
		sh:predicate ex:op2 ;
		sh:datatype xsd:integer ;
		sh:description "The second operand" ;
	] ;
	sh:returnType xsd:integer ;
	sh:select """
		SELECT ($op1 + $op2 AS ?result)
		WHERE {
		}
		""" .</pre>
				<p>
					Using the declaration above, SPARQL engines with  SHACL Full support can install a new SPARQL function based on the SPARQL 1.1 <a href="http://www.w3.org/TR/sparql11-query/#extensionFunctions">Extensible Value Testing</a> mechanism.
					Such engines are then able to handle expressions such as <code>ex:exampleFunction(40, 2)</code>, producing <code>42</code>, as illustrated in the following SPARQL query.
				</p>
				<pre class="example-shapes" title="Call of a SHACL function in a SPARQL query">
SELECT ?subject
WHERE {
	?subject ex:myProperty ?value .
	FILTER (ex:exampleFunction(?value, 2) = 42) .
}</pre>
				<p>
					The following sections introduce the properties that such functions may have.
				</p>
			</section>
			<section id="function-parameters">
				<h3>Function Parameters</h3>
				<p>
					The <a>parameters</a> of a function are linked to its <code>sh:Function</code> via the property <code>sh:parameter</code>.
					The objects of triples with <code>sh:parameter</code> as predicate have <code>sh:Parameter</code> as <a>expected type</a>.
				</p>
				<p>
					Each parameter must have exactly one <a>value</a> for the property <code>sh:predicate</code>.
					The <a>values</a> of <code>sh:predicate</code> must be <a>IRIs</a>, and follow the following restrictions:
				</p>
				<ul>
					<li>The <a>local name</a> must be a valid <a href="http://www.w3.org/TR/sparql11-query/#rVARNAME">SPARQL VARNAME</a></li>
					<li>There must not be any other declared <code>sh:Parameter</code> for the same function that has a <code>sh:predicate</code> with the same <a>local name</a></li>
				</ul>
				<p id="parameters-ordering">
					<a>Parameters</a> are ordered, corresponding to the notation of function calls in SPARQL such as
					<code>ex:exampleFunction(?param1, ?param2)</code>.
					The ordering of function <a>parameters</a> is determined as follows:
				</p>
				<ol>
					<li><a>Parameters</a> are ordered in ascending order by the numeric values of <code>sh:order</code>.</li>
					<li><a>Parameters</a> that do not declare an <code>sh:order</code> are placed after those that have.</li>
					<li><a>Parameters</a> that do not declare an <code>sh:order</code> are ordered by the <a>local names</a> of their declared <code>sh:predicate</code>s.</li>
				</ol>
				<p>
					Each parameter may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the <a>parameter</a> is not mandatory.
				</p>
			</section>
			<section id="function-returnType">
				<h3>sh:returnType</h3>
				<p>
					A function may declare a single return type via <code>sh:returnType</code>.
					This information may serve for documentation purposes, only.
					However, in some execution languages such as JavaScript, the declared <code>sh:returnType</code> may inform
					a processor how to cast a native value into an <a>RDF term</a>.
				</p>
			</section>
			<section id="function-evaluation">
				<h3>Evaluation of Functions</h3>
				<p>
					<a>SHACL instances</a> of <code>sh:SPARQLFunction</code> must have exactly one <a>value</a> for either <code>sh:ask</code> or <code>sh:select</code>.
					The <a>values</a> of this property must be strings that can be parsed into SPARQL queries of type ASK (for <code>sh:ask</code>) or SELECT (for <code>sh:select</code>).
					SELECT queries must project exactly one result variable and SHOULD not use the <code>SELECT *</code> syntax.
					In the SPARQL query, the SPARQL processor needs to <a>pre-bind</a> variables based on the provided parameters of the function call.
					For ASK queries, the function's return value is the result of the ASK query execution, i.e. <code>true</code> or <code>false</code>.
					For SELECT queries, the function's return value is the <a>binding</a> of the (single) result variable of the first <a>solution</a> in the result set.
					Since all other bindings will be ignored, such SELECT queries SHOULD only return a single result variable and at most one <a>solution</a>.
					If the result variable is unbound, then the function generates a <a href="https://www.w3.org/TR/sparql11-query/#invocation">SPARQL error</a>.
				</p>
				<p>
					Some processors may ignore the specified SPARQL query and rely on an alternative (possibly native) implementation instead,
					as long as the functions return the same values as the specified SPARQL query.
					This can be used to optimize frequently needed functions.
					Some processors may even use the SPARQL query to rewrite other SPARQL queries via inlining techniques.
				</p>
			</section>
		</section>

		<section id="entailment">
			<h2>Entailment</h2>
			<p>
				By default, SHACL does not assume any <span class="term">entailment regime</span> [[!sparql11-entailment]] to be activated on the <a>data graph</a>.
				However, the property <code>sh:entailment</code> can be used in the <a>shapes graph</a> to instruct a SHACL processor to ensure that a given entailment is activated on the <a>data graph</a>.
				The <a>values</a> of <code>sh:entailment</code> must be <a>IRIs</a>, with common use cases covered by [[!sparql11-entailment]].
				<!--DK: we can be agnostic on the what the subject is-->
				<!--The subject of <code>sh:entailment</code> must be the IRI of the shapes graph itself.-->
			</p>
			<p>
				SHACL processors are not required to support any entailment regimes.
				If an entailment regime is provided in the <a>shapes graph</a> which is not supported by the SHACL processor, the <a>validation</a> must produce a <a>failure</a>.
			</p>
		</section>
		
		<div style="padding-top: 30px">
			<h1 id="appendix" style="font-size: 160%; font-weight: bold">Appendix</h1>
		</div>

		<section id="pre-binding" class="appendix">
			<h2>Pre-binding of Variables in SPARQL Queries</h2>
			<p class="issue" data-number="68" title="Pre-binding of Variables in SPARQL">
				The following definition of what pre-binding means has not been approved by the WG yet,
				and is work in progress.
				The WG is also awaiting input from the <a href="https://www.w3.org/community/sparql-exists/">SPARQL Maintenance (EXISTS) Community Group</a>.
			</p>
			<p>
				Some features of the SPARQL-based extension mechanism of SHACL Full rely on the concept of <dfn data-lt="pre-binding|pre-bind|pre-bound|pre-bound variables|pre-binds">pre-binding of variables</dfn>.
				Although variations of this concept are supported by several existing SPARQL implementations, there is no formal definition of pre-binding in the SPARQL 1.1 specifications.
				The goal of this section is to illustrate the effect of pre-binding to users and implementers.
				Note however that the following definition is not meant to serve as recommendation for an actual implementation strategy.
			</p>
			<p>
				<span class="term">Pre-binding</span> a variable with a value means that
				the SPARQL processor needs to evaluate all occurrences of variables with that same name
				(including occurrences in inner targets and nested SELECT queries)
				so that they have the provided value.
				In other words, whenever a SPARQL processor evaluates a pre-bound variable, it must use the given value.
 			</p>

			<section id="pre-bindound-variables">
				<h3>Pre-bound variables</h3>
				<p>
					SHACL Full defines two forms of variable pre-binding:
				</p>
				<ol>
			        <li><a href="#sparql-constraints-prebound">Global pre-bound variables</a> that are available in all SPARQL-based constraints, SPARQL-based constraint components and SPARQL-based targets.</li>
					<li>Local pre-bound variables available only within a SPARQL-based constraint component and defined through the <a href="#constraint-components-parameter-pre-binding">component parameters</a> </li>
				</ol>
				<p>
					The variable <code>PATH</code> has a special treatment in SHACL property constraint components and must be processed before any other pre-bound variable.
					SHACL Full processors must perform string substitution of every occurrence of the variable <code>PATH</code> to the <a href="#path-syntax">generated SPARQL property path</a> before performing any pre-binding.
				</p>
				<p>
					The variable <code>predicate</code> is not a pre-bound variable in SHACL and will be treated as a normal SPARQL variable.
					<span class="todo">Should we disallow the variable predicate instead to avoid confusion?</span>
				</p>
			</section>

		</section>

		<section id="ack" class="appendix informative">
			<h2>Acknowledgements</h2>
			<p>
				Many people contributed to this specification, including members of the RDF Data Shapes Working Group.
				We especially thank the following:
			</p>
			<p>
				Arnaud Le Hors (chair),
				Jim Amsden,
				Iovka Boneva,
				Karen Coyle,
				Richard Cyganiak,
				Michel Dumontier,
				Holger Knublauch,
				Dimitris Kontokostas,
				Jose Labra,
				Peter Patel-Schneider,
				Eric Prud'hommeaux,
				Arthur Ryman (who also served as a co-editor until Feb 2016),
				Harold Solbrig,
				Simon Steyskal,
				Ted Thibodeau
			</p>
		</section>
		
	</body>
</html>
