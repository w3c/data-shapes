<!DOCTYPE html>
<html>
	<head>
		<title>Shapes Constraint Language (SHACL)</title>
		<meta charset="utf-8">
		<script src="https://www.w3.org/Tools/respec/respec-w3c-common" async class="remove"></script>
		<script class="remove">
			var respecConfig = {
				edDraftURI: "http://w3c.github.io/data-shapes/shacl/",
				issueBase: "http://www.w3.org/2014/data-shapes/track/issues/",
				specStatus: "ED",
				previousPublishDate: "2016-08-14",
				previousMaturity: "WD",
				shortName:  "shacl",
				editors: [
					{
						name:       "Holger Knublauch",
						url:        "http://knublauch.com/",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/",
						w3cid:      46500
					},
					{
						name:       "Dimitris Kontokostas",
						url:        "http://Kontokostas.com",
						company:    "University of Leipzig",
						companyURL: "http://informatik.uni-leipzig.de/",
						w3cid:      58399
					}
				],
				wg:           "RDF Data Shapes Working Group",
				wgURI:        "https://www.w3.org/2014/data-shapes/",
				wgPublicList: "public-rdf-shapes",
				wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/73865/status",
				noHighlightCSS: true
			};
		</script>
		<!-- script src="https://www.w3.org/scripts/jquery/2.1/jquery.min.js"></script--> 
		<style>

			pre {
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			td {
				vertical-align: top;
			}
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.def-sparql {
			}
			
			.def-sparql-body {
				margin-top: 0px;
				margin-bottom: 0px;
			}
			
			.def-text {
			}
			
			.def-text-body {
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.focus-node-selected {
				color: blue;
			}
			.focus-node-error {
				color: red;
			}

			.triple-can-be-skipped {
				color: grey;
			}
			.focus-node-error {
				color: red;
			}
			
			.component-class {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameter-context {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameters {
				font-weight: bold;
				font-size: 16px;
			}

			.part-header {
				font-weight: bold;
			}
		
			.term {
				font-style: italic;
			}
			
			.term-def-header {
				font-style: italic;
				font-weight: bold;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}

			.term-table td, th {
				border-width: 1px;
				border-style: solid;
				padding: 5px;
			}
		
			.todo {
				color: red;
			}

			/* example pre taken / adapted from R2RML */
			pre.example-shapes, pre.example-data, pre.example-results { margin-left: 0; padding: 0 2em; margin-top: 1.5em; padding: 1em; }
			pre.example-shapes:before, pre.example-data:before, pre.example-results:before { background: white; display: block; font-family: sans-serif; margin: -1em 0 0.4em -1em; padding: 0.2em 1em; }
			pre.example-shapes { background: #deb; }
			pre.example-shapes, pre.example-shapes:before { border: 1px solid #bbb; }
			pre.example-shapes:before { color: #888; content: "Example shapes graph"; width: 13em; }
			pre.example-data { background: #eeb; }
			pre.example-data, pre.example-data:before { border: 1px solid #cc9; }
			pre.example-data:before { color: #996; content: "Example data graph"; width: 13em; }
			.example-results { background: #edb; }
			.example-results, .example-results:before, .example-results th, .example-results td { border: 1px solid #aca; }
			pre.example-results:before { color: #797; content: "Example validation results"; width: 13em; }

			/* our syntax menu for switching */
			div.syntaxmenu {
				border: 1px dotted black;
				padding:0.5em;
				margin: 1em; 
			}

			@media print {
				div.syntaxmenu { display:none; }
			}
		</style>
	</head>
	<body>

		<section id="abstract">
			<p>
				This document defines the SHACL Shapes Constraint Language, a language for validating RDF graphs against a set of conditions.
				These conditions are provided as shapes and other constructs expressed in the form of an RDF graph.
				RDF graphs that are used in this manner are called "shapes graphs" in SHACL and
				the RDF graphs that are validated against a shapes graph are called "data graphs".
				As SHACL shape graphs are used to validate that data graphs satisfy a set of conditions
				they can also be viewed as a description of the data graphs that do satisfy these conditions.
				Such descriptions may be used for a variety of purposed beside validation, including
				user interface building, code generation and data integration.
			</p>
		</section>

		<section id="sotd">
		</section>
		<section class='introductory'>
		  <h2>Revision History</h2>
			<p>
				The detailed list of changes and their diffs can be found in the <a href="https://github.com/w3c/data-shapes/commits/gh-pages/shacl/index.html">Git repository</a>.
			</p>
			<ul>
				<li><b>2016-09-15</b>: Added proposed SPARQL prefix handling section (<a href="http://www.w3.org/2014/data-shapes/track/issues/105">ISSUE-105</a>)</li>
				<li><b>2016-09-15</b>: Added sh:languageIn (<a href="http://www.w3.org/2014/data-shapes/track/issues/137">ISSUE-137</a>)</li>
				<li><b>2016-08-26</b>: Remove special treatment of sh:Violation (<a href="http://www.w3.org/2014/data-shapes/track/issues/150">ISSUE-150</a>)</li>
				<li><b>2016-08-23</b>: Added Appendix enumerating the optional features of SHACL</li>
				<li><b>2016-08-05</b>: Renamed scope to target, sh:scopeProperty -> sh:scopeSubjectsOf, etc <a href="http://www.w3.org/2014/data-shapes/track/issues/175">ISSUE-175</a>)</li>
				<li><b>2016-08-01</b>: Deleted sh:classIn and sh:datatypeIn <a href="https://www.w3.org/2016/07/28-shapes-minutes.html#resolution07">resolution on ISSUE-141</a></li>
				<li><b>2016-07-28</b>: Drop sh:defaultValueType according to <a href="https://www.w3.org/2016/06/16-shapes-minutes.html#resolution03">resolution</a></li>
				<li><b>2016-07-23</b>: Change abstract and adopt <a href="https://lists.w3.org/Archives/Public/public-rdf-shapes/2016May/0008.html">Peter's proposal</a>)</li>
				<li><b>2016-07-23</b>: Changes to accommodate universal applicability <a href="http://www.w3.org/2014/data-shapes/track/issues/139">ISSUE-139</a>)</li>
				<li><b>2016-07-05</b>: Generalized inverseProperty into property paths, added generalized sh:validator <a href="http://www.w3.org/2014/data-shapes/track/issues/41">ISSUE-41</a>)</li>
				<li><b>2016-06-17</b>: Applied resolution that SHACL leaves recursion to implementations (<a href="http://www.w3.org/2014/data-shapes/track/issues/22">ISSUE-22</a>)</li>
				<li><b>2016-06-12</b>: added explanations of sh:shapesGraph for ontologies / vocabularies</li>
				<li><b>2016-06-03</b>: Removed sh:AllObjectsScope and sh:AllSubjectsScope (<a href="http://www.w3.org/2014/data-shapes/track/issues/148">ISSUE-148</a>)</li>
				<li><b>2016-05-27</b>: Renamed sh:sparql into sh:ask and sh:select. Spawned off sh:sparql from sh:constraint. sh:constraint is now for node constraints only (<a href="http://www.w3.org/2014/data-shapes/track/issues/133">ISSUE-133</a>)</li>
				<li><b>2016-05-27</b>: Changed syntax of property scopes to sh:scopeProperty and sh:scopeInverseProperty (<a href="http://www.w3.org/2014/data-shapes/track/issues/148">ISSUE-148</a>)</li>
				<li><b>2016-05-27</b>: Generalized sh:valueShape into sh:shape (<a href="http://www.w3.org/2014/data-shapes/track/issues/160">ISSUE-160</a>)</li>
				<li><b>2016-05-17</b>: New example in section 1.3</li>
				<li><b>2016-05-13</b>: terminology changes, use SHACL instance, SHACL sub/superclass and SHACL type in the spec</li>
				<li><b>2016-05-13</b>: swap sections 3 with section 4</li>
				<li><b>2016-05-12</b>: sh:and,or,not now also apply to property/inverseProperty constraints (<a href="http://www.w3.org/2014/data-shapes/track/issues/135">ISSUE-135</a>)</li>
				<li><b>2016-05-12</b>: Remove sh:abstract  (<a href="http://www.w3.org/2014/data-shapes/track/issues/78">ISSUE-78</a>)</li>
				<li><b>2016-05-09</b>: SPARQL query at sh:derivedValues must now be proper SELECT queries, to allow PREFIX declarations</li>
				<li><b>2016-05-06</b>: Deleted sh:directType (<a href="http://www.w3.org/2014/data-shapes/track/issues/123">ISSUE-123</a>)</li>
				<li><b>2016-04-22</b>: Switched from graph-based prefixes to sh:prefix (this is a proposal only!) (<a href="http://www.w3.org/2014/data-shapes/track/issues/105">ISSUE-105</a>)</li>
				<li><b>2016-04-20</b>: Significant rework of the advanced sections, based on metamodel Proposal 3 (<a href="http://www.w3.org/2014/data-shapes/track/issues/95">ISSUE-95</a>)</li>
				<li><b>2016-04-18</b>: sh:stem definition</li>
				<li><b>2016-04-18</b>: Renamed sh:sourceTemplate to sh:sourceConstraintComponent</li>
				<li><b>2016-04-18</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-04-15</b>: Allowing multi-occurrence of constraint parameters <a href="http://www.w3.org/2014/data-shapes/track/issues/133">ISSUE-133</a></li>
				<li><b>2016-04-10/16/18</b>: Updated text for <a href="http://www.w3.org/2014/data-shapes/track/issues/144">ISSUE-144</a></li>
				<li><b>2016-04-10</b>: Fixed SPARQL query of sh:minExclusive <a href="http://www.w3.org/2014/data-shapes/track/issues/145">ISSUE-145</a></li>
				<li><b>2016-04-08</b>: Updated the definition and use of sh:hasShape <a href="http://www.w3.org/2014/data-shapes/track/issues/131">ISSUE-131</a></li>
				<li><b>2016-04-08</b>: Renamed sh:notEquals to sh:disjoint <a href="http://www.w3.org/2014/data-shapes/track/issues/136">ISSUE-136</a></li>
				<li><b>2016-04-07</b>: Added section on Invalid Shapes Graphs for <a href="http://www.w3.org/2014/data-shapes/track/issues/134">ISSUE-134</a></li>
				<li><b>2016-03-25</b>: rearrange cleanup sections 2 and 4, better definition of shape validation</li>
				<li><b>2016-03-25</b>: entailment regime - fix the graph IRI issue</li>
				<li><b>2016-03-25</b>: $shapesGraph warnings</li>
				<li><b>2016-03-22</b>: Cleaned up generic mechanism to define constraint components applied to 3.1</li>
				<li><b>2016-03-21</b>: SHACL does not assume that the data graph is an RDF dataset</li>
				<li><b>2016-03-21</b>: updated some definitions for shapes, scopes and filters</li>
				<li><b>2016-03-21</b>: Re-organized the sections on the various constraint properties, introducing the term constraint component</li>
				<li><b>2016-03-21</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-03-14</b>: Added three new node kinds as resolved (<a href="http://www.w3.org/2014/data-shapes/track/issues/99">ISSUE-99</a>)</li>
				<li><b>2016-03-12</b>: Added issue warning regarding recursion</li>
				<li><b>2016-03-04</b>: Simplified the definition of sh:class (<a href="http://www.w3.org/2014/data-shapes/track/issues/99">ISSUE-99</a>)</li>
				<li><b>2016-02-24</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-02-19</b>: Clarified that support for <code>$shapesGraph</code> is optional (<a href="http://www.w3.org/2014/data-shapes/track/issues/47">ISSUE-47</a>)</li>
				<li><b>2016-02-19</b>: Clarified that the SHACL graph URI includes the # (<a href="http://www.w3.org/2014/data-shapes/track/issues/129">ISSUE-129</a>)</li>
				<li><b>2016-02-18</b>: Removed reference to the proposed class <code>sh:QCC</code>(<a href="http://www.w3.org/2014/data-shapes/track/issues/92">ISSUE-92</a>)</li>
				<li><b>2016-02-12</b>: Added a paragraph on the limits of the core vocabulary, highlighting how rdf:Lists can be handled by the extension mechanism (<a href="http://www.w3.org/2014/data-shapes/track/issues/119">ISSUE-119</a>)</li>
				<li><b>2016-02-10</b>: Added <code>sh:partition</code>. (<a href="http://www.w3.org/2014/data-shapes/track/issues/92">ISSUE-92</a>)</li>
				<li><b>2016-02-05</b>: Removed value type constraints on various constraint properties such as sh:class (<a href="http://www.w3.org/2014/data-shapes/track/issues/117">ISSUE-117</a>)</li>
				<li><b>2016-01-29</b>: Clarified that validation results must be based on the data graph only. (<a href="http://www.w3.org/2014/data-shapes/track/issues/118">ISSUE-118</a>)</li>
				<li><b>2016-01-25</b>: Clarified direction of property path. Remove comment about consistency. (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-22</b>: Switched closed shapes syntax to sh:closed (<a href="http://www.w3.org/2014/data-shapes/track/issues/115">ISSUE-115</a>)</li>
				<li><b>2016-01-21</b>: Limit definition of shapes that are also classes to the shapes graph (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-19</b>: Describe scoping of shapes that are also classes (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-18</b>: Stated starting point for recursion (<a href="http://www.w3.org/2014/data-shapes/track/issues/22">ISSUE-22</a>)</li>
				<li><b>2016-01-18</b>: Clarified the meaning of filter shapes (<a href="http://www.w3.org/2014/data-shapes/track/issues/49">ISSUE-49</a>)</li>
				<li><b>2016-01-11</b>: Deleted operations section (<a href="http://www.w3.org/2014/data-shapes/track/issues/108">ISSUE-108</a>)</li>
				<li><b>2016-01-11</b>: Added derived properties (<a href="http://www.w3.org/2014/data-shapes/track/issues/97">ISSUE-97</a>)</li>
				<li><b>2016-01-11</b>: Dropped sh:ShapeClass (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>), elaborated on possible sh:scopeClass rule</li>
				<li><b>2016-01-10</b>: Added sh:order (<a href="http://www.w3.org/2014/data-shapes/track/issues/100">ISSUE-100</a>) and sh:group (<a href="http://www.w3.org/2014/data-shapes/track/issues/114">ISSUE-114</a>)</li>
				<li><b>2016-01-10</b>: Introduced sh:datatypeIn and sh:classIn, deleted sh:text (<a href="http://www.w3.org/2014/data-shapes/track/issues/104">ISSUE-104</a>)</li>
				<li><b>2016-01-09</b>: Syntax simplifications: Switched to sh:not, sh:and, sh:or, sh:equals, sh:notEquals, sh:lessThan, sh:lessThanOrEquals (<a href="http://www.w3.org/2014/data-shapes/track/issues/103">ISSUE-103</a>)</li>
				<li><b>2015-12-02</b>: Fixed <a href="https://github.com/w3c/data-shapes/issues/9">minor mistake in spec - ex:unsinged</a>.</li>
				<li><b>2015-11-20</b>: Switched from rdfs:label/rdfs:comment at property constraints to sh:name/sh:description (ISSUE-112)</li>
				<li><b>2015-11-06</b>: Renamed sh:nodeShape to sh:scopeNode, clarified that its triples are expected in shapes graph (ISSUE-61)</li>
				<li><b>2015-10-30</b>: Deleted sh:cachable, removed the option for sh:sparql to be a query fragment in sh:scope</li>
				<li><b>2015-10-29</b>: Improved wording in the definition of sh:in.</li>
				<li><b>2015-10-28</b>: Separated definitions of sh:qualifiedMinCount and sh:qualifiedMaxCount</li>
				<li><b>2015-10-22</b>: Define sh:minLength, sh:maxLength, sh:qualifiedMinCount, and sh:qualifiedMaxCount without reference to default values</li>
				<li><b>2015-10-22</b>: Replaced ex:bornIn with ex:residentIn in Section 2.2</li>
				<li><b>2015-10-16</b>: Added sh:SPARQLConstraint and sh:SPARQLScope (part of ISSUE-98)</li>
				<li><b>2015-10-16</b>: Renamed sh:valueClass to sh:class, sh:allowedValues to sh:in, sh:directValueType to sh:directType (part of ISSUE-98)</li>
				<li><b>2015-10-15</b>: Define sh:minCount and sh:maxCount without reference to default values</li>
				<li><b>2015-10-15</b>: Use real-world names in examples 3, 4 and 5</li>
				<li><b>2015-10-15</b>: Changed SPARQL definition of sh:AllObjects, implementing resolution to ISSUE-90</li>
				<li><b>2015-10-09</b>: Added sh:flags and sh:uniqueLang</li>
				<li><b>2015-09-23</b>: Multiple minor stylistic edits and corrections</li>
				<li><b>2015-09-21</b>: Added button to show or hide SPARQL definitions (thanks to Simon)</li>
				<li><b>2015-09-18</b>: Deleted <code>sh:XorConstraint</code> as resolved, renamed <code>sh:Error</code> to <code>sh:Violation</code></li>
				<li><b>2015-09-17</b>: Added missing definition of <code>sh:class</code>, editorial changes, renamed sh:ClosedShape to sh:Closed, added sh:sourceTemplate</li>
				<li><b>2015-09-15</b>: Restructured Part 2, with new examples, integrated SPARQL binding and rewritten Operations section</li>
				<li><b>2015-09-14</b>: Added SPARQL definitions for each constraint type, added description of sh:hasShape function</li>
				<li><b>2015-09-11</b>: Restructured constraint section, cleaned up results vocabulary</li>
				<li><b>2015-09-10</b>: Added sh:shapesGraph property (<a href="http://www.w3.org/2014/data-shapes/track/issues/44">ISSUE-44</a>)</li>
				<li><b>2015-09-09</b>: Rewritten introduction, dropped Profile section, word-smithing on sh:class</li>
				<li><b>2015-09-04</b>: Applied resolution to <a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a></li>
				<li><b>2015-09-03</b>: Many editorial changes, restructured section 5 (scopes and filters) into section 2 (Shapes)</li>
				<li><b>2015-09-01</b>: Minor changes and clarifications</li>
				<li><b>2015-08-24</b>: Added section on sh:defaultValueType (<a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a>)</li>
				<li><b>2015-08-21</b>: Added support for validation functions (<a href="http://www.w3.org/2014/data-shapes/track/issues/79">ISSUE-79</a>)</li>
				<li><b>2015-08-14</b>:
					Added qualified cardinality restrictions (<a href="http://www.w3.org/2014/data-shapes/track/issues/72">ISSUE-72</a>),
					added sh:ignoredProperties to sh:ClosedShape (<a href="http://www.w3.org/2014/data-shapes/track/issues/58">ISSUE-58</a>),
					editorial improvements to terminology, added Glossary to appendix
				</li>
				<li><b>2015-08-07</b>: Extended the use of sh:severity to template constraints, split sh:source into sh:sourceConstraint and sh:sourceShape, renamed sh:root to sh:focusNode</li>
				<li><b>2015-07-31</b>: Added sh:text as the union of xsd:string and rdf:langString</li>
				<li><b>2015-07-30</b>: Integrated sh:InversePropertyScope and sh:AllObjects</li>
				<li><b>2015-07-24</b>: Added details of XSD-like facets (<a href="http://www.w3.org/2014/data-shapes/track/issues/64">ISSUE-64</a>)</li>
				<li>
					<b>2015-07-17</b>: Rewritten scope and filter mechanism (<a href="http://www.w3.org/2014/data-shapes/track/issues/62">ISSUE-62</a>),
					suggestion for generalized execution language interface (<a href="http://www.w3.org/2014/data-shapes/track/issues/60">ISSUE-60</a>)
				</li>
				<li><b>2015-07-13</b>: Replaced Appendix with references to SHACL-REF document</li>
				<li><b>2015-07-03</b>: Editorial fixes, started revision history</li>
			</ul>
		</section>
		<section class="introductory">
			<h2>Document Outline</h2>
			<p>
				The introduction includes a <a href="#terminology">Terminology</a> section that may also serve as a quick overview of the language.
			</p>
			<p>
				The sections 2 - 4 cover the <a>SHACL Core</a> language and may be read independently from the later sections.
			</p>
			<p>
				The sections 5 onwards are about the additional features that <a>SHACL Full</a> has in addition to the Core language.
				These advanced features include SPARQL-based constraint components, targets and functions.
				A summary of these advanced features can be found in the <a href="#optional-features">Appendix</a>.
			</p>
			<p>
				The examples in this document use Turtle [[!turtle]].
				The reader should be familiar with basic RDF concepts [[!rdf11-concepts]] such as triples and, for the advanced concepts of SHACL, with SPARQL [[!sparql11-overview]].			<p>
			</p>
		</section>


	
		<section id="introduction">
			<h2>Introduction</h2>
			<p>
				This document specifies SHACL (Shapes Constraint Language), a language for describing and validating RDF graphs.
				This section introduces SHACL with an overview of the key terminology and an example to illustrate basic concepts.
			</p>
			<section id="terminology">
				<h3>Terminology</h3>
				<p>
					Throughout this document, the following terminology is used.
				</p>
				<div class="def" id="rdf-terminology">
					<div class="term-def-header">Basic RDF Terminology</div>
					<div>
						This document uses the terms 
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph"><dfn data-lt="graph|graphs|RDF graphs">RDF graph</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple"><dfn data-lt="triple|triples">RDF triple</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri"><dfn data-lt="IRI|IRIs">IRI</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal"><dfn data-lt="literal|literals">literal</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node"><dfn data-lt="blank node|blank nodes">blank node</dfn></a>,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-node"><dfn data-lt="node|nodes">node</dfn></a> of an RDF graph,
						<a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-term"><dfn>RDF term</dfn></a>, and
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-subject"><dfn data-lt="subject|subjects">subject</dfn></a>,
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-predicate"><dfn data-lt="predicate|predicates">predicate</dfn></a>, and
						<a href="https://www.w3.org/TR/rdf11-concepts/#dfn-object"><dfn data-lt="object|objects">object</dfn></a> of RDF triples
						as defined in RDF 1.1 Concepts and Abstract Syntax [[!rdf11-concepts]].
						SHACL can be used with RDF graphs that are obtained by any means, e.g. from the file system, HTTP requests, or <a href="http://www.w3.org/TR/rdf11-concepts/#section-dataset">RDF datasets</a>.
						SHACL makes no assumptions about whether a graph contains triples that are entailed from the graph under any RDF entailment regime.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Property Values and Paths</div>
					<div>
						The <dfn data-lt="value|property value|property values">values</dfn> of (or for) a property <code>p</code> for a <a>node</a> <code>n</code> in an <a>RDF graph</a> are the
						<a>objects</a> of the <a>triples</a> in the <a>graph</a> that have <code>n</code> as <a>subject</a> and <code>p</code> as <a>predicate</a>.
						A <dfn data-lt="path|property paths">property path</dfn> is a possible route in a <a>graph</a> between two graph <a>nodes</a>.
						SHACL supports a subset of the property path syntax from <a href="https://www.w3.org/TR/sparql11-query/#pp-language">SPARQL 1.1</a>,
						including inverse paths and sequences.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Subclass, SHACL superclass</div>
					<div>
						A <a>node</a> <code>Sub</code> in an <a>RDF graph</a> is a <dfn data-lt="subclasses|subclass|SHACL subclasses">SHACL subclass</dfn> of another <a>node</a> <code>Super</code>
						in the <a>graph</a> if there is a sequence of <a>triples</a> in the <a>graph</a> each with predicate <code>rdfs:subClassOf</code> such that the <a>subject</a> of the first <a>triple</a> is <code>Sub</code>,
						the <a>object</a> of the last triple is <code>Super</code>, and the <a>object</a> of each <a>triple</a> except the last is the <a>subject</a> of the next.
						If <code>Sub</code> is a <a>SHACL subclass</a> of <code>Super</code> in an <a>RDF graph</a> then <code>Super</code>
						is a <dfn data-lt="superclass|superclasses|SHACL superclasses|">SHACL superclass</dfn> of <code>Sub</code> in the <a>graph</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Type</div>
					<div>
						The <dfn data-lt="type|types|SHACL type">SHACL types</dfn> of a <a>node</a> in an <a>RDF graph</a> are its <a>values</a> for <code>rdf:type</code> in the
						<a>graph</a> as well as the <a>SHACL superclasses</a> of these <a>values</a> in the <a>graph</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Class</div>
					<div>
						<a>Nodes</a> in an <a>RDF graph</a> that might be subclasses, superclasses, or types of <a>nodes</a> in the <a>graph</a> are often referred to as <dfn data-lt="class|classes|SHACL classes">SHACL class</dfn>.
						SHACL makes no assumption whether a SHACL class has any particular <a>value</a> for <code>rdf:type</code> in the <a>graph</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Instance</div>
					<div>
						A <a>node</a> in an <a>RDF graph</a> is a <dfn data-lt="SHACL instance|SHACL instances">SHACL instance</dfn> of a <a>SHACL class</a> in the <a>graph</a>
						if one of its <a>SHACL types</a> is the given <a>class</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Data Graph, Shapes Graph, Validation, Report, Result, Violation, Failure</div>
					<div>
						SHACL defines what it means for an <a>RDF graph</a>, referred to as the <dfn data-lt="data graphs">data graph</dfn>,
						to <dfn data-lt="validation|validates|validated">validate</dfn> against an <a>RDF graph</a> containing <a>shapes</a>, referred to as the <dfn data-lt="shapes graphs">shapes graph</dfn>.
						The result of validation is a <dfn data-lt="validation report|report">validation report</dfn> including
						<dfn data-lt="validation result|result">validation results</dfn> such as informational results, warnings and violations.
						Validation may also result in a <dfn>failure</dfn>, which is reported by a SHACL Full processor to indicate that a request could not be handled.
						Failures are not represented as part of the validation report, but through implementation-specific channels.
						Validation of a <a>shapes graph</a> against a <a>data graph</a> involves validating each <a>shape</a> in the <a>shapes graph</a> against the <a>data graph</a>.
						A <a>node</a> in a <a>data graph</a> is said to validate against a <a>shape</a> if validation of that <a>node</a>
						against the <a>shape</a> neither produces any <a>validation results</a> nor results in a <a>failure</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Shape</div>
					<div>
						A <dfn data-lt="shape|shapes">shape</dfn> is represented by a <a>node</a> in a <a>shapes graph</a> that is typically a <a>SHACL instance</a> of <code>sh:Shape</code>.
						A shape provides a collection of <a>targets</a>, <a>filters</a>, <a>constraints</a> and <a>parameters</a> of <a>constraint components</a> that specify how a <a>data graph</a> is
						validated against the shape.
						Shapes can also provide non-validating information, such as labels and comments.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Focus Node</div>
					<div>
						A <a>node</a> in the <a>data graph</a> that is validated against a <a>shape</a> is called a <dfn data-lt="focus node|focus nodes">focus node</dfn>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Target</div>
					<div>
						A <dfn data-lt="target|targets">target</dfn> relates a <a>shape</a> with its <a>focus nodes</a>.
						SHACL provides several different kinds of targets, most notably the <a>SHACL instances</a> of a given <a>class</a>,
						specifically enumerated <a>nodes</a>, or all <a>objects</a> or <a>subjects</a> of a given <a>predicate</a>.
						Targets are represented by triples in the <a>shapes graph</a>, for example using the property <code>sh:targetClass</code>.
						Validating a <a>data graph</a> against a <a>shape</a> involves validating the target nodes for all targets of the shape.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Filter</div>
					<div>
						A <dfn data-lt="filter shape|filter shapes|filters">filter</dfn> is a <a>shape</a> in the <a>shapes graph</a> that limits the <a>nodes</a> that are
						validated against the constraints of another shape.
						Only those <a>nodes</a> that validate against all the filters of a shape are validated against its constraints.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Constraint</div>
					<div>
						A <dfn data-lt="constraint|constraints">constraint</dfn> is a <a>node</a> in the <a>shapes graph</a> that determines how to validate
						<a>focus nodes</a> based on the <a>values</a> of properties and other characteristics of the <a>node</a>.
						Constraints can, for example, require that a focus node be an IRI or that a focus node has a particular value for a property and also a minimum number of values for the property.
						Constraints that are about a particular property or <a>path</a> and its <a>values</a> for the focus node are called <dfn data-lt="property constraint">property constraints</dfn>.
						Constraints that are about the <a>focus node</a> itself are called <dfn>focus node constraints</dfn>.
						Constraints can also have <dfn data-lt="non-validating property">non-validating properties</dfn> (such as names and default values) that do not lead to <a>validation results</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">Constraint Component, Parameter</div>
					<div>
						A <dfn data-lt="constraint component|constraint components|components|component">constraint component</dfn> represents a part of a <a>constraint</a> that is determined
						by the <a>values</a> of one or more properties.
						These properties are called <dfn data-lt="parameter">parameters</dfn>.
						For example, <code>sh:minCount</code> is a parameter for the component that checks whether the <a>focus node</a> has at least a minimum number of <a>values</a> for a
						particular property.
						Validating a <a>node</a> against a <a>constraint</a> involves validating the node against each of its <a>components</a>.
					</div>
				</div>
				<div class="def">
					<div class="term-def-header">SHACL Code and SHACL Full</div>
					<div>
						The SHACL specification is divided into two dialects.
						<dfn>SHACL Core</dfn> consists of frequently needed features for the representation of shapes, constraints and targets.
						All SHACL implementations must at least cover the Core.
						<dfn>SHACL Full</dfn> consists of all features of SHACL Core plus a collection of advanced features
						including SPARQL-based constraints, extension mechanisms to define new constraint and target types,
						user-defined functions and derived properties.
					</div>
				</div>

			</section>

			<section id="conventions">
				<h3>Document Conventions</h3>
				<p>
					Within this document, the following namespace prefix bindings are used:
				</p>
				<table class="term-table">
					<tr>
						<th>Prefix</th>
						<th>Namespace</th>
					</tr>
					<tr>
						<td><code>rdf:</code></td>
						<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
					</tr>
					<tr>
						<td><code>rdfs:</code></td>
						<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
					</tr>
					<tr>
						<td><code>sh:</code></td>
						<td><code>http://www.w3.org/ns/shacl#</code></td>
					</tr>
					<tr>
						<td><code>xsd:</code></td>
						<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
					</tr>
					<tr>
						<td><code>ex:</code></td>
						<td><code>http://example.com/ns#</code></td>
					</tr>
				</table>
				<p>
					Note that the URI of the graph defining the SHACL vocabulary itself is equivalent to
					the namespace above, i.e. it includes the <code>#</code>.
					References to the SHACL vocabulary, e.g. via <code>owl:imports</code> SHOULD include the <code>#</code>. 
				</p>
				<p>
					Throughout the document, color-coded boxes containing RDF graphs in Turtle will appear.
					These fragments of Turtle documents use the prefix bindings given above.
				</p>
				<pre class="example-shapes">
# This box represents an input shapes graph

# Triples that can be omitted are marked as grey e.g.
<span class="triple-can-be-skipped">&lt;s&gt; &lt;p&gt; &lt;o&gt; .</span></pre>

				<pre class="example-data">
# This box represents an input data graph.
# When highlighting is used in the examples:

# Elements highlighted in blue are <a>focus nodes</a> that are
# selected by some <a>target</a> of a <a>shape</a> under discussion
# and validate against the shape's <a>filters</a>, if any.
<span class="focus-node-selected">ex:Bob</span> a ex:Person .

# Elements highlighted in red are focus nodes that fail <a href="#validation">validation</a>
<span class="focus-node-error">ex:Alice</span> a ex:Person .</pre>

				<pre class="example-results">
# This box represents an output results graph</pre>

				<p>
					SHACL Definitions appear in blue boxes:
				</p>
				<div class="def def-sparql">
					<div class="def-header">SPARQL or TEXTUAL DEFINITIONS</div>
<pre class="def-sparql-body">
# This box contains SPARQL or textual definitions. </pre>
				</div>

			</section>

			<section id="conformance">
				<p>
					<span class="todo">TODO: needs more work.</span>
				</p>
				<p>
					This specification describes conformance criteria for:
				</p>
				<ul>
					<li><strong>SHACL Core</strong> language, also referred as just <strong>SHACL</strong>, as described in Part A of this document</li>
					<li><strong>SHACL Full</strong> language that extends SHACL Core with constructs described in Part B of this document</li>
					<li>SHACL Shapes Graphs</li>
					<li>Validation of an RDF node against a shape</li>
					<li>Validation of a data graph against a shapes graph</li>
					<li><strong>SHACL Core processors</strong> as processors that support validation with the SHACL Core Language</li>
					<li><strong>SHACL Full processors</strong> as processors that support validation with the SHACL Full Language</li>
				</ul>

				<p>
					<span class="todo">TODO: link to test cases.</span>
				</p>
			</section>

			<section>
				<h3>SHACL Example</h3>
				<p>
					The following example <a>data graph</a> contains eight total <a>nodes</a>, out of which three <a>nodes</a> are <a>SHACL instances</a> of the <a>class</a> <code>ex:Person</code>.
				</p>
				<pre class="example-data">
ex:Alice
	a ex:Person ;
	ex:child ex:Calvin ;
	ex:ssn "987-65-432A" .
  
ex:Bob
	a ex:Person ;
	ex:child ex:Calvin ;
	ex:ssn "123-45-6789" ;
	ex:ssn "124-35-6789" .
  
ex:Calvin
	a ex:Person ;
	ex:school ex:TrinityAnglicanSchool .</pre>
				<p>
					SHACL can be used to define the following example <a>constraints</a>:
				<p>
				<ul>
					<li>
						A <a>SHACL instance</a> of <code>ex:Person</code> may have at most one <a>value</a> for the property <code>ex:ssn</code>,
						and this <a>value</a> must be a <a>literal</a> with the datatype <code>xsd:string</code> that matches
						a specified regular expression.
					</li>
					<li>
						A <a>SHACL instance</a> of <code>ex:Person</code> may have unlimited <a>values</a> for the property <code>ex:child</code>,
						and these <a>values</a> must be <a>IRIs</a> and they must be <a>SHACL instances</a> of <code>ex:Person</code>.
					</li>
					<li>
						A person's parents are represented using the property <code>ex:child</code> in the inverse direction.
						A <a>SHACL instance</a> of <code>ex:Person</code> may have at most 2 parents, i.e. may be the <a>object</a> of at most two <a>triples</a>
						where the <a>predicate</a> is <code>ex:child</code>.
					</li>
					<li>
						A <a>SHACL instance</a> of <code>ex:Person</code> may not have <a>values</a> for any other property apart from
						<code>ex:ssn</code>, <code>ex:child</code> and <code>rdf:type</code>.
					</li>
				</ul>
				<p>
					The <a>constraints</a> above can be represented using the following <a>shapes graph</a>:
				</p>
				<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:targetClass ex:Person ;    # Applies to all persons
	sh:property [
		sh:predicate ex:ssn ;     # Constrains the values of the ex:ssn property
		sh:maxCount 1 ;
		sh:datatype xsd:string ;
		sh:pattern "^\\d{3}-\\d{2}-\\d{4}$" ;
	] ;
	sh:property [
		sh:predicate ex:child ;
		sh:class ex:Person ;
		sh:nodeKind sh:IRI ;
	] ;
	sh:property [
		rdfs:comment "A person's parents are represented via ex:child used in the inverse direction." ;
		sh:path [ sh:inversePath ex:child ] ;
		sh:name "parent" ;
		sh:maxCount 2 ;
	] ;
	sh:closed true ;
	sh:ignoredProperties ( rdf:type ) .</pre>
				<p>
					We can use the shape definition above to skim through some of the key terminology used by SHACL.
					The <a>focus nodes</a> for the <a>shape</a> <code>ex:PersonShape</code> are all <a>SHACL instances</a> of the <a>class</a> <code>ex:Person</code>.
					These <a>focus nodes</a> are the <a>targets</a> of the <a>shape</a> and are defined using the property <code>sh:targetClass</code>.
					The <a>shape</a> has three <a>property constraints</a>, linked to the shape using the property <code>sh:property</code>,
					one of which uses a <a>path</a> expression.
					The <a>shape</a> furthermore defines a constraint on the <a>focus nodes</a> themselves using the <a>parameters</a> <code>sh:closed</code> and <code>sh:ignoredProperties</code>.
				</p>
				<p>
					Some of the <a>property constraints</a> specify multiple <a>constraint components</a> in order to
					restrict multiple aspects of the <a>property values</a>.
					For example, in the <a>property constraint</a> for <code>ex:ssn</code>, three <a>constraint components</a> are used.
					These <a>constraint components</a> are identified by their <a>parameters</a> <code>sh:datatype</code>, <code>sh:pattern</code> and <code>sh:maxCount</code>.
					For each <a>focus node</a> the <a>property values</a> of <code>ex:ssn</code> will be validated against all three components.
					The constraint on the inverse property values of <code>sh:child</code> has only one <a>constraint component</a> identified by the <code>sh:maxCount</code> <a>parameter</a>.
					Note that this <a>constraint</a> uses the <a>non-validating property</a> <code>sh:name</code>
					to suggest a human-readable name for the property when used in the inverse direction.
				</p>
				<p>
					SHACL <a>validation</a> based on the provided <a>data graph</a> and <a>shapes graph</a> would produce the following <a>validation results</a>:
				</p>
				<pre class="example-results">
[	a sh:ValidationResult ;
	sh:sourceConstraintComponent sh:RegexConstraintComponent ;
	sh:sourceShape ex:PersonShape ;
	sh:focusNode ex:Alice ;
	sh:path ex:ssn ;
	sh:value "987-65-432A" ;
	sh:severity sh:Violation ;
] ;
[	a sh:ValidationResult ;
	sh:sourceConstraintComponent sh:MaxCountConstraintComponent ;
	sh:sourceShape ex:PersonShape ;
	sh:focusNode ex:Bob ;
	sh:path ex:ssn ;
	sh:severity sh:Violation ;
] ;
[	a sh:ValidationResult ;
	sh:sourceConstraintComponent sh:ClosedConstraintComponent ;
	sh:sourceShape ex:PersonShape ;
	sh:focusNode ex:Calvin ;
	sh:path ex:school ;
	sh:value ex:TrinityAnglicanSchool ;
	sh:severity sh:Violation ;
] .</pre>
				<p>
					The first <a>validation result</a> is produced because <code>ex:Alice</code> has a <a>value</a> for <code>ex:ssn</code>
					that does not match the regular expression specified by the property <code>sh:regex</code>.
					The second <a>validation result</a> is produced because <code>ex:Bob</code> has more than the permitted number of <a>values</a>
					for the property <code>ex:ssn</code> as specified by the <code>sh:maxCount</code> of 1.
					The third <a>validation result</a> is produced because the <a>shape</a> <code>ex:PersonShape</code> has the	the property <code>sh:closed</code> set to <code>true</code>
					but <code>ex:Calvin</code> uses the property <code>ex:school</code> which is neither one of the predicates from any of the 
					<a>property constraints</a> at the shape, nor one of the properties listed using <code>sh:ignoredProperties</code>.
				</p>
			</section>
			
			<section id="shacl-rdfs">
				<h3>Relationship between SHACL and RDFS inferencing</h3>

				<!--p>
					SHACL uses RDF and RDFS vocabulary (in particular <code>rdf:type</code>, <code>rdfs:Class</code>, <code>rdfs:subClassOf</code>, <code>rdf:Property</code>, <code>rdf:List</code>,
					<code>rdf:langLiteral</code>, and <code>rdfs:Resource</code>) and concepts (notably classes, instances, and subclasses).
					However, SHACL does not always use this vocabulary or these concepts in exactly the way that they are formally defined in RDF and RDFS [[!rdf11-mt]].				
				</p>
				<p>
					When determining subclass and instance relationships SHACL only uses the transitive closure of <code>rdfs:subClassOf</code>,
					without requiring in particular the RDF axioms, the RDFS meaning of <code>rdfs:Resource</code>, the reflexivity of <code>rdfs:subClassOf</code>,
					the effect of subproperties of <code>rdfs:subClassOf</code>, and the effects of <code>rdfs:domain</code> and <code>rdfs:range</code>.
				</p>
				<p>
					Note that <code>rdfs:subClassOf</code> transitivity is only used when SHACL explicitly determines type and subclass relationships in the shapes graph and the data.
					Elsewhere, only triples that are explicitly present in the shapes graph or the data are considered.
					For example, SHACL property constraints on <code>rdf:type</code> and <code>rdfs:subClassOf</code> only utilize triples that are explicitly in the data.
					Similarly, subproperties of <code>rdfs:label</code> and <code>rdfs:commment</code> and subclasses of <code>rdf:List</code> are not recognized in the shapes graph.
				</p>
				<p>
					These design decisions mean that SHACL processors do not have to natively support full RDFS inferencing. -->
				<p>
					SHACL uses the RDF and RDFS vocabularies, but full RDFS inferencing is not required.
					However, SHACL processors MUST identify <a>SHACL instances</a> of a class both in the <a>data graph</a> and the <a>shapes graph</a> without mutating either graph during the <a href="#validation">validation process</a>.
					Furthermore, SHACL processors may operate on RDF graphs that include entailments - either pre-computed before being submitted to a SHACL processor or performed on the fly as part of SHACL processing.
					To support processing of entailments, SHACL includes the property <a href="#entailment"><code>sh:entailment</code></a> to indicate what inferencing is required by a given <a>shapes graph</a>.
					SHACL implementations may, but are not required to, support entailment regimes.
				</p>
			</section>
			
			<section id="shacl-sparql">
				<h3>Relationship between SHACL and SPARQL</h3>
				<p>
					This specification uses parts of SPARQL 1.1 in the normative definition of the semantics of the SHACL Core <a>constraints</a> and <a>targets</a>.
					However, SPARQL is not required for the implementation of the SHACL Core language.
				</p>
				<p>
					SPARQL variables using the <code>$</code> marker represent external values that must be <a>pre-bound</a> or (in the case of <code>$PATH</code>) substituted in the SPARQL query before execution.
				</p>
				<p>
					In some places, the specification assumes that the provided SPARQL engines are preserving the identity of <a>blank nodes</a>,
					so that repeated invocations of queries consistently identify and communicate the same <a>blank nodes</a>.
				</p>
				<p>
					The definition of some <a>constraints</a> requires or is simplified through access to the <a>shapes graph</a> during query execution.
					SHACL Full processors MAY <a>pre-bind</a> the variable <code>shapesGraph</code> to provide access to the <a>shapes graph</a>.
					Access to the <a>shapes graph</a> is not a requirement for supporting the SHACL Core language.
					The variable <code>shapesGraph</code> can also be used in user-defined <a href="#sparql-constraints">SPARQL constraints</a> and <a href="#constraint-components">SPARQL-based constraint components</a>.
					However, such <a>constraints</a> may not be interoperable across different SHACL Full processors or not applicable to remote RDF datasets.
				</p>
				<p>
					Some SHACL <a>constraints</a> are defined with the use of the <a href="#hasShape"><code>sh:hasShape</code></a> function.
					SHACL additionally introduces mechanisms to define <a>constraints</a>, <a>targets</a>, <a href="#derivedValues">derived values</a> and new functions in SPARQL.
					Implementations that cover only the SHACL Core features are not required to implement these mechanisms or the <code>sh:hasShape</code> function.
				</p>
				<div class="syntaxmenu">
					<p>The button below can be used to show or hide the SPARQL definitions.</p>
					<form>
						<p>
							<input id="hide-sparql" onclick="$('.def-sparql').css('display', 'none'); $('#hide-sparql').css('display', 'none'); $('#show-sparql').css('display', '');" type="button" value="Hide SPARQL Definitions" />
							<input id="show-sparql" onclick="$('.def-sparql').css('display', '');     $('#show-sparql').css('display', 'none'); $('#hide-sparql').css('display', '');" style="display:none" type="button" value="Show SPARQL Definitions" />
						</p>
					</form>
				</div>
			</section>
			
		</section>
		
		<div style="padding-top: 30px"> <!-- ALH: really??? -->
			<h1 id="part1" style="font-size: 160%; font-weight: bold">Part 1: SHACL Core</h1>
		</div>

		<section id="shapes">
			<h2>Shapes</h2>
			<p>
				<a>Shapes</a> are <a>SHACL instances</a> of <code>sh:Shape</code> and define <a>constraints</a> that a set of <a>focus nodes</a> can be validated against.
				The set of <a>focus nodes</a> for a <a>shape</a> may be defined explicitly in a <a>shape</a> using <a>targets</a> and <a>filters</a>.
				The <a>focus nodes</a> may also be determined as part of the <a>validation</a> of <a>constraints</a> that include references to <a>shapes</a>
				using properties such as <a href="#ShapeConstraintComponent"><code>sh:shape</code></a> and <a href="#OrConstraintComponent"><code>sh:or</code></a>.
				<!--Shape targets define the selection criteria for the targetted nodes.
				Shapes with targets MAY additionally provide <a>filters</a>.
				Filter shapes further refine the focus nodes to the ones that conform to a set of filter shapes.-->

				Shapes can also provide <a href="#nonValidation">non-validating information</a>, such as labels and names.

				The following figure depicts a workflow of the targeting and filtering process.
				<!-- SHACL <a>validation</a> engines MAY alter the order of the depicted steps as long as the returned <a>validation results</a> are correct.-->
				<!--DK: TODO check term correct -->

			</p>
			<figure>
				<img src="images/SHACL-Validation-Process.png" />
				<figcaption>Illustration of the targeting and filtering process</figcaption>
			</figure>

			<section id="targets">
				<h3>Targets</h3>
				<p>
					Targets specify which <a>nodes</a> in the <a>data graph</a> are validated against a <a>shape</a>.
					While targets define the starting points of the validation process,
					some shapes may validate
					a) less target nodes when a shapes defines <a>filters</a> or
					b) additional nodes against different shapes, for example when referenced via <a href="#ShapeConstraintComponent">sh:shape</a> and <a href="#OrConstraintComponent">sh:or</a>.

				</p>
				<p>
					SHACL Core includes four target types:
					<a href="#targetNode">node targets</a>,
					<a href="#targetClass">class-based targets</a>,
					<a href="#targetSubjectsOf">subjects-of targets</a>, and
					<a href="#targetObjectsOf">objects-of targets</a>.
				</p>
				<p>
					The SHACL Full language additionally defines an advanced <a href="#sparql-targets">general target mechanism based on SPARQL</a>.
				</p>
				<p>
					When multiple <a>targets</a> are provided in a <a>shape</a>, the target of a shape is the union of all nodes produced by these individual targets.
					Nodes specified by targets are not required to exist in the <a>data graph</a>.
				</p>
				
				<section id="targetNode">
					<h4>Node targets (sh:targetNode)</h4>
					<p>
						A <dfn>node target</dfn> is defined with the <code>sh:targetNode</code> predicate.
						The <a>values</a> of <code>sh:targetNode</code> can be <a>IRIs</a> or <a>literals</a>.
						Each value of a node target defines a node to validate in the data graph.
					</p>

					<p>
						With the example data below, only <code>ex:Alice</code> is the target of the provided shape:
					</p>
					<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:targetNode ex:Alice .</pre>

					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
ex:Bob a ex:Person .</pre>

					<p class="def-sparql">
						The following SPARQL query specifies the semantics of node targets.
						The variable <code>targetNode</code> is assumed to be <a href="#pre-binding">pre-bound</a> to the given value of <code>sh:targetNode</code>.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	BIND ($targetNode AS ?this)
}</pre>
					</div>
				</section>
				
				<section id="targetClass">
					<h4>Class-based Targets (sh:targetClass)</h4>
					<p>
						A <dfn>class target</dfn> is defined with the <code>sh:targetClass</code> predicate.
						Each value of <code>sh:targetClass</code> must be an <a>IRI</a> that is expected to be a <a>SHACL class</a>.
						For every value <code>c</code> of a class target, all <a>SHACL instances</a> of <code>c</code> in the data graph are validated
						against the <a>subject</a> of the <code>sh:targetClass</code> triple.
					</p>

					<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:targetClass ex:Person .</pre>

					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
<span class="focus-node-selected">ex:Bob</span> a ex:Person .
ex:NewYork a ex:Place .</pre>
					<p>
						In this example, only <code>ex:Alice</code> and <code>ex:Bob</code> are validated.
						Note that, according to the <a>SHACL instance</a> definition, all the <code>rdfs:subClassOf</code> declarations needed to walk the class hierarchy must exist in the <a>data graph</a>.
						However, the <code>ex:Person a rdfs:Class</code> triple is not required to exist in either graphs.
					</p>
					<p>
						In the following example, the selected target node is only <code>ex:Who</code>.
					</p>
					<pre class="example-data">
ex:Doctor rdfs:subClassOf ex:Person .
<span class="focus-node-selected">ex:Who</span> a ex:Doctor .
ex:House a ex:Nephrologist .</pre>

					<p class="def-sparql">
						The following SPARQL query specifies the semantics of class targets.
						The variable <code>targetClass</code> is assumed to be <a href="#pre-binding">pre-bound</a> to the given value of <code>sh:targetClass</code>.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?this rdf:type/rdfs:subClassOf* $targetClass
}</pre>
					</div>

					<section id="implicit-targetClass">
						<h4>Implicit Class Targets</h4>
						<p>
							When, in the <a>shapes graph</a>, a <a>shape</a> is a <a>SHACL instance</a> of both <code>sh:Shape</code> and <code>rdfs:Class</code>
							then the <a>shape</a> is a <a>class target</a> of itself.
						</p>
						<pre class="example-shapes">
ex:Person
	<b>a rdfs:Class</b>, sh:Shape .</pre>
						<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .</pre>
						<p>
							In this example, only <code>ex:Alice</code> is validated, because it is a <a>SHACL instance</a> of
							<code>ex:Person</code> which is both a class and a shape in the <a>shapes graph</a>.
						</p>
					</section>
				</section>
				
				<section id="targetSubjectsOf">
					<h5>Subjects-of targets (sh:targetSubjectsOf)</h5>
					<p>
						A <dfn>subjects-of target</dfn> is defined with the predicate <code>sh:targetSubjectsOf</code>,
						the <a>values</a> of which must be <a>IRIs</a>.
						For every value <code>p</code> of such a target, the validated nodes are defined as
						the set of <a>subjects</a> in the <a>data graph</a> that appear in a <a>triple</a> with <code>p</code> as a <a>predicate</a>.
					</p>
					<p>
						In other words, this type of target can be used to state that a shape applies to all nodes in the <a>data graph</a>
						that have at least one <a>value</a> of the given property.
					</p>

					<pre class="example-shapes">
ex:TargetSubjectsOfExampleShape
	a sh:Shape ;
	sh:targetSubjectsOf ex:knows .</pre>
					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> ex:knows ex:Bob .
ex:Bob ex:livesIn ex:NewYork .</pre>
					<p>
						In the example above, only <code>ex:Alice</code> is validated against the given shape,
						because it is the <a>subject</a> of a <a>triple</a> that has <code>ex:knows</code> as its <a>predicate</a>.
					</p>

					<p class="def-sparql">
						The following SPARQL query specifies the semantics of subjects-of targets.
						The variable <code>targetSubjectsOf</code> is assumed to be <a href="#pre-binding">pre-bound</a> to the given value of <code>sh:targetSubjectsOf</code>.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?this $targetSubjectsOf ?any .
}</pre>
					</div>
				</section>
				
				<section id="targetObjectsOf">
					<h5>Objects-of targets (sh:targetObjectsOf)</h5>
					<p>
						An <dfn>objects-of target</dfn> is defined with the predicate <code>sh:targetObjectsOf</code>,
						the <a>values</a> of which must be <a>IRIs</a>.
						For every value <code>p</code> of such a target, the validated nodes are defined as
						the set of <a>objects</a> in the <a>data graph</a> that appear in a <a>triple</a> with <code>p</code> as a <a>predicate</a>.
					</p>

					<pre class="example-shapes">
ex:TargetObjectsOfExampleShape
	a sh:Shape ;
	sh:targetObjectsOf ex:knows .</pre>
					<pre class="example-data">
ex:Alice ex:knows <span class="focus-node-selected">ex:Bob</span> .
ex:Bob ex:livesIn ex:NewYork .</pre>
					<p>
						In the example above, only <code>ex:Bob</code> is validated against the given shape,
						because it is the <a>object</a> of a <a>triple</a> that has <code>ex:knows</code> as its <a>predicate</a>.
					</p>

					<p class="def-sparql">
						The following SPARQL query specifies the semantics of objects-of targets.
						The variable <code>targetObjectsOf</code> is assumed to be <a href="#pre-binding">pre-bound</a> to the given value of <code>sh:targetObjectsOf</code>.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?any $targetObjectsOf ?this .
}</pre>
					</div>
				</section>
			</section>
			
			<section id="filterShape">
				<h3>Filter Shapes</h3>
				<p>
					A <a>filter</a> is a <a>shape</a> in a <a>shapes graph</a> that limits the nodes that are validated against a given <a>constraint</a> or <a>shape</a>.
					Only those nodes that validate against all the filters are validated.
					A filter is specified with the <code>sh:filterShape</code> predicate.
				</p>
				<p>
					The following example states that the <code>sh:minCount</code> constraint on <code>ex:email</code> is filtered to include only <a>SHACL instances</a> of <code>ex:Person</code> that are <code>ex:member</code>s of <code>ex:W3c</code>.
				</p>
				<pre class="example-shapes">
ex:ExampleFilteredShape
	a sh:Shape ;
	sh:targetClass ex:Person ;
	sh:filterShape [
		<span style="color: grey;">a sh:Shape ; # Optional triple</span>
		sh:property [
			sh:predicate ex:member ;
			sh:hasValue ex:W3c ;
		]
	] ;
	sh:property [
		sh:predicate ex:email ;
		sh:minCount 1 ;
	] .</pre>

<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person ;
	ex:member ex:W3c ;
	ex:email &lt;mailto:alice@example.org&gt; .
<span class="focus-node-selected">ex:John</span> a ex:Person ;
	ex:member ex:W3c .
ex:Bob a ex:Person ;
	ex:member ex:Acme .</pre>

				<pre class="example-results">
[  a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:John ;
	sh:path ex:email ;
	sh:message "sh:minCount for ex:email is '1'." ;
	sh:sourceConstraintComponent sh:MinCountConstraintComponent ;
	sh:sourceShape ex:ExampleFilteredShape ; 
] . </pre>

				<p>
					The following example shows a <code>sh:filterShape</code> that is defined on a specific <a>property constraint</a>, instead of the whole <a>shape</a>.
					In this scenario, the <code>sh:minCount</code> constraint is only applied to persons that are also member of <code>ex:W3c</code>.
				</p>

				<pre class="example-shapes">
ex:FilteredExampleShape
	a sh:Shape ;
	sh:targetClass ex:Person ;
	sh:property [
		sh:predicate ex:email ;
		sh:minCount 1 ;
		sh:filterShape [
			sh:property [
				sh:predicate ex:member ;
				sh:hasValue ex:W3c ;
			]
		] ;
	] .
</pre>
				<p>
					Filter shapes MUST be evaluated before validating the associated shapes or constraints.
					This includes scenarios such as <a href="#ShapeConstraintComponent"><code>sh:shape</code></a> where a shape is explicitly referenced by another constraint.
					However, during the validation of a shape referenced via <code>sh:shape</code>, the declared <a>targets</a> of these shapes are not used to limit the set of focus nodes.
				</p>
				<!-- span class="todo">TODO: say anything about filters and severities?</span><br/
				HK: What would that potentially be? -->
			</section>
			
			<section id="shape-constraints">
				<h3>Constraints</h3>
				<p>
					Constraints are defined within a shape and <code>sh:Constraint</code> is the <a>SHACL superclass</a> of all constraint types.
					The SHACL Core language defines two types of constraints:
					a) constraints about a particular property or <a>path</a> and its <a>values</a> for the focus node (<a>property constraints</a>) and
					b) constraints about the <a>focus node</a> itself (<a>focus node constraints</a>).
				</p>

				<p>
					Additional types of constraints can be added using SHACL Full as
					<a href="#sparql-constraints">SPARQL-based constraints</a> or
					<a href="#constraint-components">SPARQL-based constraint components</a>.
				</p>

				<p>
					Constraints may contain
					<a href="#nonValidation">non-validating</a> properties (such as <code>sh:description</code>) or
					<a>parameters</a> of <a>constraint components</a> (e.g. <code>sh:minCount</code>).
					<a>Constraint components</a> define one or more <a>parameter</a> properties and <a>validation</a> instructions
					(such as those implemented as SPARQL queries) that can be used to perform the <a>validation</a> for the given <a>focus node</a> and parameter <a>values</a>.
					<!-- The relationship between a <a>constraint component</a> and the <span class="term">constraint types</span>
					that it can be used with is called the <dfn data-lt="contexts">context</dfn> of the component.
					For example, the <span class="term">context</span> of the component defining the <code><a href="#ClosedConstraintComponent">sh:closed</a></code> property is <code>sh:NodeConstraint</code>.
					This means that the property <code>sh:closed</code> can only be used in <a>SHACL instances</a> of <code>sh:NodeConstraint</code>.-->
					The catalog of predefined constraint components in SHACL Core is described in <a href="#constraints">section 4</a>.
				</p>


				<section id="property-constraints-section">
					<h4>Property Constraints (sh:predicate or sh:path)</h4>

					<p>
						<a>Property constraints</a> specify conditions that must be met with respect to <a>nodes</a> that can be reached from the
						<a>focus node</a> either by directly following a given property (specified using <code>sh:predicate</code>) or a given <a>property path</a> (specified using <code>sh:path</code>).
						<a>Property constraints</a> are linked from a <a>shape</a> with the property <code>sh:property</code>.
						The values of <code>sh:property</code> must be <a>IRIs</a> or <a>blank nodes</a>
						that are the <a>subject</a> of precisely one <a>triple</a> with
						either <a>predicate</a> <code>sh:predicate</code> or <code>sh:path</code>.
						The <a>values</a> of <code>sh:predicate</code> must be <a>IRIs</a>.
						The <a>values</a> of <code>sh:path</code> must be well-formed <a>property paths</a> following the <a href="#path-syntax">SHACL property path syntax rules</a>.
					</p>
					<p>
						The following example illustrates the two syntax variations of property constraints. 
					</p>
					<pre class="example-shapes">
ex:ExampleShapeWithPropertyConstraints
	a sh:Shape ;
	sh:property [
		sh:predicate ex:email ;
		sh:name "e-mail" ;
		sh:description "We need at least one email value" ;
		sh:minCount 1 ;
	] ;
	sh:property [
		sh:path (ex:knows ex:email) ;
		sh:name "Friend's e-mail" ;
		sh:description "We need at least one email for everyone you know" ;
		sh:minCount 1 ;
	] .</pre>
					<p>
						<code>sh:PropertyConstraint</code> is the class of property constraints.
						A SHACL processor treats all values of <code>sh:property</code> as <a>property constraints</a>.
						Thus, the values of <code>sh:property</code> do not require the <code>rdf:type sh:PropertyConstraint</code> triple.
					</p>

				</section>

				<section id="focus-node-constraints-section">
					<h4>Focus Node Constraints</h4>

					<p>
						<a>Focus node constraints</a> define constraints about the <a>focus node</a> itself.
						Since focus node constraints operate directly on the input focus nodes they impose some limitations in comparison to <a>property constraints</a>.
						In particular, constraints that operate on value sets, such as <code>sh:hasValue</code> and <code>sh:equals</code>, are not applicable to focus node constraints.
						Focus node constraints are attached directly to <a>Shapes</a> and <code>sh:shape</code> can be used to group focus node constraints.
					</p>

					<pre class="example-shapes">
ex:ExampleShapeWithFocusNodeConstraint
	a sh:Shape ;
	sh:targetClass ex:Person ;
	sh:stem "https://www.w3.org/People/" .</pre>

					<p>
						The class <code>sh:Shape</code> is defined as <code>rdfs:subClassOf sh:Constraint</code>.
					</p>

				</section>

				<section id="multiple-parameter-constraints-section">
					<h4>Multiple Parameters</h4>

					<p>
						Parameters of constraint components that only declare one parameter,  such as <code>sh:class</code>,
						may be used multiple times within the same constraint node.
						The interpretation of such declarations is conjunction, i.e. all constraints must validate.
						Constraints that declare more than one parameters, such as <code>sh:pattern</code>, are not allowed to be declared more than once in the same constraint.
						In the following example this technique is used to restrict the values of <code>ex:customer</code> to be <a>SHACL instances</a> of both
						<code>ex:Customer</code> and <code>ex:Person</code>.
					</p>
					<pre class="example-shapes">
ex:InvoiceShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:customer ;
		sh:class ex:Customer ;
		sh:class ex:Person ;
	] .</pre>

				</section>

				<section id="path-syntax">
					<h4>Property Paths</h4>
					<p>
						SHACL includes an RDF vocabulary to represent <a>property paths</a> that can be mapped into a subset of <a href="https://www.w3.org/TR/sparql11-query/#pp-language">SPARQL 1.1 property paths</a>.
						In particular, SHACL supports the following SPARQL 1.1 property path constructs:
						<code>PredicatePath</code>, <code>InversePath</code>, <code>SequencePath</code>, <code>AlternativePath</code>,
						<code>ZeroOrMorePath</code>, <code>OneOrMorePath</code> and <code>ZeroOrOnePath</code>.

						A valid SHACL property path <code>p</code> is represented by an <a>IRI</a> or a <a>blank node</a> that can be
						correctly traversed recursively using the following rules.
					</p>
					<ol>
						<li>
							If the graph contains a <a>triple</a> of the form <code>p sh:inversePath elt</code>
							then the path becomes an <code>InversePath</code> element of <code>elt</code> and <code>elt</code> must be a valid SHACL property path.
							Corresponding rules apply for
							<code>sh:zeroOrMorePath</code> (<code>ZeroOrMorePath</code>),
							<code>sh:zeroOrOnePath</code> (<code>ZeroOrOnePath</code>) and
							<code>sh:oneOrMorePath</code> (<code>OneOrMorePath</code>).
						</li>
						<li>
							If the graph contains a <a>triple</a> of the form <code>p rdf:first elt</code>,
							the path must be a well-formed RDF list with a at least two members.
							Each member must be valid SHACL property path that is converted into a sequence of either <code>SequencePath</code> or <code>AlternativePath</code> elements.
						</li>
						<li>
							If the graph contains a <a>triple</a> of the form <code>p sh:alternativePath elt</code>,
							the value of path must be a well-formed RDF list with a at least two members.
							All members must be valid SHACL property paths that become a series of <code>AlternativePath</code> elements.
						</li>
						<li>
							If <code>p</code> is an <a>IRI</a> then it is turned into a <code>PredicatePath</code>
							with value <code>p</code>.
						</li>

					</ol>
					<p>
						A SHACL property path is invalid if:
					</p>
					<ul>
						<li><code>p</code> is a <a>blank node</a> that is not handled by any of the above rules.</li>
						<li>During the path traversal the same node is reached more than once.</li>
						<li>There is a <a>value</a> for <code>p</code> with a predicate different from:
						<code>sh:inversePath</code>, <code>sh:alternativePath</code>, <code>sh:zeroOrMorePath</code>,
						<code>sh:zeroOrOnePath</code>, <code>sh:oneOrMorePath</code> or <code>rdf:first</code>.</li>
						<li>There are two or more <a>triples</a> with <code>p</code> as a subject.</li>
					</ul>
					<p>
						The following example illustrates some valid SHACL property paths, together with their SPARQL 1.1 equivalents.
					</p>
					<pre class="example-shapes">
# ex:parent
[] sh:path ex:parent .

# ^ex:parent
[] sh:path [ sh:inversePath ex:parent ] .

# ex:parent/ex:firstName
[] sh:path ( ex:parent ex:firstName ) .
					
# rdf:type/rdfs:subClassOf*
[] sh:path ( rdf:type [ sh:zeroOrMorePath rdfs:subClassOf ] ) .

# ex:father|ex:mother
[] sh:path [ sh:alternativePath ( ex:father ex:mother  ) ] .</pre>
				</section>

				<section>
					<h5>sh:path and sh:predicate</h5>
					<p>
						<code>sh:predicate</code> is a convention for declaring a simple predicate path of length one.
						In almost all cases, <code>sh:path</code> can be used in place of <code>sh:predicate</code> without changing the semantics of the property constraint.
						There are exceptions in cases when the value is a valid SHACL property path.
					</p>
					<pre class="example-shapes">
ex:ShapeWithIdenticalPath
	a sh:shape ;
	sh:property [
		sh:predicate ex:mother .
	]
	sh:property [
		sh:path ex:mother .
	] .

ex:ShapeWithDifferentPath
	a sh:shape ;
	sh:property [
		sh:predicate ex:parent .
	]
	sh:property [
		sh:path ex:parent .
	] .

ex:parent sh:alternativePath ( ex:father ex:mother  ) .</pre>
					<p>
						In the above example, both property constraints of <code>ex:ShapeWithIdenticalPath</code> declare an identical path to <code>ex:mother</code>.
						The property constraints in <code>ex:ShapeWithDifferentPath</code> denote different paths.
						The property constraint with <code>sh:predicate</code> denotes <code>ex:parent</code> while the property constraint with <code>sh:path</code> denotes the property path <code>(ex:father|ex:mother)</code>.
					</p>
				</section>


			</section>
		</section>

		<section id="validation">
			<h2>Validation and Graphs</h2>
			<p>
				A SHACL processor takes two immutable RDF graphs as input, a valid <a>shapes graph</a> and a
				<a>data graph</a>, and validates the <a>data graph</a> against the <a>shapes graph</a> as described herein.
			</p>

			<div id="def-validation" class="def def-text">
				<div class="def-header">VALIDATION DEFINITION</div>
				<div class="def-text-body">
					<ul>
						<li>A <a>node</a> validates against a <a>shape</a> iff
							either it does not validate against some <a>filter</a> of the shape
							or none of the <a>constraints</a> in the shape produce a <a>validation result</a> or a <a>failure</a> for the node.
						</li>
						<li>A <a>data graph</a> validates against a <a>shape</a> iff
							each node that is in any of the <a>targets</a> of the shape validates against the shape.
						</li>
						<li>A <a>data graph</a> validates against a <a>shapes graph</a> iff
							the data graph validates against each <a>shape</a> in the shapes graph.
						</li>
					</ul>
				</div>
			</div>

			<p>
				The validation process returns a <a>validation report</a> containing all <a>validation results</a>.
				<!--By default, the validation report contains validation results of all <a>severity</a> levels
				but the user can request validation results with a custom minimum severity.-->
				For simpler validation scenarios, SHACL processors SHOULD provide an additional validation interface that returns only <span class="term">VALID</span> or <span class="term">INVALID</span>.
				Furthermore, SHACL processors SHOULD support validating specific individual nodes only, for example specified using an additional argument beside shapes and data graphs.			
			</p>
			<p>
				During validation, the <a>data graph</a> and the <a>shapes graph</a> must remain immutable, i.e. both graphs at the end of the validation must be identical to the graph at the beginning of validation.
			</p>
			<p>
				A SHACL Core processor MUST implement all constructs in the Core of SHACL (Sections 2, 3, 4).
				A SHACL Core processor does not have to implement the other parts of SHACL.
			</p>

			<section id="shapes-graph">
				<h3>Shapes Graph</h3>
				<p>
					The <a>shapes graph</a> contains shape definitions that a <a>data graph</a> can be tested against.
					Shapes graphs can be reusable validation modules that can be cross-referenced with the predicate <a href="http://www.w3.org/TR/owl2-syntax/#Imports"><code>owl:imports</code></a>.
					Prior to validation, SHACL processors SHOULD extend the originally provided <a>shapes graph</a> by transitively following and importing all referenced <a>shapes graphs</a>
					through the <a href="http://www.w3.org/TR/owl2-syntax/#Imports"><code>owl:imports</code></a> predicate.
				</p>
				<p>
					In addition to shape definitions, the shapes graph may contain additional information for the SHACL processor such as <a href="#entailment">entailment</a> directives.
				</p>
			</section>
			
			<section id="data-graph">
				<h3>Data Graph</h3>
				<p>
					The <a>data graph</a> contains the RDF data that a SHACL processor can <a>validate</a>.
					SHACL treats it as a general RDF graph and makes no assumption if it is e.g. an RDF dataset, an in-memory graph or a named graph in a remote SPARQL endpoint.
					<!-- TODO: say something about datasets / $shapesGraph -->
				</p>
				<p>
					The data graph is expected to include all the ontology axioms related to the data and especially all the <code>rdfs:subClassOf</code> triples in order for SHACL to correctly identify class targets and validate Core SHACL constraints.
				</p>
			</section>
			
			<section id="sh-shapes-graph">
				<h3>Linking to shapes graphs (sh:shapesGraph)</h3>
				<p>
					A <a>data graph</a> can include triples used to suggest one or more graphs to a SHACL processor with the predicate <code>sh:shapesGraph</code>.
					Every <a>value</a> of this property is an <a>IRI</a> representing a graph that should be included into the <a>shapes graph</a> used to validate the <a>data graph</a>.
				</p>
				<p>
					In the following example, a tool may use the union of <code>ex:graph-shapes1</code> and <code>ex:graph-shapes2</code> graphs (and their <code>owl:imports</code>) as the <a>shapes graph</a> when validating the given graph.
				</p>

				<pre class="example-data">
&lt;http://example.com/myDataGraph&gt;
	sh:shapesGraph ex:graph-shapes1 ;
	sh:shapesGraph ex:graph-shapes2 .</pre>

				<p>
					The same mechanism applies for ontologies or vocabularies.
					The ontology or the vocabulary IRI can point to one or more graphs with the predicate <code>sh:shapesGraph</code>.
					A SHACL processor MAY take this information into account to determine which <a>shapes graph</a> to use for validating a <a>data graph</a> that uses that ontology or vocabulary.
				</p>
			</section>

			<section id="validation-report">
				<h3>Validation report</h3>
				<p>
					The <a>validation report</a> is the result of the validation process and includes a set of zero or more <a>validation results</a>.
					Each <a>validation result</a> contains a set of required or optional values that are described in the SHACL <span class="term">Validation Results Vocabulary</span>.
				</p>
				<p>
					The validation results produced by a SHACL processor MUST be the product of validation of the <a>data graph</a> only.
					Some SHACL processors MAY also report errors in the <a>shapes graph</a>, but those errors MUST NOT be mixed with the data validation results using the same results vocabulary.
				</p>

				<section id="results">
					<h4>Validation Results</h4>
					<p>
						SHACL includes an RDF vocabulary to represent <a>validation results</a> together with
						structural information that may provide guidance on how to identify or fix a violation.
					</p>

					<p>
						The following graph represents a example validation result.
						The values of <code>sh:message</code> are not mandated by SHACL and are considered implementation-specific.
					</p>
			<pre class="example-results">
ex:ExampleConstraintViolation
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:Bob ;
	sh:path ex:age ;
	sh:value "twenty two" ;
	sh:message "ex:age expects a literal of datatype xsd:integer." ;
	sh:sourceConstraintComponent sh:DatatypeConstraintComponent ;
	sh:sourceShape ex:PersonShape .</pre>
					<p>
						Validation results must be <a>SHACL instances</a> of the class <code>sh:ValidationResult</code>.
						Its <a>SHACL superclass</a>, <code>sh:AbstractResult</code>, defines the properties described in the following sub-sections.
						SHACL implementations may produce <a>SHACL instances</a> of other <a>SHACL subclasses</a> of <code>sh:AbstractResult</code>, for example
						to report successfully completed constraint checks or accumulated results.
					</p>
					<section id="results-focus-node">
						<h5>Focus node (sh:focusNode)</h5>
						<p>
							Validation results must have a single value for the property <code>sh:focusNode</code> to point to a
							<a>node</a> that has caused the result.
							This represents the <a>focus node</a> that was validated when the validation result was produced.
						</p>
					</section>
					<section id="results-path">
						<h5>Path (sh:path)</h5>
						<p>
							Validation results may have a value for the property <code>sh:path</code> pointing at a well-formed <a>property path</a> starting with the given <code>sh:focusNode</code>.
							For results produced by a <a>property constraint</a>, this <a>path</a> is always identical to either the <code>sh:predicate</code> or <code>sh:path</code> of the constraint.
						</p>
					</section>
					<section id="results-value">
						<h5>Value (sh:value)</h5>
						<p>
							Validation results may have a value for the property <code>sh:value</code> pointing at a specific <a>node</a> that has caused the result.
						</p>
					</section>
					<section id="results-source">
						<h5>Source (sh:sourceConstraint, sh:sourceShape and sh:sourceConstraintComponent)</h5>
						<p>
							Validation results may link to one <code>sh:Constraint</code> that has caused
							the result, specified via the property <code>sh:sourceConstraint</code>,
							and at the <code>sh:Shape</code> defining the constraint, via <code>sh:sourceShape</code>.
							Validation results may link to the <a>constraint component</a> that caused the result
							via <code>sh:sourceConstraintComponent</code>.
						</p>
					</section>
					<section id="results-detail">
						<h5>Detail (sh:detail)</h5>
						<p>
							The property <code>sh:detail</code> may link a (parent) result with one or more other
							(child) results that provide further details about the cause of the (parent) result.
							Depending on the capabilities of the SHACL processor, this may include violations of
							nested constraints that have been evaluated via <code>sh:shape</code>.
						</p>
					</section>
					<section id="results-message">
						<h5>Message (sh:message)</h5>
						<p>
							Validation results may have values for the property <code>sh:message</code> to communicate
							additional textual details to humans.
							While <code>sh:message</code> may have multiple values, there SHOULD not be two values with the same language tag.
						</p>
					</section>
					<section id="results-severity">
						<h5>Severity (sh:severity)</h5>
						<p>
							Each validation result must have exactly one value for the property <code>sh:severity</code>.
							SHACL includes the following three pre-defined <dfn data-lt="severity">severities</dfn>.
						</p>
						<table class="term-table">
							<tr>
								<th>Severity</th>
								<th>Description</th>
							</tr>
							<tr>
								<td><code>sh:Info</code></td>
								<td>A non-critical constraint violation indicating an informative message.</td>
							</tr>
							<tr>
								<td><code>sh:Warning</code></td>
								<td>A non-critical constraint violation indicating a warning.</td>
							</tr>
							<tr>
								<td><code>sh:Violation</code></td>
								<td>A constraint violation that should be fixed.</td>
							</tr>
						</table>
					</section>
					<section id="severity">
						<h3>Declaring the Severity of a Constraint</h3>
						<p>
							Constraints can specify their severity level using the property <code>sh:severity</code>,
							which must link to one of the severities.  <code>sh:Violation</code> is the default if unspecified.
							Constraints based on <a href="#constraint-components">constraint components</a> use the <code>sh:severity</code> declared at the component IRI unless overridden at the constraint.
							The following example clarifies this.
						</p>
				<pre class="example-shapes">
ex:MyShape
	a sh:Shape ;
	sh:property [
		# Violations of either minCount and datatype are produced as warnings
		sh:predicate ex:myProperty ;
		sh:minCount 1 ;
		sh:datatype xsd:string ;
		sh:severity sh:Warning ;
	] ;
	sh:property [
		# The default severity for sh:maxCount is sh:Violation
		sh:predicate ex:myProperty ;
		sh:maxCount 1 ;
	] .</pre>
					</section>
				</section>
			</section>
		</section>

		<section id="constraints">
			<h2>Core Constraint Components</h2>
			<p>
				This section defines the built-in SHACL Core <a>constraint components</a> that MUST be supported by all SHACL Core processors.
				Each constraint component is identified by an IRI that is referenced in the validation results via <code>sh:sourceConstraintComponent</code>.
			</p>
			<p>
				The choice of constraint components that are defined by the SHACL Core was made based on
				the requirements collected by the [[shacl-ucr]] document.
				Special attention was paid to the balance between trying to cover as many common use cases as possible
				and keeping the size of the Core language manageable.
				Not all use cases (such as describing constraints on members of an <code>rdf:List</code>) can be expressed by the Core language alone.
				Instead, SHACL Full provides an extension mechanism, described in the second part of this specification.
				It is expected that additional reusable libraries of <a>constraint components</a> will be maintained by third parties.
			</p>
			<p>
				All constraint components can be used both in <a>property constraints</a> and <a>focus node constraints</a>.
				However, some components may always result in violations in a particular constraint type.
				For example, <a href="#ClosedConstraintComponent">sh:closed</a> does not make sense in <a>property constraints</a>
				or <a href="#HasValueConstraintComponent">sh:hasValue</a> in <a>focus node constraints</a>.
			</p>
			<p>
				The textual description of each component refers to the concept of <dfn data-lt="value node">value nodes</dfn>
				which is defined as follows, including rules for the creation of validation results:
			</p>
			<ul>
				<li>
					For <a>property constraints</a> that have a <code>sh:predicate</code> the <span class="term">value nodes</span> are the <a>objects</a> of the <a>triples</a> that have the <a>focus node</a> as <a>subject</a> and the given property as <a>predicate</a>.
					Each produced <a>validation result</a> must have the <a>focus node</a> as its <code>sh:focusNode</code>,
					the <code>sh:predicate</code> as its <code>sh:path</code> and, if applicable, the respective violating value node as its <code>sh:value</code>.
				</li>
				<li>
					For <a>property constraints</a> that have a <code>sh:path</code> the <span class="term">value nodes</span> are the <a>objects</a> in the <a>data graph</a> that can be reached by following the given <a>property path</a> starting with the
					<a>focus node</a> as <a>subject</a> based on the evaluation rules defined by <a href="https://www.w3.org/TR/sparql11-query/#propertypaths">SPARQL 1.1</a>.
					Each produced <a>validation result</a> must have the <a>focus node</a> as its <code>sh:focusNode</code>,
					and, if applicable, the respective violating value node as its <code>sh:value</code>.
					The value of <code>sh:path</code> of each validation result must be a "deep copy" of the <code>sh:path</code> provided in the constraint, i.e.
					all triples that are required by the <a href="#path-syntax">SHACL well-formed path syntax rules</a> need to be copied from the <a>shapes graph</a> into the graph containing the validation results. 
				</li>
				<li>
					For <a>focus node constraints</a> the <span  class="term">value nodes</span> are the individual <a>focus nodes</a>, forming a set of exactly one node.
				</li>
			</ul>
			<section id="constraints-sparql-definitions" class="def-sparql">
				<h3>SPARQL definitions for built-in constraint components</h3>
				<p>
					The SPARQL definitions in this section represent potential <a href="#constraint-components-validators">validators</a>.
					Many constraint components are represented by a SPARQL ASK query.
					These queries are interpreted against each <a>value node</a>, bound to the variable <code>value</code>.
					If a <a>value node</a> fails the ASK query, a <a>validation result</a> is produced based on the rules outlined in
					the <a href="#SPARQLAskValidator">section on ASK-based validators</a>.
					Constraint components that are described using a SELECT query are interpreted based on the rules outlined in
					the <a href="#SPARQLSelectValidator">section on SELECT-based validators</a>.
					In particular, for <code>sh:PropertyConstraint</code>s,	the variable <code>PATH</code> is substituted with a <a>path</a> expression
					based on the values of either <code>sh:predicate</code> or <code>sh:path</code> in the constraint.
					All SPARQL queries also assume the variable bindings and result variable mapping rules detailed in the
					<a href="#sparql-constraints">section on SPARQL-based Constraints</a>.
					In a nutshell, the variable <code>this</code> represents the currently validated <a>focus node</a>.
				</p>
				<p>
					Note that the parameter tables in each of the following sections have a column called Value Type which indicates the expected
					type of the parameter values for documentation purposes, without enforcing any formal restrictions.
					Based on the parameter IRIs on the tables, <a>pre-bound</a> variables are defined using the <a>parameter names</a>.
				</p>
				<p>
					Some SPARQL definitions in this section also assume the existence of a built-in SPARQL function <a href="#hasShape"><code>sh:hasShape</code></a>.
				</p>
			</section>

			<section id="constraints-value-type">
				<h3>Value Type Constraint Components</h3>
				<p>
					The constraint components in this section have in common that they define restrictions
					on the type of the nodes.
					Note that it is possible to represent multiple value type options using <a href="#OrConstraintComponent">sh:or</a>.
				</p>
				<section id="ClassConstraintComponent">
					<h4>sh:class</h4>
					<p>
						The property <code>sh:class</code> can be used to verify that each <a>value node</a> is a <a>SHACL instance</a> of a given type.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ClassConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:class</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Type of all value nodes</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							that is either a <a>literal</a>, or a non-literal that is not a <a>SHACL instance</a> of the given <a>class</a> in the <a>data graph</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	$value rdf:type/rdfs:subClassOf* $class .
}</pre>
					</div>
					<pre class="example-shapes">
ex:ClassExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob, ex:Alice, ex:Carol ;
	sh:property [
		sh:predicate ex:knows ;
		sh:class ex:Person ;
	] .</pre>

					<pre class="example-data">
ex:Alice a ex:Person .
ex:Bob ex:knows ex:Alice .
<span class="focus-node-error">ex:Carol</span> ex:knows ex:Bob .</pre>
				</section>
				
				<section id="DatatypeConstraintComponent">
					<h4>sh:datatype</h4>
					<p>
						The property <code>sh:datatype</code> can be used to restrict the datatype of all <a>value nodes</a>.
						The values of <code>sh:datatype</code> must be resources representing datatypes, such as <code>xsd:string</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:DatatypeConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:datatype</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Datatype of all value nodes (e.g., <code>xsd:integer</code>)</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							that is not a <a>literal</a>, or is a <a>literal</a> with a mismatching datatype.
							A <a>literal</a> matches a datatype if the <a>literal</a>'s datatype has the same <a>IRI</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER (datatype($value) = $datatype) .
}</pre>
					</div>
					<pre class="example-shapes" title="Shape with sh:datatype property constraint">
ex:DatatypeExampleShape
	a sh:Shape ;
	sh:targetNode ex:Alice, ex:Bob ;
	sh:property [
		sh:predicate ex:age ;
		sh:datatype xsd:integer ;
	] .</pre>

					<pre class="example-data">
ex:Alice ex:age "23"^^xsd:integer .
<span class="focus-node-error">ex:Bob</span> ex:age "twenty two" .</pre>
				</section>
				
				<section id="NodeKindConstraintComponent">
					<h4>sh:nodeKind</h4>
					<p>
						The property <code>sh:nodeKind</code> is used to restrict the RDF node kind of each <a>value node</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:NodeKindConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:nodeKind</code></td>
							<td><code>sh:NodeKind</code></td>
							<td>Node kind (IRI, blank node, literal or combinations of these) of all value nodes</td>
						</tr>
					</table>
					<p>
						The values of <code>sh:nodeKind</code> must be one of the following six instances of the class <code>sh:NodeKind</code>:
						<code>sh:BlankNode</code>, <code>sh:IRI</code> and <code>sh:Literal</code> as well as the
						following values that represent combinations of the former three, i.e. either-or:
						<code>sh:BlankNodeOrIRI</code>, <code>sh:BlankNodeOrLiteral</code> and <code>sh:IRIOrLiteral</code>.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							that does not match the given node kind.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER ((isIRI($value) &amp;&amp; $nodeKind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ) ) ||
		(isLiteral($value) &amp;&amp; $nodeKind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ) ) ||
		(isBlank($value)   &amp;&amp; $nodeKind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ) )) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:NodeKindExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob, ex:Alice ;
	sh:property [
		sh:predicate ex:knows ;
		sh:nodeKind ex:IRI ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:knows ex:Alice .
<span class="focus-node-error">ex:Alice</span> ex:knows "Bob" .</pre>
				</section>
			</section>

			<section id="constraints-count">
				<h3>Cardinality Constraint Components</h3>
				<p>
					The <a>constraint components</a> represent restrictions on the number of
					<a>values</a> that the <a>focus node</a> may have for the given property or property path.
					SHACL has no default cardinality restrictions on properties.
					Focus node constraints have a cardinality always equal to 1 by design.
				</p>
				<section id="MinCountConstraintComponent">
					<h4>sh:minCount</h4>
					<p>
						The property <code>sh:minCount</code> restricts the minimum number of <a>value nodes</a>.
						If the minimum cardinality value is 0 then this constraint is always satisfied and so may be omitted.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MinCountConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum cardinality.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced if the number of
							<a>value nodes</a> is less than the value of <code>sh:minCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this
WHERE {
	OPTIONAL {
		$this $PATH ?value .
	}
} 
GROUP BY $this
HAVING (COUNT(?value) &lt; $minCount)</pre>
					</div>
					<pre class="example-shapes">
ex:MinCountExampleShape
	a sh:Shape ;
	sh:targetNode ex:Alice, ex:Bob ;
	sh:property [
		sh:predicate ex:name ;
		sh:minCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:Alice ex:name "Alice" .
<span class="focus-node-error">ex:Bob</span> ex:givenName "Bob"@en .</pre>
				</section>
				
				<section id="MaxCountConstraintComponent">
					<h4>sh:maxCount</h4>
					<p>
						The property <code>sh:maxCount</code> restricts the maximum number of <a>value nodes</a>.
						If this parameter is omitted then there is no limit on the number of triples.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MaxCountConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:maxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum cardinality.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced if the number of
							<a>value nodes</a> is greater than the value of <code>sh:maxCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this
WHERE {
	$this $PATH ?value .
}
GROUP BY $this
HAVING (COUNT(?value) > $maxCount)</pre>
					</div>
					<pre class="example-shapes">
ex:MaxCountExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob ;
	sh:property [
		sh:predicate ex:birthDate ;
		sh:maxCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:birthDate "May 5th 1990" .</pre>
				</section>
			</section>
			
			<section id="constraints-range">
				<h3>Value Range Constraint Components</h3>
				<p>
					The following constraint components represent range restrictions on nodes that are comparable
					via operators such as <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.
				</p>
				<section id="range-property-constraints">
					<h4>sh:minExclusive, sh:minInclusive, sh:maxExclusive, sh:maxInclusive</h4>
					<p>
						The properties from the following table restrict the range of <a>value nodes</a>.
						The supported datatypes of these nodes are <code>xsd:string</code>, <code>xsd:boolean</code>, <code>xsd:dateTime</code> and all numeric datatypes such as <code>xsd:integer</code>.
					</p>
					<p>
						<span class="component-class">Constraint Components:</span> <code>sh:MinExclusiveConstraintComponent</code>, <code>sh:MinInclusiveConstraintComponent</code>, <code>sh:MaxExclusiveConstraintComponent</code>, <code>sh:MaxInclusiveConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
							<th>Definition</th>
						</tr>
						<tr id="MinExclusiveConstraintComponent">
							<td><code>sh:minExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum exclusive value</td>
							<td><code>&lt;</code></td>
						</tr>
						<tr id="MinInclusiveConstraintComponent">
							<td><code>sh:minInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum inclusive value</td>
							<td><code>&lt;=</code></td>
						</tr>
						<tr id="MaxExclusiveConstraintComponent">
							<td><code>sh:maxExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum exclusive value</td>
							<td><code>&gt;</code></td>
						</tr>
						<tr id="MaxInclusiveConstraintComponent">
							<td><code>sh:maxInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum inclusive value</td>
							<td><code>&gt;=</code></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							that does not match the literal range specified by the table above,
							using the semantics of the SPARQL operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.
							A <a>validation result</a> must also be produced if the node cannot be compared to the specified range.
						</div>
					</div>
					<p>
						Note that if the comparison cannot be performed, for example when someone compares a string with an integer,
						then the SHACL processor will produce a validation result.  This is different from, say, a plain SPARQL query, in
						which such failures would silently not lead to any results.
					</p>
					<p class="def-sparql">
						The following SPARQL definition covers <code>sh:minExclusive</code> - the other variations can be derived by replacing the <code>&lt;</code> operator and the <code>minExclusive</code> variable.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER ($minExclusive &lt; $value)
}</pre>
					</div>
					<pre class="example-shapes">
ex:NumericRangeExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob, ex:Alice, ex:Ted ;
	sh:property [
		sh:predicate ex:age ;
		sh:minInclusive 0 ;
		sh:maxInclusive 150 ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:age 23 .
<span class="focus-node-error">ex:Alice</span> ex:age 220 .
<span class="focus-node-error">ex:Ted</span> ex:age "twenty one" .</pre>
				</section>
			</section>

			<section id="constraints-string">
				<h3>String-based Constraint Components</h3>
				<p>
					The constraint components in this section have in common that they are representing
					restrictions on the string representation of certain nodes.
				</p>
				<section id="MinLengthConstraintComponent">
					<h4>sh:minLength</h4>
					<p>
						The property <code>sh:minLength</code> restricts the string length of <a>value nodes</a>.
						This can be applied to any <a>literals</a> and <a>IRIs</a>, but not to <a>blank nodes</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MinLengthConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum length. If the value is 0 then there is no restriction on the string length but this constraint is still violated if the node is a blank node.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							where the length of its string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							is less than the specified minimum length, or if the node is a <a>blank node</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER (STRLEN(str($value)) >= $minLength) .
}</pre>
					</div>
				</section>
				
				<section id="MaxLengthConstraintComponent">
					<h4>sh:maxLength</h4>
					<p>
						The property <code>sh:maxLength</code> restricts the string length of <a>value nodes</a>
						This can be applied to any <a>literals</a> and <a>IRIs</a>, but not to <a>blank nodes</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MaxLengthConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:maxLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum length. If this constraint is omitted then there is no restriction on the string length and no requirement that the node is a literal or IRI.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							where the length of its string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							is greater than the specified maximum length, or if the node is a <a>blank node</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER (STRLEN(str($value)) &lt;= $maxLength) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:PasswordExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob, ex:Alice ;
	sh:property [
		sh:predicate ex:password ;
		sh:minLength 8 ;
		sh:maxLength 10 ;
	] .</pre>

					<pre class="example-data">
ex:Bob ex:password "123456789" .
<span class="focus-node-error">ex:Alice</span> ex:password "1234567890ABC" .</pre>
				</section>
				
				<section id="PatternConstraintComponent">
					<h4>sh:pattern</h4>
					<p>
						The property <code>sh:pattern</code> can be used to validate whether all <a>value nodes</a> match a given regular expression.
						The values of <code>sh:pattern</code> must be valid pattern arguments for the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:PatternConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:pattern</code></td>
							<td><code>xsd:string</code></td>
							<td>Regular expression that all value nodes must match</td>
						</tr>
						<tr>
							<td><code>sh:flags</code></td>
							<td><code>xsd:string</code> (optional)</td>
							<td>An optional string of flags, interpreted as in <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL 1.1 REGEX</a></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a> that is a <a>blank node</a> or
							where the string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							does not match the given regular expression (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>).
							If <code>sh:flags</code> is present then this must be interpreted according to the third argument of the SPARQL REGEX function. 
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER (!isBlank($value) &amp;&amp; IF(bound($flags), regex(str($value), $pattern, $flags), regex(str($value), $pattern)))
}</pre>
					</div>
					<pre class="example-shapes">
ex:PatternExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob, ex:Alice, ex:Carol ;
	sh:property [
		sh:predicate ex:bCode ;
		sh:pattern "^B" ;    # starts with 'B'
		sh:flags "i" ;       # Ignore case
	] .</pre>
					<pre class="example-data">
ex:Bob ex:bCode "b101" .
ex:Alice ex:bCode "B102" .
<span class="focus-node-error">ex:Carol</span> ex:bCode "C103" .</pre>
				</section>
				
				<section id="StemConstraintComponent">
					<h4>sh:stem</h4>
					<p>
						The property <code>sh:stem</code> validates whether all <a>value nodes</a> are IRIs and the IRI starts with a given string value.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:StemConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:stem</code></td>
							<td><code>xsd:string</code></td>
							<td>String value that an IRI must start with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							that is not an <a>IRI</a> or the <a href="https://www.w3.org/TR/sparql11-query/#func-str">string representation</a> of the <a>IRI</a> does not <a href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#func-strstarts">start with</a> the given string.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	FILTER (isIRI($value) &amp;&amp; STRSTARTS(str($value), $stem))
}</pre>
					</div>
					<pre class="example-shapes">
ex:StemExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob, ex:Alice, ex:Carol ;
	sh:property [
		sh:predicate ex:w3cHomepage ;
		sh:stem "https://www.w3.org/People/" ;
	] .</pre>
					<pre class="example-data">
ex:Alice ex:w3cHomepage &lt;https://www.w3.org/People/Alice&gt; .
<span class="focus-node-error">ex:Bob</span> ex:w3cHomepage &lt;https://example.com/People/Bob&gt; .
<span class="focus-node-error">ex:Carol</span> ex:w3cHomepage "https://www.w3.org/People/Carol" .</pre>
				</section>
				
				<section id="LanguageInConstraintComponent">
					<h4>sh:languageIn</h4>
					<p>
						The property <code>sh:languageIn</code> can be used to enumerate language tags that all <a>value nodes</a> must have.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:LanguageInConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:languageIn</code></td>
							<td><code>rdf:List</code></td>
							<td>A list of language ranges (list members are <code>xsd:string</code>)</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							that is either not a <a>literal</a> or that does not have a language tag
							matching any of the provided language ranges following the filtering schema defined by
							the <a href="https://www.w3.org/TR/sparql11-query/#func-langMatches">SPARQL langMatches</a> function.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	BIND (lang($value) AS ?valueLang) .
	FILTER (bound(?valueLang) &amp;&amp; EXISTS {
			GRAPH $shapesGraph {
				$languageIn (rdf:rest*)/rdf:first ?lang .
				FILTER (langMatches(?valueLang, ?lang))
			} 
		} )
}</pre>
					</div>
					<p>
						The following example shape states that all values of <code>ex:prefLabel</code>
						must be either in English or Mori.
					</p>
					<pre class="example-shapes">
ex:NewZealandLanguagesShape
	a sh:Shape ;
	sh:targetNode ex:Mountain, ex:Berg ;
	sh:property [
		sh:predicate ex:prefLabel ;
		sh:languageIn ( "en" "mi" ) ;
	] .</pre>
					<p>
						From the example instances, <code>ex:Berg</code> will lead to constraint violations for all
						of its labels.
					</p>
					<pre class="example-data">
ex:Mountain
	ex:prefLabel "Mountain"@en ;
	ex:prefLabel "Hill"@en-NZ ;
	ex:prefLabel "Maunga"@mi .

<span class="focus-node-error">ex:Berg</span>
	ex:prefLabel "Berg" ;
	ex:prefLabel "Berg"@de ;
	ex:prefLabel ex:BergLabel .</pre>
				</section>
				
				<section id="UniqueLangConstraintComponent">
					<h4>sh:uniqueLang</h4>
					<p>
						The property <code>sh:uniqueLang</code> can be set to <code>true</code> to specify that no pair of <a>value nodes</a> may use the same language tag.
						The values of <code>sh:uniqueLang</code> must be <code>xsd:boolean</code>s.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:UniqueLangConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:uniqueLang</code></td>
							<td><code>xsd:boolean</code></td>
							<td><code>true</code> to activate this constraint</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							If <code>sh:uniqueLang</code> is set to <code>true</code> then a <a>validation result</a> must be produced for each non-empty language tag that is
							used by at least two <a>value nodes</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT DISTINCT $this ?lang
WHERE {
	{
		FILTER ($uniqueLang) .
	}
	$this $PATH ?value .
	BIND (lang(?value) AS ?lang) .
	FILTER (bound(?lang) &amp;&amp; ?lang != "") . 
	FILTER EXISTS {
		$this $PATH ?otherValue .
		FILTER (?otherValue != ?value &amp;&amp; ?lang = lang(?otherValue)) .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:UniqueLangExampleShape
	a sh:Shape ;
	sh:targetNode ex:Alice, ex:Bob ;
	sh:property [
		sh:predicate ex:label ;
		sh:uniqueLang true ;
	] .</pre>

					<pre class="example-data">
ex:Alice
	ex:label "Alice" ;
	ex:label "Alice"@en ;
	ex:label "Alice"@fr .

<span class="focus-node-error">ex:Bob</span>
	ex:label "Bob"@en ;
	ex:label "Bobby"@en .</pre>
				</section>
			</section>
			
			<section id="constraints-property-pairs">
				<h3>Property Pair Constraint Components</h3>
				<p>
					The constraint components in this section restrict the sets of <a>value nodes</a> in relation to other properties.
					<a>Value nodes</a> of focus node constraints are always defined as a set of size 1
					and may produce unexpected results when used with constraint components of this category.
				</p>
				
				<section id="EqualsConstraintComponent">
					<h3>sh:equals</h3>
					<p>
						<code>sh:equals</code> constrains a pair of properties so that the sets of values of both properties at a given focus node must be equal.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:EqualsConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:equals</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Property to compare with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced
							for each <a>value node</a> that does not exist as <a>value</a> at the focus node of the property specified using <code>sh:equals</code> and
							for each <a>value</a> of the property specified using <code>sh:equals</code> that does not exist as <a>value node</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this ?value
WHERE {
	{
		$this $PATH ?value .
		MINUS {
			$this $equals ?value .
		}
	}
	UNION
	{
		$this $equals ?value .
		MINUS {
			$this $PATH ?value .
		}
	}
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:equals</code> in a shape to verify
						that certain nodes must have the same set of values for <code>ex:firstName</code> and <code>ex:givenName</code>.
					</p>
					<pre class="example-shapes">
ex:EqualExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob ;
	sh:property [
		sh:predicate ex:firstName ;
		sh:equals ex:givenName ;
	] .</pre>
					<pre class="example-data">
ex:Bob
	ex:firstName "Bob" ;
	ex:givenName "Bob" .</pre>
				</section>
				
				<section id="DisjointConstraintComponent">
					<h3>sh:disjoint</h3>
					<p>
						<code>sh:disjoint</code> constrains a pair of properties so that the sets of <a>values</a> of both properties at a given <a>focus node</a> must not share any nodes.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:DisjointConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:disjoint</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							that also exists as <a>value</a> of the property specified using <code>sh:disjoint</code> at the given <a>focus node</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this ?value
WHERE {
	$this $PATH ?value .
	$this $disjoint ?value .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:disjoint</code> in a shape to verify
						that certain nodes must not share any values for <code>ex:prefLabel</code> and <code>ex:altLabel</code>.
					</p>
					<pre class="example-shapes">
ex:DisjointExampleShape
	a sh:Shape ;
	sh:targetNode ex:USA, ex:Germany ;
	sh:property [
		sh:predicate ex:prefLabel ;
		sh:disjoint ex:altLabel ;
	] .</pre>
					<pre class="example-data">
ex:USA
	ex:prefLabel "USA" ;
	ex:altLabel "United States" .

<span class="focus-node-error">ex:Germany</span>
	ex:prefLabel "Germany" ;
	ex:altLabel "Germany" .</pre>
				</section>
				
				<section id="LessThanConstraintComponent">
					<h3>sh:lessThan</h3>
					<p>
						<code>sh:lessThan</code> constrains a pair of properties so that the <a>values</a> of the first property must be smaller than the <a>values</a> of the second property at a given <a>focus node</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:LessThanConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:lessThan</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each pair of <a>value nodes</a> and
							the values of the property specified using <code>sh:lessThan</code> at the given <a>focus node</a>, where
							the first <a>value</a> is not less than the second <a>value</a>, based on SPARQL's <code>&lt;</code> operator.
							A validation result must also be produced if the two <a>values</a> cannot be compared.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this ?value
WHERE {
	$this $PATH ?value .
	$this $lessThan ?otherValue .
	FILTER (!(?value &lt; ?otherValue)) .
}</pre>
					</div>
					<p class="todo">TODO: Decide what should happen if values are not comparable, i.e. &lt; fails, similar to minExclusive etc.</p>
					<p>
						The following example illustrates the use of <code>sh:lessThan</code> in a shape to verify
						that all values of <code>ex:startDate</code> must be "before" the values of <code>ex:endDate</code>.
					</p>
					<pre class="example-shapes">
ex:LessThanExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:startDate ;
		sh:lessThan ex:endDate ;
	] .</pre>
				</section>
				
				<section id="LessThanOrEqualsConstraintComponent">
					<h3>sh:lessThanOrEquals</h3>
					<p>
						<code>sh:lessThanOrEquals</code> constrains a pair of properties so that the <a>values</a> of the first property must be smaller than or equal to the <a>values</a> of the second property at a given <a>focus node</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:LessThanOrEqualsConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:lessThanOrEquals</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each pair of <a>value nodes</a> and
							the values of the property specified using <code>sh:lessThanOrEquals</code> at the given <a>focus node</a>, where
							the first <a>value</a> is not less than or equal to the second <a>value</a>, based on SPARQL's <code>&lt;=</code> operator.
							A validation result must also be produced if the two <a>values</a> cannot be compared.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this ?value
WHERE {
	$this $PATH ?value .
	$this $lessThan ?otherValue .
	FILTER (!(?value &lt;= ?otherValue)) .
}</pre>
					</div>
				</section>
			</section>				
	
			<section id="constraints-logical">
				<h3>Logical Constraint Components</h3>
				<p>
					The constraint components in this section implement the common logical operators <span class="term">and</span>,
					<span class="term">or</span> and <span class="term">not</span>.
				</p>
				<section id="NotConstraintComponent">
					<h3>sh:not</h3>
					<p>
						SHACL supports a negation constraint component that can be used to verify that a <a>value node</a> does not have a given <a>shape</a>.
						This is comparable to a logical "not" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:NotConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:not</code></td>
							<td><code>sh:Shape</code></td>
							<td>The shape to negate</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a> that produces no validation results for the shape given via <code>sh:not</code>.
							A <a>failure</a> must be reported if the validation of the shape produces a <a>failure</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for shapes, must return no results)</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	BIND (sh:hasShape($this, $not, $shapesGraph) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || ?hasShape) .
}</pre>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints, must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this ?value ?failure
WHERE {
	$this $PATH ?value .
	BIND (sh:hasShape($this, $not, $shapesGraph) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || ?hasShape) .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:not</code> in a shape to verify
						that certain nodes cannot have any value of <code>ex:property</code>.
					</p>
					<pre class="example-shapes">
ex:NotExampleShape
	a sh:Shape ;
	sh:targetNode ex:InvalidInstance1 ;
	sh:not [
		a sh:Shape ;
		sh:property [
			sh:predicate ex:property ;
			sh:minCount 1 ;
		] ;
	] .</pre>
					<pre class="example-data">
<span class="focus-node-error">ex:InvalidInstance1</span> ex:property "Some value" .</pre>
				</section>
				
				<section id="AndConstraintComponent">
					<h3>sh:and</h3>
					<p>
						SHACL supports a conjunctive constraint component that can be used to test whether a <a>value node</a> has all out of several shapes.
						This is comparable to a logical "and" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:AndConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:and</code></td>
							<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
							<td>List of shapes to validate the value nodes against</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a> if the following condition is false:
							The validation of the <a>value node</a> against all of the <a>shapes</a> in the <code>sh:and</code> list produces a <a>validation result</a> for at least one shape.
							A <a>failure</a> must be produced if the validation of one of the shapes produces a <a>failure</a>.
						</div>
					</div>
					<p>
						Note that although <code>sh:and</code> has an <code>rdf:List</code> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:and</code> in a shape to verify
						that certain nodes have exactly one value of <code>ex:property</code>.
						This is achieved via the conjunction of a separate named shape (<code>ex:SuperShape</code>) which defines
						the minimum count, and a blank node shape that further constrains the maximum count.
						As shown here, <code>sh:and</code> can be used to implement a specialization mechanism between shapes.
					</p>
					<pre class="example-shapes">
ex:SuperShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:minCount 1 ;
	] .

ex:ExampleAndShape
	a sh:Shape ;
	sh:targetNode ex:ValidInstance, ex:InvalidInstance ;
	sh:and (
		ex:SuperShape
		[
			a sh:Shape ;
			sh:property [
				sh:predicate ex:property ;
				sh:maxCount 1 ;
			]
		]
	) .</pre>

<pre class="example-data">
ex:ValidInstance
	ex:property "One" .

# Invalid: more than one property
<span class="focus-node-error">ex:InvalidInstance</span>
	ex:property "One" ;
	ex:property "Two" .</pre>
				</section>
				
				<section id="OrConstraintComponent">
					<h3>sh:or</h3>
					<p>
						SHACL supports a high-level syntax for disjunctive constraints that can be used to test whether a <a>value node</a> has at least one out of several shapes.
						This is comparable to a logical "or" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:OrConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:or</code></td>
							<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
							<td>List of shapes to validate the value nodes against</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a> if the following condition is false:
							The validation of the <a>value node</a> against all of the <a>shapes</a> in the <code>sh:or</code> list produces no <a>validation results</a> for at least one shape.
							A <a>failure</a> must be produced if the <a>validation</a> of one of the shapes produces a <a>failure</a>.
						</div>
					</div>
					<p>
						Note that although <code>sh:or</code> has an <code>rdf:List</code> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:or</code> in a shape to verify
						that certain nodes have at least one value of <code>ex:firstName</code>
						or at least one value of <code>ex:givenName</code>.
					</p>
					<pre class="example-shapes">
ex:OrConstraintExampleShape
	a sh:Shape ;
	sh:targetNode ex:Bob ;
	sh:or (
		[
			sh:property [
				sh:predicate ex:firstName ;
				sh:minCount 1 ;
			]
		]
		[
			sh:property [
				sh:predicate ex:givenName ;
				sh:minCount 1 ;
			]
		]
	) .</pre>
					<pre class="example-data">
ex:Bob ex:firstName "Robert" .</pre>
					<p>
						The next example shows how <code>sh:or</code> can be used in a <a>property constraint</a> to state that the values of
						the given property <code>ex:address</code> may be either literals with datatype <code>xsd:string</code>
						or <a>SHACL instances</a> of the class <code>ex:Address</code>.
					</p>
					<pre class="example-shapes">
ex:PersonAddressShape
	a sh:Shape ;
	sh:targetClass ex:Person ;
	sh:property [
		sh:predicate ex:address ;
		sh:or (
			[
				sh:datatype xsd:string ;
			]
			[
				sh:class ex:Address ;
			]
		)
	] .</pre>
					<pre class="example-data">
ex:Bob ex:address "123 Prinzengasse, Vaduz, Liechtenstein" .</pre>
				</section>
			</section>
	
			<section id="constraints-shape">
				<h3>Shape-based Constraint Components</h3>
				<p>
					The constraint components in this section can be used to represent complex restrictions
					based on applying shape definitions on value nodes. 
				</p>
				
				<section id="ShapeConstraintComponent">
					<h4>sh:shape</h4>
					<p>
						The property <code>sh:shape</code> can be used verify that all <a>value nodes</a> must have a given shape.
						The value type of <code>sh:shape</code> is <code>sh:Shape</code>, but the <code>rdf:type</code> triple of those shapes can be omitted.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ShapeConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:shape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of all value nodes</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced for each <a>value node</a>
							where validating the value node against the shape specified by <code>sh:shape</code> 
							produces any validation results.
							A <a>failure</a> must be produced if the validation of any <a>value node</a> has produced a <a>failure</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for shapes, must return no results)</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	BIND (sh:hasShape($this, $shape, $shapesGraph) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || !?hasShape) .
}</pre>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints, must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this ?value ?failure
WHERE {
	$this $PATH ?value .
	BIND (sh:hasShape(?value, $shape, $shapesGraph) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || !?hasShape) .
}</pre>
					</div>
					<p id="recursion">
						A shape may refer to itself directly or indirectly via <code>sh:shape</code>, <code>sh:filterShape</code>, etc.
						Such a shape is said to be <em>recursive</em>.
						The meaning of non-recursive shapes is always well-founded.
						In contrast, the meaning of a recursive shape may not be well-founded.
						The handling of recursive shapes in SHACL is left to implementations.
						Some implementations MAY reject shapes graphs containing recursive shape definitions.
						Some implementations MAY report a <a>failure</a> if a recursion has been detected at validation time.
					</p>
					<p>
						In the following example, all values of the property <code>ex:someProperty</code> will validate with no results for the shape
						specified by a blank node that ensures that the property <code>ex:nestedProperty</code> has at least one value.
					</p>
					<pre class="example-shapes">
ex:ShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:shape [
			a sh:Shape ;   # Optional
			sh:property [
				sh:predicate ex:nestedProperty ;
				sh:minCount 1 ;
			]
		]
	] .</pre>

					<pre class="example-data">
ex:ShapeExampleValidResource
	ex:someProperty [
		ex:nestedProperty 42 ;
	] .</pre>
				</section>
				
				<section id="QualifiedValueShapeConstraintComponent">
					<h4>sh:qualifiedValueShape, sh:qualifiedMinCount, sh:qualifiedMaxCount</h4>
					<div class="issue" data-number="92" title="Relationship of QCRs with Partitions">
						Feature at risk:
						There is an ongoing proposal (see sh:partition) that strongly overlaps with the QCRs proposed here.
						The WG may decide to support only one of these options, but not both.
					</div>
					<p>
						The property <code>sh:qualifiedValueShape</code> can be used verify that a certain number of <a>value nodes</a> must have a given shape.
						The value type of <code>sh:qualifiedValueShape</code> is <code>sh:Shape</code>, and it needs to be accompanied by
						a <code>sh:qualifiedMinCount</code> or a <code>sh:qualifiedMaxCount</code> (both typed <code>xsd:integer</code>), or both.
						The <code>rdf:type</code> of the value shapes can be omitted.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:QualifiedValueShapeConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:qualifiedValueShape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of the specified values</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMinCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum number of values that must have the shape. If this constraint is omitted then there is no minimum number of values required.</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMaxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum number of values that can have the shape. If this constraint is omitted then there is no maximum number of values required.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMinCount</div>
						<div class="def-text-body">
							Let <code>C</code> be the number of <a>value nodes</a> where
							validating the node against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no <a>validation results</a>.
							A <a>failure</a> must be produced if the validation of any of the value nodes produces a <a>failure</a>.
							A <a>validation result</a> must be produced if <code>C</code>
							is less than the specified <code>sh:qualifiedMinCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:qualifiedMinCount (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this (SUM(?failed)>0 AS ?failure)
WHERE {
	{
		$this $PATH ?value .
		BIND (sh:hasShape(?value, $qualifiedValueShape, $shapesGraph) AS ?hasShape) .
		FILTER (!bound(?hasShape) || ?hasShape) .
	}
	BIND (IF(!bound(?hasShape), 1, 0) AS ?failed) .
} 
GROUP BY $this
HAVING ((COUNT(?value) &lt; $qualifiedMinCount) || (SUM(?failed) > 0))</pre>
					</div>
					<p class="def-sparql">
						Note that in the SPARQL query above, we assume that the <code>SUM</code> operation fails
						if one of the values of <code>?s</code> is not a number.
						This mechanism is used by the error handling, which sets <code>?s</code> to the string <code>'error'</code>
						whenever one of the individual <code>sh:hasShape</code> calls fails.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMaxCount</div>
						<div class="def-text-body">
							Let <code>C</code> be the number of <a>value nodes</a> where
							validating the node against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no <a>validation results</a>.
							A <a>failure</a> must be produced if the validation of any of the <a>value nodes</a> produces a <a>failure</a>.
							A <a>validation result</a> must be produced if <code>C</code>
							is greater than the specified <code>sh:qualifiedMaxCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:qualifiedMaxCount (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this (SUM(?failed)>0 AS ?failure)
WHERE {
	{
		$this $PATH ?value .
		BIND (sh:hasShape(?value, $qualifiedValueShape, $shapesGraph) AS ?hasShape) .
		FILTER (!bound(?hasShape) || ?hasShape) .
	}
	BIND (IF(!bound(?hasShape), 1, 0) AS ?failed) .
} 
GROUP BY $this
HAVING ((COUNT(?value) > $qualifiedMaxCount) || (SUM(?failed) > 0))</pre>
					</div>
					<p>
						In the following example, the property <code>ex:parent</code> must have exactly two values,
						and at least one of them needs to be female.
					</p>
					<pre class="example-shapes">
ex:QualifiedValueShapeExampleShape
	a sh:Shape ;
	sh:targetNode ex:QualifiedValueShapeExampleValidResource ;
	sh:property [
		sh:predicate ex:parent ;
		sh:minCount 2 ;
		sh:maxCount 2 ;
		sh:qualifiedValueShape [
			a sh:Shape ;   # Optional
			sh:property [
				sh:predicate ex:gender ;
				sh:hasValue ex:female ;
			]
		] ;
		sh:qualifiedMinCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:QualifiedValueShapeExampleValidResource
	ex:parent ex:John ;
	ex:parent ex:Jane .

ex:John
	ex:gender ex:male .

ex:Jane
	ex:gender ex:female .</pre>
				</section>
				
				<section id="PartitionConstraintComponent">
					<h4>sh:partition</h4>
					<p>
						In some cases a given property may be multi-valued and it may be required that the set of values
						be partitioned into two or more subsets, each of which satisfies certain constraints.
					</p>
					<p>
						For example, suppose that in the Library of Congress BIBFRAME (<code>bf:</code>) Cultural Heritage vocabulary each person (<code>bf:Person</code>) must be identified by 
						(<code>bf:identifiedBy</code>) exactly one identifier from <code>id.loc.gov</code> and may have another identifier
						from <code>viaf.org</code>. No other identifiers are allowed. Thus the set of all identifiers is partitioned into
						two subsets, the first of which contains exactly one member and the second of which contains zero or one members.
						The following example shows a snippet of some valid BIBFRAME data.
					</p>
					<pre class="example-data" title="Valid BIBFRAME Data">&lt;bf_Person1>
  	bf:identifiedBy &lt;http://id.loc.gov/authorities/names/n80103961#RWO> ;
 	bf:identifiedBy &lt;https://viaf.org/viaf/268367832/#Knape,_Joachim> .</pre>
					<p>
						The following example shows a snippet of some invalid BIBFRAME data.
					</p>
					<pre class="example-data" title="Invalid BIBFRAME Data">&lt;bf_Person1>
  	bf:identifiedBy &lt;http://id.loc.gov/authorities/names/n80103961#RWO> ;
 	bf:identifiedBy &lt;https://viaf.org/viaf/268367832/#Knape,_Joachim> ;
	bf:identifiedBy "this is a mistake" . # should be an error</pre>
					<p>
						Qualified cardinality constraints provide a basis for expressing this type of partitioning requirement, but using them imposes a burden on the shapes author. In the BIBFRAME example the author would need to express the requirement that the set of all identifiers that are from neither <code>id.loc.gov</code> nor <code>viaf.org</code> is empty, i.e. it has a maximum cardinality of 0. Clearly, as more subsets of values are involved, the burden on the author increases.
						The <code>sh:partition</code> constraint makes it easier to express this type of requirement than it would be to use 
						multiple qualified cardinality constraints.
						In effect, <code>sh:partition</code> chains together a sequence of qualified cardinality constraints and removes the set of value nodes matched by each from further consideration. If every value node gets matched in this process, then
						the <code>sh:partition</code> constraint reports no violations. Otherwise, any value nodes remaining are reported as
						violations of the constraint.
						The BIBFRAME example constraint is expressed as follows.
					</p>
					<pre class="example-shapes" title="BIBFRAME constraint expressed using sh:partition">
ex:BibframeShape a sh:Shape ;
	sh:property [
		sh:predicate bf:identifiedBy ;
		sh:partition (
			[sh:minCount 1; sh:maxCount 1; sh:pattern "^http://id.loc.gov/"]
			[sh:maxCount 1; sh:pattern "^https://viaf.org/"]
		)
] .</pre>
					<p>
						The value of the <code>sh:partition</code> constraint parameter MUST be an <code>rdf:List</code> that contains zero or more resources. 
						Each resource in the list defines conditions on a subset of the value nodes and MAY contain the following parameters:
					</p>
					<ul>
						<li>zero or one <code>sh:minCount</code>. This defines the minimum cardinality of the corresponding subset.</li>
						<li>zero or one <code>sh:maxCount</code>. This defines the maximum cardinality of the corresponding subset.</li>
						<li>any combination of parameters associated with node validation constraints. A node validation constraint
							is any constraint defined by a boolean function on nodes. 
							These include the built-in constraints defined by <code>sh:nodeKind</code>, <code>sh:partition</code>,
							<code>sh:minExclusive</code>, etc.
							The corresponding subset consists of those remaining nodes for which the boolean function is <code>true</code>.</li>
					</ul>
					<p>
						Note that a resource that contains no parameters matches all nodes. Such a resource is useful as the last member of the list where it acts as a default matching rule in the case where nodes that do not match any of the preceeding constraints are allowed. 
						Note also that a qualified cardinality constraint defined using <code>sh:qualifiedValueShape</code>,
						<code>sh:qualifiedMinCount</code>, and <code>sh:qualifiedMaxCount</code> is equivalent to a <code>sh:partition</code> constraint that contains two resources with the first one containing the corresponding parameters and the last one being the default matching rule that matches any set of nodes.
					</p>
					<p>
						Each member of the list is used by the SHACL processor to match a subset of the value nodes.
						The SHACL processor matches as many nodes as possible and then compares the result with the specified
						minimum and maximum cardinalities if specified. This is referred to as a <em>greedy</em> matching algorithm.
						Greedy pattern matching is commonly used with textual regular expressions.
						Nodes that match are removed from further matching. Thus the set of all value nodes becomes partitioned by 
						the matching algorithm. The following paragraphs define this algorithm more precisely.
					</p>
					<p>
						Let D be a data graph and let F be a focus node in D. Let S be a shapes graph, let T be a shape in S, 
						and let C be a <code>sh:partition</code> constraint in T. 
						Let N be the set of value nodes for C in D at F. Recall that N depends on how C is related to T. 
					</p>
					<ul>
						<li>If (T, <code>sh:constraint</code>, C) is in S then N consists of just the node F.</li>
						<li>If (T, <code>sh:property</code>, C) and (C, <code>sh:predicate</code>, P) are in S 
							then N consists of all the nodes X such that (F, P, X) is in D.</li>
					</ul>
					<p>
						Let the value of the <code>sh:partition</code> parameter be the list (Q<sub>1</sub>, ..., Q<sub>n</sub>) of resources.
						The SHACL processor MUST perform the following steps to validate the constraint C at F.
					</p>
					<ol>
						<li>Let R denote the set of remaining value nodes. Initialize R to N.</li>
						<li>Repeat the following for Q = Q<sub>1</sub>, ..., Q<sub>n</sub>
						<ol>
							<li>Let P be the conjunction of all the node validation constraints in Q.</li>
							<li>Compute R' to be the set of all nodes in R that satisfy P, i.e. R' = {X in R | P(X) = true}</li>
							<li>If Q contains a minimum cardinality m<sub>min</sub> and the number of nodes in R' is less than m<sub>min</sub>,
							i.e. m<sub>min</sub> > #R', then report a constraint violation and exit the loop.</li>
							<li>If Q contains a maximum cardinality m<sub>max</sub> and the number of nodes in R' is greater then m<sub>max</sub>,
							i.e. m<sub>max</sub> &lt; #R', then report a constraint violation and exit the loop.</li>
							<li>Remove R' from R, i.e. set R = R \ R'.</li>
						</ol>
						</li>
						<li>If R is non-empty and no violations have been reported yet then report a violation.</li>
					</ol>
					<p>
						Note that the order of resources within the list is significant. 
						In general, if the members of the list are reordered then different value node sets will be matched
						and different violation results will be reported.
					</p>
				</section>
			</section>
			
			<section id="constraints-others">
				<h3>Other Constraint Components</h3>
				<p>
					This section enumerates Core constraint components that did not fit into the other categories.
				</p>
				
				<section id="ClosedConstraintComponent">
					<h3>sh:closed, sh:ignoredProperties</h3>
					<p>
						The RDF data model offers a huge amount of flexibility.
						Any resource can in principle have values for any property.
						However, in some cases it makes sense to restrict which properties can be applied to resources.
						The SHACL Core language includes a property called <code>sh:closed</code> that can be assigned to
						a shape via the property <code>sh:constraint</code> to indicate that valid resources must only have
						values for those properties that have been explicitly declared via <code>sh:property</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ClosedConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:closed</code></td>
							<td><code>xsd:boolean</code></td>
							<td>Set to <code>true</code> to close the shape</td>
						</tr>
						<tr>
							<td><code>sh:ignoredProperties</code></td>
							<td><code>rdf:List</code> (members: <code>rdf:Property</code>)</td>
							<td>Optional list of properties that are also permitted in addition to those explicitly enumerated via <code>sh:property</code></td>
						</tr>
					</table>
					<div id="def-ClosedShape-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							If <code>sh:closed</code> is <code>true</code> then
							a <a>validation result</a> must be produced for each <a>triple</a> that has the <a>focus node</a> as its
							<a>subject</a> and a <a>predicate</a> that is not explicitly enumerated as a <code>sh:predicate</code>
							in any of the <code>sh:property</code> constraints at the surrounding shape.
							If the parameter <code>sh:ignoredProperties</code> is present then the properties enumerated in this list are also permitted.
							The produced <a>validation result</a> must have the predicate of the triple as its <code>sh:path</code>,
							and the object of the triple as its <code>sh:value</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results)</div>
<pre class="def-sparql-body">
SELECT $this (?predicate AS ?path) ?value
WHERE {
	{
		FILTER ($closed) .
	}
	$this ?predicate ?value .
	FILTER (NOT EXISTS {
		GRAPH $shapesGraph {
			$currentShape sh:property/sh:predicate ?predicate .
		}
	} &amp;&amp; (!bound($ignoredProperties) || NOT EXISTS {
		GRAPH $shapesGraph {
			$ignoredProperties rdf:rest*/rdf:first ?predicate .
		}
	}))
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:closed</code> in a shape to verify
						that certain nodes only have values for <code>ex:exampleProperty1</code> and <code>ex:exampleProperty2</code>.
						The "ignored" property <code>rdf:type</code> would also be allowed.
					</p>
					<pre class="example-shapes">
ex:ClosedShapeExampleShape
	a sh:Shape ;
	sh:targetNode ex:Alice, ex:Bob ;
	sh:closed true ;
	sh:ignoredProperties (rdf:type) ;
	sh:property [
		sh:predicate ex:firstName ;
	] ;
	sh:property [
		sh:predicate ex:lastName ;
	] .</pre>

					<pre class="example-data">
ex:Alice
	ex:firstName "Alice" .

<span class="focus-node-error">ex:Bob</span>
	ex:firstName "Bob" ;
	ex:middleInitial "J" .</pre>
				</section>
				
				<section id="HasValueConstraintComponent">
					<h4>sh:hasValue</h4>
					<p>
						The property <code>sh:hasValue</code> can be used to verify that one of the <a>value nodes</a> is a given RDF node.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:HasValueConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:hasValue</code></td>
							<td>any</td>
							<td>A specific required value</td>
						</tr>
					</table>
					<div id="def-hasValue-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <a>validation result</a> must be produced if the node specified by <code>sh:hasValue</code> is not among the <a>value nodes</a>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must return no results for the given $PATH)</div>
<pre class="def-sparql-body">
SELECT $this
WHERE {
	FILTER NOT EXISTS { $this $PATH $hasValue }
}</pre>
					</div>
					<pre class="example-shapes">
ex:StanfordGraduate
	a sh:Shape ;
	sh:targetNode ex:Alice ;
	sh:property [
		sh:predicate ex:alumniOf ;
		sh:hasValue ex:Stanford ;
	] .</pre>

					<pre class="example-data">
ex:Alice
	ex:alumniOf ex:Harvard ;
	ex:alumniOf ex:Stanford .</pre>
				</section>
				
				<section id="InConstraintComponent">
					<h4>sh:in</h4>
					<p>
						The property <code>sh:in</code> exclusively enumerates the permitted <a>value nodes</a>.
						For example when specified as part of a <a>property constraint</a>, then each <a>value</a> of the given property must be a member of the specified list.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:InConstraintComponent</code>
					</p>

					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:in</code></td>
							<td><code>rdf:List</code></td>
							<td>Enumeration of allowed values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:in</code> must be well-formed <code>rdf:List</code>s.
							The members of that <code>rdf:List</code> must not be blank nodes.
							A <a>validation result</a> must be produced for every <a>value node</a>
							that is not a member of the given list.
							Matching of literals needs to be exact, e.g. <code>"04"^^xsd:byte</code> does not match <code>"4"^^xsd:integer</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (Must evaluate to true for each value node $value)</div>
<pre class="def-sparql-body">
ASK {
	GRAPH $shapesGraph {
		$in (rdf:rest*)/rdf:first $value .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:InExampleShape
	a sh:Shape ;
	sh:targetNode ex:RainbowPony ;
	sh:property [
		sh:predicate ex:color ;
		sh:in ( ex:Pink ex:Purple ) ;
	] .</pre>

					<pre class="example-data">
ex:RainbowPony ex:color ex:Pink .</pre>
				</section>
			</section>
				
			<section id="nonValidation">
				<h4>Non-Validating Constraint Characteristics</h4>
				<p>
					While the previous sections introduced properties that represent validation conditions,
					this section covers properties that are ignored by SHACL processors.
					The use of these properties is entirely optional and not subject to formal interpretation contracts.
					They may be used for purposes such as form building or predictable printing of RDF files.
				</p>
				<p id="name">
					Property constraints may have one or more <a>values</a> for <code>sh:name</code> to provide human-readable labels for the property in the target where it appears.
					If present, tools SHOULD prefer those locally defined labels over globally defined labels at the <code>rdf:Property</code> itself.
					For example, if a form displays a resource that is in the target of a given shape, and the shape defines a <code>sh:property</code> constraint with an <code>sh:name</code>, then the tool SHOULD use the provided name.
					Similarly, property constraints may have an <code id="description">sh:description</code> to provide a description of the property in the given context.
					Both <code>sh:name</code> and <code>sh:description</code> may have multiple <a>values</a>, but SHOULD only have one <a>value</a> per language tag.
				</p>
				<p id="order">
					Property constraints may have one <a>value</a> for the property <code>sh:order</code> to indicate the relative order of the property constraint for purposes such as form building.
					The values of <code>sh:order</code> must be decimals.
					<code>sh:order</code> is not used for validation purposes.
					If present, the recommended use of <code>sh:order</code> is to sort the property constraints in an ascending order, for example so that
					properties with smaller order are placed above (or to the left) of properties with larger order.
				</p>
				<p id="group">
					Property constraints may link to an <a>SHACL instance</a> of the class <code>sh:PropertyGroup</code> using the property <code>sh:group</code> to indicate that
					the constraint belongs to a group of related property constraints.
					Each group may have additional triples that serve application purposes, such as an <code>rdfs:label</code> for form building.
					Groups may also have an <code>sh:order</code> property to indicate the relative ordering of groups within the same form.
				</p>
				<p id="defaultValue">
					Property constraints may have a single value for <code>sh:defaultValue</code>.
					The default value does not have fixed semantics in SHACL, but MAY be used by user interface tools to pre-populate input widgets.
					The value type of the <code>sh:defaultValue</code> SHOULD align with the specified <code>sh:datatype</code> or <code>sh:class</code> of the same constraint.
				</p>
				<p>
					The following example illustrates the use of these various features together.
				</p>
				<pre class="example-shapes">
ex:PersonFormShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:firstName ;
		sh:name "first name" ;
		sh:description "The person's given name(s)" ;
		sh:order 0 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:predicate ex:lastName ;
		sh:name "last name" ;
		sh:description "The person's last name" ;
		sh:order 1 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:predicate ex:streetAddress ;
		sh:name "street address" ;
		sh:description "The street address including number" ;
		sh:order 11 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:predicate ex:locality ;
		sh:name "locality" ;
		sh:description "The suburb, city or town of the address" ;
		sh:order 12 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:predicate ex:postalCode ;
		sh:name "postal code" ;
		sh:name "zip code"@en-US ;
		sh:description "The postal code of the locality" ;
		sh:order 13 ;
		sh:group ex:AddressGroup ;
	] .

ex:NameGroup
	a sh:PropertyGroup ;
	sh:order 0 ;
	rdfs:label "Name" .

ex:AddressGroup
	a sh:PropertyGroup ;
	sh:order 1 ;
	rdfs:label "Address" .</pre>
				<p>
					A form building application may use the information above to display information as follows:
				</p>
				<div style="background: #f3f3f3; padding: 8px">
					<div style="font-size: 18px; color: #0000a0"><b>Name</b></div>
					<table>
						<tr>
							<td style="text-align: right; width: 160px"><b>first name:</b></td>
							<td>John</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>last name:</b></td>
							<td>Doe</td>
						</tr>
					</table>
					<div style="font-size: 18px; padding-top: 6px; color: #0000a0"><b>Address</b></div>
					<table>
						<tr>
							<td style="text-align: right; width: 160px"><b>street address:</b></td>
							<td>123 Silverado Ave</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>locality:</b></td>
							<td>Cupertino</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>zip code:</b></td>
							<td>54321</td>
						</tr>
					</table>
				</div>
			</section>
		</section>

		<div style="padding-top: 30px">
			<h1 id="part2" style="font-size: 160%; font-weight: bold">Part 2: SHACL Full</h1>
			<p>
				Part 1 of this specification introduced features that are built into the Core of SHACL.
				The goal of this Core was to provide a high-level vocabulary for common use cases to describe shapes.
				However, SHACL also provides mechanisms to go beyond the Core vocabulary and represent constraints and targets with greater flexibility.
				These mechanisms, called <a>SHACL Full</a>, are described in the following sections.
			</p>
		</div>
		
		<section id="sparql-constraints">
			<h2>SPARQL-based Constraints</h2>
			<p>
				SHACL Full supports two mechanisms to define constraints using SPARQL:
			</p>
			<ul>
				<li>Constraints based on a high-level vocabulary (<a href="#constraint-components">constraint components</a>), relying on a reusable SPARQL query in the background</li>
				<li>Constraints directly based on a SPARQL query</li>
			</ul>
			<p>
				The following sub-sections are about the latter.
			</p>
			<section id="sparql-constraints-syntax">
				<h3>Syntax of SPARQL-based Constraints</h3>
				<p>
					<code>sh:SPARQLConstraint</code> is an <code>rdfs:subClassOf sh:Constraint</code> and is the class of all SPARQL-based constraints.
					SPARQL-based constraints must have exactly one value for the property <code>sh:select</code>.
					The SPARQL queries linked to a <a>constraint</a> via <code>sh:select</code> must be string literals that can be parsed into legal SPARQL 1.1 queries
					of the query form <code>SELECT</code> after they have been treated with the <a href="#sparql-prefixes">prefix handling rules</a> outlined later.
				</p>
				<p>
					The following example illustrates the definition of a SPARQL-based constraint.
				</p>
				<pre class="example-data">
ex:ValidCountry a ex:Country ;
	ex:germanLabel "Spanien"@de .
  
<span class="focus-node-error">ex:InvalidCountry</span> a ex:Country ;
	ex:germanLabel "Spain"@en .</pre>
				<pre class="example-shapes" id="example-sparql-constraint">
ex:LanguageExampleShape
	a sh:Shape ;
	sh:targetClass ex:Country ;
	sh:sparql [
		a sh:SPARQLConstraint ;   # This triple is optional
		sh:message "Values must be literals with German language tag." ;
		sh:prefixes ex: ;
		sh:select """
			SELECT $this (ex:germanLabel AS ?path) ?value
			WHERE {
				$this ex:germanLabel ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), "de"))
			}
			""" ;
	] .</pre>
				<p>
					The target of the shape above includes all <a>SHACL instances</a> of <code>ex:Country</code>.
					For those RDF nodes (represented by the variable <code>this</code>), the SPARQL query walks through the values of <code>ex:germanLabel</code>
					and verifies that they are literals with a German language code.
					The validation results for the aforementioned data graph is shown below:
				</p>
				<pre class="example-results">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:InvalidCountry ;
	sh:path ex:germanLabel ;
	sh:value "Spain"@en ;
	sh:sourceShape ex:LanguageExampleShape ;
	...
]
</pre>
				<p>
					The SPARQL query returns result set rows for all bindings of <code>?value</code> that violate the constraint.
					A validation result is produced for each row in that result set, following the <a href="#sparql-constraints-variables">mapping rules</a> explained later:
					Each validation result will have <code>$this</code> as the <code>sh:focusNode</code>,
					<code>ex:germanLabel</code> as <code>sh:path</code> and the violating value as <code>sh:value</code>.
				</p>
				<!--p>
					In the example above, it is assumed that the existing SHACL validation engine is capable of evaluating constraints using SPARQL.
					Additional executable languages such as JavaScript may be provided based on other sets of properties like <code>ex:javaScript</code>,
					but that is outside of the target of this specification.
				</p-->
			</section>
			<section id="sparql-prefixes">
				<h4>Prefix Declarations for SPARQL Queries</h4>
				<p>
					Before parsing the values of <code>sh:select</code> (or similar properties such as <code>sh:ask</code>),
					a SHACL Full processor must prepend <a href="https://www.w3.org/TR/sparql11-query/#rPrefixDecl"><code>PREFIX</code></a> declarations
					for all namespace prefixes that are linked to the <a>subject</a> of the <code>sh:select</code> triple
					via the property <code>sh:prefixes</code> in the current <a>shapes graph</a>.
					An example use of the <code>sh:prefixes</code> property can be found in the
					<a href="#example-sparql-constraint">example</a> above.
					The syntax of such prefix declarations is illustrated by the following example.
				</p>
				<pre class="example-shapes">
ex:
	a owl:Ontology ;
	owl:imports sh: ;
	sh:declare [
		sh:prefix "ex" ;
		sh:namespace "http://example.com/ns#"^^xsd:anyURI ;
	] ;
	sh:declare [
		sh:prefix "schema" ;
		sh:namespace "http://schema.org/"^^xsd:anyURI ;
	] .</pre>
				<p>
					The values of <code>sh:prefixes</code> must be <a>IRIs</a> or <a>blank nodes</a>.
					Each value of <code>sh:prefixes</code> may have values for the property <code>sh:declare</code>
					to point at an IRI or blank node that defines a prefix for a given namespace IRI.
					The SHACL vocabulary defines the class <code>sh:PrefixDeclaration</code> for these nodes,
					although no <code>rdf:type</code> triple is required.
					The values of <code>sh:declare</code> must have
					exactly one value for the property <code>sh:prefix</code> (<a>literals</a> of type <code>xsd:string</code>) and
					exactly one value for the property <code>sh:namespace</code> (<a>literals</a> of type <code>xsd:anyURI</code>).
				</p>
				<p>
					The recommended <a>subject</a> for values of <code>sh:declare</code> is the IRI of the graph defining the shapes that use the prefixes.
					These IRIs are often declared as an instance of <code>owl:Ontology</code>, but this is not required.
					The <a>subjects</a> of <code>sh:declare</code> triples may link to other prefix declarations using
					the property <code>owl:imports</code>.
					By transitively following the <code>owl:imports</code> links from a node containing prefix declarations,
					SHACL Full processors can collect pairs of prefix/namespace declarations, reusing declarations from other sub-graphs.
					If such a collection of prefix declarations contains multiple namespaces for the same <code>sh:prefix</code>,
					then the <a>shapes graph</a> is invalid.
				</p>
				<p>
					Before a SHACL Full processor parses a SPARQL query string, it MUST prepend any <code>PREFIX</code> declarations based on
					the collection of prefixes that is retrieved from all values of <code>sh:prefixes</code> and their transitive <code>owl:imports</code>.
					Each value of <code>sh:prefix</code> is turned into the <code>PNAME_NS</code>, while each value of <code>sh:namespace</code> is turned
					into the <code>IRIREF</code> in the <code>PREFIX</code> declaration.
					For the example shapes graph above, a SHACL Full processor would produce lines such as <code>PREFIX ex: &lt;http://example.com/ns#&gt;</code>.
					The resulting list of <code>PREFIX</code> declarations must be inserted before the SPARQL fragments (e.g. values of <code>sh:select</code>).
					The SHACL Full processor must produce a <a>failure</a> if the resulting SPARQL query string cannot be parsed into a valid SPARQL 1.1 query.
					In the rest of this document, the <code>sh:prefixes</code> statements may have been omitted for brevity.
				</p>
			</section>
			<section id="sparql-constraints-prebound">
				<h4>Pre-bound Variables in SPARQL Constraints ($this, $shapesGraph, $currentShape)</h4>
				<p>
					The following table enumerates variables that have special meaning in SPARQL constraints.
					When SPARQL constraints are executed, the SHACL Full processor <a>pre-binds</a> values for these variables.
				</p>
				<table class="term-table">
					<tr>
						<th>Variable</th>
						<th>Interpretation</th>
					</tr>
					<tr>
						<td><code>$this</code></td>
						<td>
							The <a>focus node</a>.
						</td>
					</tr>
					<tr>
						<td><code style="white-space: nowrap">$shapesGraph</code></td>
						<td>
							Can be used to query the shapes graph as in <code>GRAPH $shapesGraph { ... }</code>.
							If the shapes graph is a named graph in the same dataset as the data graph then it is the IRI of the shapes graph in the dataset.
							Not all SHACL Full processors need to support this variable.
							Processors that do not support <code>$shapesGraph</code> MUST report a <a>failure</a> if they encounter a query that references this variable.
							Use of <code>GRAPH $shapesGraph { ... }</code> should be handled with extreme caution.
							It may result in constraints that are not interoperable across different SHACL Full processors and that may not run on remote RDF datasets.
						</td>
					</tr>
					<tr>
						<td><code style="white-space: nowrap">$currentShape</code></td>
						<td>
							The currently validated shape.  Typically used in conjunction with <code>$shapesGraph</code>.
							The same support policies as for <code>$shapesGraph</code> apply for this variable.
						</td>
					</tr>
				</table>
			</section>
			<section id="sparql-constraints-variables">
				<h4>Mapping of Result Variables to Validation Results</h4>
				<p>
					If one of the rows of the result set produced by a SELECT query contains the binding <code>true</code>
					for the variable <code>failure</code>, then the SHACL Full processor must signal a <a>failure</a>.
				</p>
				<p>
					Otherwise, each row of the result set produced by a SELECT query must be converted into one validation result resource.
					The properties of those resources are derived by the following rules, through a combination of result variables and the properties linked to the constraint itself.
					The production rules are meant to be executed from top to bottom, so that the first bound value will be used.
				</p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Production Rules</th>
					</tr>
					<tr>
						<td><code>sh:severity</code></td>
						<td>
							<ol>
								<li>The value of <code>sh:severity</code> of the constraint node</li>
								<li>For <a>constraint components</a>, the value of <code>sh:severity</code> of the constraint component resource</li>
								<li><code>sh:Violation</code> as default</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:focusNode</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>focusNode</code></li>
								<li>The value of the variable <code>this</code></li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:path</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>path</code> (only supports property IRIs, no complex paths)</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:value</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>value</code></li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:message</code></td>
						<td>
							<ol>
								<li>The value of the variable <code>message</code></li>
								<li>
									The values of <code>sh:message</code> of the subject of the <code>sh:select</code> or <code>sh:ask</code> triple.
									These string literals may reference any value of the SELECT result variables via <code>{?varName}</code> or <code>{$varName}</code>.
									If the constraint is based on a <a href="#constraint-components">constraint component</a>, then the component's parameter variables can also be used.
									The <code>{?varName}</code> blocks SHOULD be substituted with suitable string representations of the values of said variables.
								</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:sourceConstraint</code></td>
						<td>
							<ol>
								<li>The <a>constraint</a> that was validated against</li>
							</ol>
						</td>
					</tr>
					<tr>
						<td><code>sh:sourceShape</code></td>
						<td>
							<ol>
								<li>The <a>shape</a> that was validated against</li>
							</ol>
						</td>
					</tr>
				</table>
			</section>
			<section id="sparql-constraints-annotations">
				<h4>Injecting Annotation Properties into Validation Results</h4>
				<p>
					It is possible to inject additional <span class="term">annotation properties</span> into the validation result resources created for each row of the SELECT result sets.
					Any such property needs to be declared via a value of <code>sh:resultAnnotation</code> at the subject holding the <code>sh:select</code> or <code>sh:ask</code> triple.
					The values of <code>sh:resultAnnotation</code> must be IRIs or blank nodes with the following properties:
				</p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Value type</th>
						<th>Count</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>sh:annotationProperty</code></td>
						<td><code>rdf:Property</code></td>
						<td><code>1&nbsp;(mandatory)</code></td>
						<td>The annotation property that shall be set</td>
					</tr>
					<tr>
						<td><code>sh:annotationVarName</code></td>
						<td><code>xsd:string</code></td>
						<td><code>0..1</code></td>
						<td>The name of the SPARQL variable to take the values from</td>
					</tr>
					<tr>
						<td><code>sh:annotationValue</code></td>
						<td></td>
						<td><code>0..unlimited</code></td>
						<td>Constant nodes that shall be used as default values</td>
					</tr>
				</table>
				<p>
					For each row of a SELECT result set, a SHACL Full processor must walk through the declared result annotations.
					The mapping from result annotations to SPARQL variables uses the following rules:
				</p>
				<ol>
					<li>If a <code>sh:resultAnnotation</code> defines a <code>sh:annotationVarName</code> then the SHACL Full processor must look for the variable named after the <code>sh:annotationVarName</code></li>
					<li>Otherwise, the SHACL Full processor must derive a variable name from the value of <code>sh:annotationProperty</code> using the same <a>local name</a> mechanism as described earlier</li>
				</ol>
				<p>
					If a variable name could be determined, then the SHACL Full processor must copy the bindings for the given variable into the constructed validation results for the current row.
					If the variable has no binding in the result set row, then the value of <code>sh:annotationValue</code> must be used, if present.
				</p>
				<p>
					The values of <code>sh:annotationProperty</code> must not be from the SHACL namespace, to avoid clashes with variables that are already produced by other means.
				</p>
				<p>
					Here is a slightly complex example, illustrating the use of result annotations.
				</p>
				<pre class="example-shapes">
ex:ShapeWithPathViolationExample
	a sh:Shape ;
	sh:targetNode ex:ExampleRootResource ;
	sh:sparql [
		sh:resultAnnotation [
			sh:annotationProperty ex:time ;
			sh:annotationVarName "time"
		] ;
		sh:select """
			SELECT $this (ex:property1 AS ?path) (?first AS ?value) ?message ?time
			WHERE {
				$this ex:property1 ?first .
				?subject ex:property2 ?first .
				FILTER isBlank(?value) .
				BIND (CONCAT("The ", "message.") AS ?message) .
				BIND (NOW() AS ?time) .
			}
			""" ;
	] .</pre>

				<pre class="example-data">
ex:ExampleRootResource
	ex:property1 ex:ExampleIntermediateResource .

ex:ExampleValueResource
	ex:property2 ex:ExampleIntermediateResource .
</pre>
				<p>
					Which produces the following validation result resource:
				</p>
				<pre class="example-results">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:ExampleRootResource ;
	sh:path ex:property1 ;
	sh:value ex:ExampleIntermediateResource ;
	sh:message "The message." ;
	sh:sourceConstraint [ the blank node of the sh:sparql above ] ;
	sh:sourceShape ex:ShapeWithPathViolationExample ;
	ex:time "2015-03-27T10:58:00"^^xsd:dateTime ;  # Example
] .</pre>
			</section>
		</section>
		
		<section id="constraint-components">
			<h2>SPARQL-based Constraint Components</h2>
			<p>
				SPARQL-based constraints as introduced in the previous section provide a lot of flexibility.
				However, SPARQL-based constraints may be hard to understand for some people or lead to repetition.
				<a>Constraint components</a> are a way to abstract the complexity of SPARQL and define high level reusable components similar to the <a href="#constraints">Core constraint components</a>.
				The definition of such constraint components can be represented in the SHACL RDF vocabulary and thus shared and reused.
			</p>
			<p>
				<code>sh:ConstraintComponent</code> is the class of all constraint components.
				Each constraint component must define:
			</p>
			<ul>
				<li>one or more <a href="#constraint-components-parameters">parameters</a> (e.g. <code>sh:class</code>, <code>sh:stem</code>)</li>
				<li>at least one <a href="#constraint-components-validators">validator</a></li>
			</ul>
			<section class="informative">
				<h3>An Example Constraint Component</h3>
				<p>
					The following example demonstrates how SPARQL can be used to define new constraint components using the SHACL Full language.
					The example implements <a href="#PatternConstraintComponent"><code>sh:pattern</code> and <code>sh:flags</code></a> using a <a href="#SPARQLAskValidator">SPARQL ASK</a> query to validate that each <a>value node</a> matches a given regular expression.
					Note that this is only an example implementation and should not be considered normative.
				</p>
				<pre class="example-shapes" title="Constraint component based on SPARQL">
sh:PatternConstraintComponent
	a sh:ConstraintComponent ;
	sh:parameter [
		sh:predicate sh:pattern ;
		sh:order 0 ;
	] ;
	sh:parameter [
		sh:predicate sh:flags ;
		sh:optional true ;
		sh:order 1 ;
	] ;
	sh:validator shimpl:hasPattern .

shimpl:hasPattern
	a sh:SPARQLAskValidator ;
	sh:message "Value does not match pattern {$pattern}" ;
	sh:ask "ASK { FILTER (!isBlank($value) &amp;&amp; IF(bound($flags), regex(str($value), $pattern, $flags), regex(str($value), $pattern))) }" .</pre>
				<p>
					The following sections introduce the properties that <a>constraint components</a> may have.
					Some of these properties are independent of SPARQL-based execution and apply
					to constraint components based on other potential extension languages such as JavaScript too.
				</p>
			</section>
			<section id="constraint-components-parameters">
				<h3>Parameters Declaration (sh:parameter)</h3>
				<p>
					The parameters of a <a>constraint component</a> are declared via the property <code>sh:parameter</code>.
					Each parameter must be a <a>SHACL instance</a> of <code>sh:Parameter</code>, but the <code>rdf:type</code> triples can be omitted.
				</p>
				<p class="issue" data-number="107" title="Specifying SPARQL variable name">
					There is an open issue about the relationship between SPARQL variable name and sh:predicate.
					Possible revisions may require an additional property similar to sh:annotationVarName.
				</p>
				<p>
					Each <code>sh:Parameter</code> must have exactly one value <code>p</code> for the property <code>sh:predicate</code> and the value must be an IRI.
					The <dfn data-lt="local names">local name</dfn> of an <a>IRI</a> is defined as the longest <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCNAME</a>
					at the end of the <a>IRI</a>, not immediately preceded by the first colon in the <a>IRI</a>.
					The <dfn data-lt="parameter names">parameter name</dfn> is defined as the <a>local name</a> of the <a>value</a> of <code>sh:predicate</code>.
					To ensure that a correct mapping from parameters into SPARQL variables is possible, every <a>parameter name</a>:
				</p>
				<ul>
					<li>Must be a valid <a href="http://www.w3.org/TR/sparql11-query/#rVARNAME">SPARQL VARNAME</a></li>
					<li>Must not be equal to <code>this</code>, <code>shapesGraph</code>, <code>currentShape</code>, <code>focusNode</code>, <code>predicate</code>, <code>path</code> or <code>value</code>.</li>
					<li>Must not be equal to another <a>parameter name</a> in the same <a>constraint component</a></li>
				</ul>
				<p>
					An <code>sh:Parameter</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the parameter is not mandatory.
					Every <code>sh:ConstraintComponent</code> must have at least one non-optional parameter.
				</p>
				<p>
					The class <code>sh:Parameter</code> is defined as a <a>SHACL subclass</a> of <code>sh:PropertyConstraint</code>,
					and all properties that are applicable to property constraints may also be used for parameters.
					This includes descriptive properties such as <code>sh:name</code> and <code>sh:description</code>
					but also constraint parameters such as <code>sh:class</code>.
					Some implementations MAY use these constraint parameters to prevent the execution of constraint components with invalid parameter values.
				</p>
				<section id="constraint-components-parameter-pre-binding">
					<h4>Parameter pre-binding</h4>
					<p>
						Every <a>parameter name</a> defines a <a>pre-bound</a> variable for the <a>constraint component</a> the parameter belongs to.
						This variable can be used in the SPARQL definition of the <a>constraint component</a>  and a SHACL Full processor MUST <a>pre-bind</a> it to the parameter value.
					</p>
				</section>
			</section>
			<section id="labelTemplate">
				<h3>Label Templates (sh:labelTemplate)</h3>
				<p>
					The property <code>sh:labelTemplate</code> can be used at any <a>constraint component</a> to suggest how they could be rendered to humans.
					The values of <code>sh:labelTemplate</code> must be strings (possibly with language tag) that can reference the values of the declared parameters using the syntax <code>{?varName}</code> or <code>{$varName}</code>,
					where <code>varName</code> is the name of the SPARQL variable that corresponds to the parameter.
					At display time, these <code>{...}</code> blocks SHOULD be substituted with the actual parameter values.
					There may be multiple label templates for the same subject, assuming they do not have the same language tags.
				</p>
			</section>
			<section id="constraint-components-validators">
				<h3>Validators</h3>
				<p>
					For every supported context (i.e., <a>property constraint</a> or <a>shape</a>)
					the constraint component must declare a suitable <dfn>validator</dfn>.
					For a given constraint, a validator is selected from the constraint component using the following rules:
				</p>
				<ol>
					<li>For <a>shapes</a>, use one of the values of <code>sh:shapeValidator</code>, if present.</li>
					<li>For <a>property constraints</a>, use one of the values of <code>sh:propertyValidator</code>, if present.</li>
					<li>Otherwise, use one of the values of <code>sh:validator</code>.
				</ol>
				<p>
					If no suitable validator can be found, a SHACL Full processor ignores the constraint.
					<span class="todo">The SHACL WG is seeking practical feedback on what the default behavior should be, and
					whether we should report violations in those cases.</span>
				</p>
				<p>
					SHACL Full includes two types of validators, based on <a href="#SPARQLSelectValidator">SPARQL SELECT</a> (for <code>sh:shapeValidator</code> and <code>sh:propertyValidator</code>)
					or <a href="#SPARQLAskValidator">SPARQL ASK</a> queries (for <code>sh:validator</code>).
				</p>
				<section id="SPARQLSelectValidator">
					<h3>Validators based on SPARQL SELECT Queries</h3>
					<p>
						Validators that have the <code>rdf:type</code> <code>sh:SPARQLSelectValidator</code> must point at exactly one string representation of a SPARQL SELECT query via the property <code>sh:select</code>.
						The value of <code>sh:select</code> must be a valid SPARQL query using the aforementioned <a href="#sparql-prefixes">prefix handling rules</a>.
						This type of validator can be used as values of <code>sh:shapeValidator</code> or <code>sh:propertyValidator</code>.
					</p>
					<p>
						The following example illustrates the definition of a constraint component based on a SPARQL SELECT query.
						It is a generalized variation of the SPARQL-based example constraint from the <a href="#example-sparql-constraint">section on SPARQL-based constraints</a>.
						That SPARQL query included two constants: the specific property <code>ex:germanLabel</code> and the language tag <code>de</code>.
						Constraint components make it possible to generalize such scenarios, so that constants get <a>pre-bound</a> with <a>parameters</a>.
						This allows the query logic to be reused in multiple places, without having to write any new SPARQL.
					</p>
					<pre class="example-shapes" title="Constraint component based on SPARQL">
ex:LanguageConstraintComponentUsingSELECT
	a sh:ConstraintComponent ;
	rdfs:label "Language constraint component" ;
	sh:parameter [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:minLength 2 ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values must be literals with language \"{$lang}\"" ;
	sh:propertyValidator [
		a sh:SPARQLSelectValidator ;
		sh:message "Values must be literals with language \"{?lang}\"" ;
		sh:select """
			SELECT $this ?value
			WHERE {
				$this $PATH ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), $lang))
			}
			"""
	] .</pre>
					<p>
						Once a constraint component has been defined, its parameters can be used as illustrated in the following example.
					</p>
					<pre class="example-shapes" title="Shape definition using ex:LanguageConstraintComponent">
ex:LanguageExampleShape
	a sh:Shape ;
	sh:targetClass ex:Country ;
	sh:property [
		sh:predicate ex:germanLabel ;
		ex:lang "de" ;
	] ;
	sh:property [
		sh:predicate ex:englishLabel ;
		ex:lang "en" ;
	] .</pre>
					<p>
						The example shape above specifies that all values of <code>ex:germanLabel</code> must carry the language tag <code>de</code>
						while all values of <code>ex:englishLabel</code> must have <code>en</code> as their language.
						These details are specified via two property constraints that provide values for the <code>ex:lang</code> parameter required by the constraint component.
					</p>
					<p>
						SELECT queries used in the context of <a>property constraints</a> must use a special variable named <code>PATH</code> as a placeholder for the predicate or path
						used by the constraint.
						The only legal use of this variable is in the <a>predicate</a> position of a <a href="https://www.w3.org/TR/sparql11-query/#QSynTriples">triple pattern</a>.
						A query that uses the variable <code>PATH</code> in any other position is invalid.
						Furthermore, any query that uses the variable <code>this</code> as part of the Expression used in a SPARQL 1.1 <a href="https://www.w3.org/TR/sparql11-query/#rAggregate">Aggregate</a>
						is invalid. <!-- HK: This is because otherwise this would prevent implementations from injecting a loop over all target nodes into the beginning of the query -->
					</p>
					<p id="SPARQLSelectValidator-evaluation">
						A SHACL Full processor executes the provided SPARQL query on the data graph to produce validation results.
						In the context of <a>property constraints</a>, the SHACL Full processor will first substitute all occurrences of the variable <code>PATH</code>
						with the provided <a>property path</a> derived from the value of either <code>sh:predicate</code> or <code>sh:path</code> in the constraint.
						The resulting SPARQL query is then evaluated with the same <a>pre-bound variables</a>
						as outlined in the section for <a href="#sparql-constraints-prebound">SPARQL-based Constraints</a> (<code>$this</code> etc).
						Additionally, the value of each declared <a>parameter</a> of the constraint component needs to be pre-bound for
						the variable derived by the <a>local name</a> of the parameter's <code>sh:predicate</code>.
						For example, if a non-optional parameter declares <code>sh:predicate ex:lang</code> then the variable <code>lang</code> needs to be pre-bound.
						The result set of the SELECT query is turned into validation results using the same rules as outlined in the section for <a href="#sparql-constraints-variables">SPARQL-based Constraints</a>.
						In addition to the result properties listed in that section, the property <code>sh:sourceConstraintComponent</code> MUST point at the
						IRI of the constraint component that has been evaluated.
						Furthermore, a <code>sh:SPARQLSelectValidator</code> may declare additional <a href="#sparql-constraints-annotations">annotation properties</a> via <code>sh:resultAnnotation</code>.
					</p>
				</section>
				<section id="SPARQLAskValidator">
					<h3>Validators based on SPARQL ASK Queries</h3>
					<p>
						Many constraint components are of the form in which all <a>value nodes</a> are tested individually against some boolean condition.
						Writing SELECT queries for these becomes burdensome, especially if a constraint component can be used for both <a>property constraints</a> and <a>shapes</a>.
						SHACL Full provides an alternative, more compact syntax for validators based on ASK queries.
						This type of validators can be used as values of the property <code>sh:validator</code>.
					</p>
					<p>
						Validators that have the <code>rdf:type</code> <code>sh:SPARQLAskValidator</code> must point at exactly one string representation of a SPARQL ASK query via the property <code>sh:ask</code>.
						The value of <code>sh:ask</code> must be a valid SPARQL query using the aforementioned <a href="#sparql-prefixes">prefix handling rules</a>.
						The ASK queries are expected to return <code>true</code> if a given <a>value node</a>
						(represented by the pre-bound variable <code>value</code>) is valid.
					</p>
					<p>
						Prior to evaluation, a SHACL Full processor transforms the provided ASK query into a SELECT query using the following templates.
						The resulting SELECT query can then be evaluated using the same algorithm as for <a href="#SPARQLSelectValidator-evaluation">SELECT-based validators</a>.
						The processor drops the ASK keyword, any top-level dataset clauses and solution modifiers, leaving only the <code>GroupGraphPattern</code> including the outermost <code>{...}</code> pair.
						This block then substitutes <code>...</code> in the template.
					</p>
					<p>Template for <code>sh:Shape</code> context:</p>
					<pre>
	SELECT $this ?value
	WHERE {
		BIND ($this AS ?value) .
		FILTER NOT EXISTS ...
	}</pre>
					<p>Template for <code>sh:PropertyConstraint</code> context:</p>
					<pre>
	SELECT $this ?value
	WHERE {
		$this $PATH ?value .
		FILTER NOT EXISTS ...
	}</pre>
					<p>
						Once the corresponding template has been applied, the resulting SELECT query will be evaluated using the same approach as outlined <a href="#SPARQLSelectValidator-evaluation">above</a>.
						Actual SHACL implementations may of course use a different approach internally, as long as the results are equivalent to the described approach.
					</p>
					<p>
						The following example defines a constraint component using an ASK query.
					</p>
					<pre class="example-shapes" title="Constraint component based on SPARQL">
ex:LanguageConstraintComponentUsingASK
	a sh:ConstraintComponent ;
	rdfs:label "Language constraint component" ;
	sh:parameter [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:minLength 2 ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values must be literals with language \"{$lang}\"" ;
	sh:validator ex:hasLang .
	
ex:hasLang
	a sh:SPARQLAskValidator ;
	sh:message "Values must be literals with language \"{$lang}\"" ;
	sh:ask """
		ASK {
			FILTER (isLiteral($value) &amp;&amp; langMatches(lang($value), $lang))
		}
		""" .</pre>
					<p>
						Note that the validation condition implemented by an ASK query is "in the inverse direction" from its SELECT counterpart:
						ASK queries return <code>true</code> for valid value nodes, while SELECT queries return the invalid value nodes.
					</p>
					<p class="todo">
						TODO: The TopBraid SHACL API uses such ASK constraint declarations to install new SPARQL functions.
						Time permitting we could standardize that too, so that people can reuse the same business logic in the queries.
					</p>
				</section>
			</section>

			<section>
				<h3>Evaluation</h3>
				<p>
					A constraint component is triggered for every <a>SHACL instance</a> of a context that defines all non-optional parameters.
					<span class="todo">TODO: This is unclear.</span>
				</p>
			</section>
		</section>

		<section id="sparql-targets">
			<h2>SPARQL-based Targets (sh:target)</h2>
			<p>
				SHACL Full provides facilities to define custom targets.
				Similar to constraints, targets may either be <a href="#SPARQLTarget"><span class="term">SPARQL-based targets</span></a> or
				<a href="#SPARQLTargetType"><span class="term">SPARQL-based target types</span></a> in a higher-level vocabulary.
				All subjects of <code>sh:target</code> triples must be IRIs.
			</p>
			<section id="SPARQLTarget">
				<h3>Targets using sh:SPARQLTarget</h3>
				<p>
					SPARQL-based targets must be <a>SHACL instances</a> of <code>sh:SPARQLTarget</code>, which is a <a>SHACL subclass</a> of <code>sh:Target</code>.
					The SPARQL queries linked to a <a>target</a> via <code>sh:select</code> must be of the query form <code>SELECT</code>.
					The SELECT queries must project to the result variable <code>this</code>.
					The resulting target consists of all distinct bindings for the variable <code>this</code>.
				</p>
				<p>
					The SELECT queries must also be executable when converted to an ASK query and with a pre-bound value for <code>?this</code>.
					The set of bindings for <code>?this</code> that return <code>true</code> for such ASK queries must be identical to the set produced by the SELECT query.
					This design makes sure that SHACL Full processors can validate whether a given shape applies to a given individual focus node.
				</p>
				<p>
					The following example illustrates a well-formed SPARQL-based target that produces all persons born in the USA:
				</p>
				<pre class="example-shapes" title="SPARQL-based target example">
ex:USCitizenShape
	a sh:Shape ;
	sh:target [
		a sh:SPARQLTarget ;
		sh:select """
			SELECT ?this
			WHERE {
				?this a ex:Person .
				?this ex:bornIn ex:USA .
			}
			""" ;
	] ;
	...</pre>
			</section>
			<section id="SPARQLTargetType">
				<h3>SPARQL-based Target Types</h3>
				<p>
					The class <code>sh:TargetType</code> can be used to define high-level vocabularies for targets.
					Similar to constraint components, such targets take <a>parameters</a> that are interpreted when the target is evaluated.
					The class <code>sh:SPARQLTargetType</code> is an <code>rdfs:subClassOf sh:TargetType</code> for target types that define a SPARQL SELECT query via the property <code>sh:select</code>.
					Similar to constraint components, the parameter values become <a href="#pre-binding">pre-bound variables</a> in such SPARQL queries.
					The parameter values of such targets must not be blank nodes.
					All parameters of target types are expected to have <code>sh:maxCount 1</code>.
					Similar to constraint components, target types may also have values for the property <a href="#labelTemplate"><code>sh:labelTemplate</code></a>.
				</p>
				<p>
					The following example defines a new SPARQL-based parameterizable target class that takes one parameter <code>ex:country</code>
					that gets mapped into the variable <code>country</code> in the corresponding SPARQL query to determine the resulting focus nodes.
				</p>
				<pre class="example-shapes" title="Parameterized target example">
ex:PeopleBornInCountryTarget
	a sh:SPARQLTargetType ;
	rdfs:subClassOf sh:Target ;
	sh:labelTemplate "All persons born in {$country}" ;
	sh:parameter [
		sh:predicate ex:country ;
		sh:name "country" ;
		sh:description "The country that the focus nodes must be born in." ;
		sh:class ex:Country ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
		sh:nodeKind sh:IRI ;
	] ;
	sh:select """
		SELECT ?this
		WHERE {
			?this a ex:Person .
			?this ex:bornIn $country .
		}
		""" .

ex:USCitizenShape
	a sh:Shape ;
	sh:target [
		a ex:BornInCountryTarget ;
		ex:country ex:USA ;
	] ;
	...</pre>
				<p>
					The set of target nodes produced by such a target type consists of all bindings of the variable <code>this</code> in the result set,
					when the SPARQL SELECT query has been executed with the pre-bound parameter values.
				</p>
			</section>
		</section>
		
		<section id="derivedValues">
			<h2>Derived Values Constraints</h2>
			<p>
				It is a common scenario that certain property values are derived from other values.
				For example, the area of a rectangle must be the product of width and height, or an uncle of a person is a male sibling of a parent.
				SHACL Full includes a constraint parameter <code>sh:derivedValues</code> that can be used with property constraints to define such constraints.
			</p>
			<p>
				<span class="component-class">Constraint Component:</span> <code>sh:DerivedValuesConstraintComponent</code>
			</p>

			<div class="parameters">Parameters:</div>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Value Type</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><code>sh:derivedValues</code></td>
					<td><code>sh:ValuesDeriver</code></td>
					<td>An object providing instructions on how to derive the values</td>
				</tr>
			</table>
			<p>
				The values of <code>sh:derivedValues</code> must be <a>SHACL instances</a> of a <a>SHACL subclass</a> of <code>sh:ValuesDeriver</code>.
				<code>sh:SPARQLValuesDeriver</code> is the only <a>SHACL subclass</a> of <code>sh:ValuesDeriver</code> defined by SHACL Full.
				Each <code>sh:SPARQLValuesDeriver</code> must have exactly one value for the property <code>sh:select</code> that can be used to produce the values that the property is expected to have.
				The values of <code>sh:select</code> must be SPARQL SELECT queries that project into the variable <code>value</code> only.
				These queries can access the current focus node via the variable <code>this</code> and must produce bindings for the variable <code>value</code> for all derived values.
			</p>
			<div class="def def-text">
				<div class="def-header">TEXTUAL DEFINITION</div>
				<div class="def-text-body">
					Let S be the set of nodes produces by the values deriver for the <a>focus node</a>.
					A <a>validation result</a> must be produced for every <a>value node</a>
					that is not in S, and for every member of S that is not a <a>value node</a>.
					The produced <a>validation results</a> must have the <a>focus node</a> as its <code>sh:focusNode</code>,
					the <code>sh:predicate</code> or <code>sh:path</code> as its <code>sh:path</code>, and the missing or extra value as its <code>sh:value</code>.
				</div>
			</div>
			<p>
				The following example illustrates the use of <code>sh:derivedValues</code> to define a restriction
				so that the value of the property <code>ex:area</code> must be the product of the value of <code>ex:width</code> and <code>sh:height</code>.
			</p>
			<pre class="example-shapes" title="A property definition with derived values">
ex:RectangleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:width ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate ex:height ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate ex:area ;
		sh:datatype xsd:integer ;
		sh:derivedValues [
			a sh:SPARQLValuesDeriver ;
			sh:select """
				SELECT ?value
				WHERE {
					$this ex:width ?width .
					$this ex:height ?height .
					BIND (?width * ?height AS ?value) .
				}
				""" ;
		] ;
	] .</pre>
		</section>
		
		<section id="functions">
			<h2>SPARQL Functions</h2>
			<p>
				SHACL <dfn data-lt="function|SHACL function">functions</dfn> define operations that produce an RDF <a>node</a> based on zero or more <a>parameters</a> and an input RDF <a>graph</a> (or dataset).
				Functions can be called within SPARQL queries to encapsulate complex logic of other SPARQL queries, or executable logic in other languages such as JavaScript.
				However, the general declaration mechanism for SHACL functions is independent from SPARQL and may also be exploited by other environments.
			</p>
			<section id="sparql-functions-syntax">
				<h3>Syntax of SPARQL Functions</h3>
				<p>
					Functions that encapsulate a SPARQL query must be <a>SHACL instances</a> of <code>sh:SPARQLFunction</code>, which is a <a>SHACL subclass</a> of the more general class <code>sh:Function</code>.
					Such functions must provide exactly one value for either <code>sh:ask</code> or <code>sh:select</code>, linking to a SPARQL query.
				</p>
				<p>
					The following example illustrates the definition of a function based on a simple mathematical SPARQL query.
				</p>
				<pre class="example-shapes" title="SHACL function with a SPARQL body">
ex:exampleFunction
	a sh:SPARQLFunction ;
	rdfs:comment "Computes the sum of its two parameters ?op1 and ?op2." ;
	sh:parameter [
		sh:predicate ex:op1 ;
		sh:datatype xsd:integer ;
		sh:description "The first operand" ;
	] ;
	sh:parameter [
		sh:predicate ex:op2 ;
		sh:datatype xsd:integer ;
		sh:description "The second operand" ;
	] ;
	sh:returnType xsd:integer ;
	sh:select """
		SELECT ($op1 + $op2 AS ?result)
		WHERE {
		}
		""" .</pre>
				<p>
					Using the declaration above, SPARQL engines with  SHACL Full support can install a new SPARQL function based on the SPARQL 1.1 <a href="http://www.w3.org/TR/sparql11-query/#extensionFunctions">Extensible Value Testing</a> mechanism.
					Such engines are then able to handle expressions such as <code>ex:exampleFunction(40, 2)</code>, producing <code>42</code>, as illustrated in the following SPARQL query.
				</p>
				<pre class="example-shapes" title="Call of a SHACL function in a SPARQL query">
SELECT ?subject
WHERE {
	?subject ex:myProperty ?value .
	FILTER (ex:exampleFunction(?value, 2) = 42) .
}</pre>
				<p>
					The following sections introduce the properties that such functions may have.
				</p>
			</section>
			<section id="function-parameters">
				<h3>Function Parameters</h3>
				<p>
					The <a>parameters</a> of a function are linked to its <code>sh:Function</code> via the property <code>sh:parameter</code>.
					Each <a>parameter</a> must be a <a>SHACL instance</a> of <code>sh:Parameter</code>, but their <code>rdf:type</code> triple can be omitted.
				</p>
				<p>
					Each <code>sh:Parameter</code> must have exactly one <a>value</a> for the property <code>sh:predicate</code>.
					The <a>values</a> of <code>sh:predicate</code> must be <a>IRIs</a>, and follow the following restrictions:
				</p>
				<ul>
					<li>The <a>local name</a> must be a valid <a href="http://www.w3.org/TR/sparql11-query/#rVARNAME">SPARQL VARNAME</a></li>
					<li>There must not be any other declared <code>sh:Parameter</code> for the same function that has a <code>sh:predicate</code> with the same <a>local name</a></li>
				</ul>
				<p id="parameters-ordering">
					<a>Parameters</a> are ordered, corresponding to the notation of function calls in SPARQL such as
					<code>ex:exampleFunction(?param1, ?param2)</code>.
					The ordering of function <a>parameters</a> is determined as follows:
				</p>
				<ol>
					<li><a>Parameters</a> are ordered in ascending order by the numeric values of <code>sh:order</code>.</li>
					<li><a>Parameters</a> that do not declare an <code>sh:order</code> are placed after those that have.</li>
					<li><a>Parameters</a> that do not declare an <code>sh:order</code> are ordered by the <a>local names</a> of their declared <code>sh:predicate</code>s.</li>
				</ol>
				<p>
					Each <code>sh:Parameter</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the <a>parameter</a> is not mandatory.
				</p>
			</section>
			<section id="function-returnType">
				<h3>sh:returnType</h3>
				<p>
					A function may declare a single return type via <code>sh:returnType</code>.
					This information may serve for documentation purposes, only.
					However, in some execution languages such as JavaScript, the declared <code>sh:returnType</code> may inform
					a processor how to cast a native value into an <a>RDF term</a>.
				</p>
			</section>
			<section id="function-evaluation">
				<h3>Evaluation of Functions</h3>
				<p>
					<a>SHACL instances</a> of <code>sh:SPARQLFunction</code> must have exactly one <a>value</a> for either <code>sh:ask</code> or <code>sh:select</code>.
					The <a>values</a> of this property must be strings that can be parsed into SPARQL queries of type ASK (for <code>sh:ask</code>) or SELECT (for <code>sh:select</code>).
					SELECT queries must project exactly one result variable and SHOULD not use the <code>SELECT *</code> syntax.
					In the SPARQL query, the SPARQL processor needs to <a>pre-bind</a> variables based on the provided parameters of the function call.
					For ASK queries, the function's return value is the result of the ASK query execution, i.e. <code>true</code> or <code>false</code>.
					For SELECT queries, the function's return value is the binding of the (single) result variable of the first row in the result set.
					Since all other bindings will be ignored, such SELECT queries SHOULD only return a single result variable and at most one row.
					Also note that the result variable may be unbound, making the return value of the function <span class="term">undefined</span>.
				</p>
				<p>
					<em>Recursive use of functions is undefined:</em>
					If a SPARQL-based function contains calls to other functions so that the same function with the same combination of parameters would be visited twice
					then the result of the function call is undefined.
					An implementation may either return no result (unbound) or terminate the surrounding SPARQL query with an error.
				</p>
				<p>
					Some processors may ignore the specified SPARQL query and rely on an alternative (possibly native) implementation instead,
					as long as the functions return the same values as the specified SPARQL query.
					This can be used to optimize frequently needed functions.
					Some processors may even use the SPARQL query to rewrite other SPARQL queries via inlining techniques.
				</p>
			</section>
		</section>

		<section id="entailment">
			<h2>Entailment</h2>
			<p>
				By default, SHACL does not assume any <span class="term">entailment regime</span> [[!sparql11-entailment]] to be activated on the <a>data graph</a>.
				However, the property <code>sh:entailment</code> can be used to instruct a SHACL Full processor to ensure that a given entailment is activated on the <a>data graph</a>.
				The <a>values</a> of <code>sh:entailment</code> must be <a>IRIs</a>, with common use cases covered by [[!sparql11-entailment]].
				<!--DK: we can be agnostic on the what the subject is-->
				<!--The subject of <code>sh:entailment</code> must be the IRI of the shapes graph itself.-->
			</p>
			<p>
				SHACL Full processors are not required to support any entailment regimes.
				If an entailment regime is provided in the <a>data graph</a> which is not supported by the SHACL Full processor, the <a>validation</a> must produce a <a>failure</a>.
			</p>
		</section>
		
		<div style="padding-top: 30px">
			<h1 id="appendix" style="font-size: 160%; font-weight: bold">Appendix</h1>
		</div>
		
		<section id="hasShape" class="appendix">
			<h2>The Function sh:hasShape</h2>
			<div class="issue" data-number="131" title="sh:hasShape">
				The following definition is under discussion.
			</div>
			<p>
				SHACL Full processors must implement the function <code>sh:hasShape</code>,
				which takes the following <a>parameters</a>:
			</p>
			<table class="term-table">
				<tr>
					<th style="min-width: 200px">Parameter</th>
					<th>Value Type</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><code>focusNode</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The <a>focus node</a> to validate.</td>
				</tr>
				<tr>
					<td><code>shape</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The <a>shape</a> to validate the focus node against.</td>
				</tr>
				<tr>
					<td><code>shapesGraph</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The IRI of the current <a>shapes graph</a>.</td>
				</tr>
			</table>
			<p>
				An example call of this function is
			</p>
			<pre>
				<code>BIND (sh:hasShape(ex:JohnDoe, ex:PersonShape, $shapesGraph) AS ?hasShape)</code>
			</pre>
			<p>
				None of the <a>parameters</a> can be unbound.
				The result of the <code>sh:hasShape</code> function is either <code>true</code>, <code>false</code> or <span class="term">undefined</span>:
			</p>
			<ul>
				<li><code>true</code> if the <a>validation</a> of the <code>focusNode</code> against the given <code>shape</code> produces no <a>validation results</a>.</li>
				<li><code>false</code> if the <a>validation</a> of the <code>focusNode</code> against the given <code>shape</code> produces at least one <a>validation result</a>.</li>
				<li><span class="term">undefined</span> if during the execution a <a>failure</a> has been reported. This result indicates a <a>failure</a>.
				Implementations MAY for example use this to report infinite recursion.</li>
			</ul>
			<p>
				Note that any <a>validation results</a> produced inside of the <code>sh:hasShape</code> function are temporary, i.e. they are not added to the results graph of the surrounding <a>validation</a> process.
				However, some implementations may add those nested <a>validation results</a> as annotations to the surrounding <a>validation results</a>, via <a href="#results-detail"><code>sh:detail</code></a>.
			</p>
		</section>
		
		<section id="optional-features" class="appendix">
			<h2>List of Optional SHACL Features and Dialects</h2>
			<p>
				SHACL has been designed to address a wide range of use cases.
				For many advanced use cases, highly expressive constraints such as those
				written in SPARQL are needed.
				Yet, SHACL has been designed so that those advanced use cases do not put
				unnecessary burden on implementations that only aim at the simpler features.
				As a result of this, not all SHACL engines need to support all features of
				the <a>SHACL Full</a> language.
				The following overview enumerates the features that are outside of
				<a>SHACL Core</a>.
			</p>
			<ul>
				<li><a href="#sparql-constraints">SPARQL-based Constraints</a></li>
				<li><a href="#constraint-components">SPARQL-based Constraint Components</a></li>
				<li><a href="#sparql-targets">SPARQL-based Targets</a></li>
				<li><a href="#derivedValues">Derived Values Constraints</a></li>
				<li><a href="#functions">SPARQL Functions</a></li>
				<li><a href="#entailment">Entailment</a></li>
				<li><a href="#hasShape">The Function sh:hasShape</a></li>
			</ul>
			<p>
				Furthermore, implementation details of the following features have been left unspecified. 
			</p>
			<ul>
				<li><a href="#recursion">Handling of recursive shapes</a></li>
			</ul>
		</section>
		
		<section id="pre-binding" class="appendix">
			<h2>Pre-binding of Variables in SPARQL Queries</h2>
			<p class="issue" data-number="68" title="Pre-binding of Variables in SPARQL">
				The following definition of what pre-binding means has not been approved by the WG yet,
				and is work in progress.
				The WG is also awaiting input from the <a href="https://www.w3.org/community/sparql-exists/">SPARQL Maintenance (EXISTS) Community Group</a>.
			</p>
			<p>
				Some features of the SPARQL-based extension mechanism of SHACL Full rely on the concept of <dfn data-lt="pre-binding|pre-bind|pre-bound|pre-bound variables|pre-binds">pre-binding of variables</dfn>.
				Although variations of this concept are supported by several existing SPARQL implementations, there is no formal definition of pre-binding in the SPARQL 1.1 specifications.
				The goal of this section is to illustrate the effect of pre-binding to users and implementers.
				Note however that the following definition is not meant to serve as recommendation for an actual implementation strategy.
			</p>
			<p>
				<span class="term">Pre-binding</span> a variable with a value means that
				the SPARQL processor needs to evaluate all occurrences of variables with that same name
				(including occurrences in inner targets and nested SELECT queries)
				so that they have the provided value.
				In other words, whenever a SPARQL processor evaluates a pre-bound variable, it must use the given value.
 			</p>

			<section id="pre-bindound-variables">
				<h3>Pre-bound variables</h3>
				<p>
					SHACL Full defines two forms of variable pre-binding:
				</p>
				<ol>
			        <li><a href="#sparql-constraints-prebound">Global pre-bound variables</a> that are available in all SPARQL-based constraints, SPARQL-based constraint components and SPARQL-based targets.</li>
					<li>Local pre-bound variables available only within a SPARQL-based constraint component and defined through the <a href="#constraint-components-parameter-pre-binding">component parameters</a> </li>
				</ol>
				<p>
					The variable <code>PATH</code> has a special treatment in SHACL property constraint components and must be processed before any other pre-bound variable.
					SHACL Full processors must perform string substitution of every occurrence of the variable <code>PATH</code> to the <a href="#path-syntax">generated SPARQL property path</a> before performing any pre-binding.
				</p>
				<p>
					The variable <code>predicate</code> is not a pre-bound variable in SHACL and will be treated as a normal SPARQL variable.
					<span class="todo">Should we disallow the variable predicate instead to avoid confusion?</span>
				</p>
			</section>

		</section>

		<section id="ack" class="appendix informative">
			<h2>Acknowledgements</h2>
			<p>
				Many people contributed to this specification, including members of the RDF Data Shapes Working Group.
				We especially thank the following:
			</p>
			<p>
				Arnaud Le Hors (chair),
				Jim Amsden,
				Iovka Boneva,
				Karen Coyle,
				Richard Cyganiak,
				Michel Dumontier,
				Holger Knublauch,
				Dimitris Kontokostas,
				Jose Labra,
				Peter Patel-Schneider,
				Eric Prud'hommeaux,
				Arthur Ryman (who also served as a co-editor until Feb 2016),
				Harold Solbrig,
				Simon Steyskal,
				Ted Thibodeau
			</p>
		</section>
		
	</body>
</html>
