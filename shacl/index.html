<!DOCTYPE html>
<html>
	<head>
		<title>Shapes Constraint Language (SHACL)</title>
		<meta charset="utf-8">
		<script src="https://www.w3.org/Tools/respec/respec-w3c-common" async class="remove"></script>
		<script class="remove">
			var respecConfig = {
				edDraftURI: "http://w3c.github.io/data-shapes/shacl/",
				issueBase: "http://www.w3.org/2014/data-shapes/track/issues/",
				specStatus: "ED",
				shortName:  "shacl",
				editors: [
					{
						name:       "Holger Knublauch",
						url:        "http://knublauch.com/",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/",
						w3cid:      46500
					},
					{
						name:       "Dimitris Kontokostas",
						url:        "http://aksw.org/DimitrisKontokostas",
						company:    "University of Leipzig",
						companyURL: "http://informatik.uni-leipzig.de/",
						w3cid:      58399
					}
				],
				wg:           "RDF Data Shapes Working Group",
				wgURI:        "//www.w3.org/2014/data-shapes/",
				wgPublicList: "public-rdf-shapes",
				wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status"
			};
		</script>
		<!-- script src="https://www.w3.org/scripts/jquery/2.1/jquery.min.js"></script--> 
		<style>

			pre {
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.def-sparql {
			}
			
			.def-text {
			}
			
			.def-text-body {
				margin-left: 2em;
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.focus-node-selected {
				color: green;
			}
			.focus-node-error {
				color: red;
			}
			
			.component-class {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameter-context {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameters {
				font-weight: bold;
				font-size: 16px;
			}

			.part-header {
				font-weight: bold;
			}
		
			.term {
				font-style: italic;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}

			.term-table td, th {
				border-width: 1px;
				border-style: solid;
				padding: 5px;
			}
		
			.todo {
				color: red;
			}

			/* example pre taken / adapted from R2RML */
			pre.example-shapes, pre.example-data, pre.example-results { margin-left: 0; padding: 0 2em; margin-top: 1.5em; padding: 1em; }
			pre.example-shapes:before, pre.example-data:before, pre.example-results:before { background: white; display: block; font-family: sans-serif; margin: -1em 0 0.4em -1em; padding: 0.2em 1em; }
			pre.example-shapes { background: #deb; }
			pre.example-shapes, pre.example-shapes:before { border: 1px solid #bbb; }
			pre.example-shapes:before { color: #888; content: "Example shapes graph"; width: 12em; }
			pre.example-data { background: #eeb; }
			pre.example-data, pre.example-data:before { border: 1px solid #cc9; }
			pre.example-data:before { color: #996; content: "Example data graph"; width: 12em; }
			.example-results { background: #edb; }
			.example-results, .example-results:before, .example-results th, .example-results td { border: 1px solid #aca; }
			pre.example-results:before { color: #797; content: "Example results"; width: 12em; }

			/* our syntax menu for switching */
			div.syntaxmenu {
				border: 1px dotted black;
				padding:0.5em;
				margin: 1em; 
			}

			@media print {
				div.syntaxmenu { display:none; }
			}
		</style>
	</head>
	<body>

		<section id="abstract">
			<p>
				SHACL (Shapes Constraint Language) is a language for describing and constraining the contents of RDF graphs.
				SHACL groups these descriptions and constraints into "shapes", which specify conditions that apply at a given RDF node.
				Shapes provide a high-level vocabulary to identify predicates and their associated cardinalities, datatypes and other constraints.
				Additional constraints can be associated with shapes using SPARQL.
				The vocabulary of SHACL has been designed to support similar extension languages besides SPARQL.
				These extension languages can also be used to define new high-level vocabulary terms.
				SHACL shapes can be used to communicate information about data structures associated with some process or interface, generate or validate data, or drive user interfaces.
				This document defines the SHACL language and its underlying semantics.
			</p>	
		</section>

		<section id="sotd">
		</section>
		<section class='introductory'>
		  <h2>Revision History</h2>
			<p>
				The detailed list of changes and their diffs can be found in the <a href="https://github.com/w3c/data-shapes/commits/gh-pages/shacl/index.html">Git repository</a>.
			</p>
			<ul>
				<li><b>2016-04-19</b>: Edits for wording by kcoyle</li>
				<li><b>2016-04-18</b>: sh:stem definition</li>
				<li><b>2016-04-18</b>: Renamed sh:sourceTemplate to sh:sourceConstraintComponent</li>
				<li><b>2016-04-18</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-04-15</b>: Allowing multi-occurrence of constraint parameters <a href="http://www.w3.org/2014/data-shapes/track/issues/133">ISSUE-133</a></li>
				<li><b>2016-04-10/16/18</b>: Updated text for <a href="http://www.w3.org/2014/data-shapes/track/issues/144">ISSUE-144</a></li>
				<li><b>2016-04-10</b>: Fixed SPARQL query of sh:minExclusive <a href="http://www.w3.org/2014/data-shapes/track/issues/145">ISSUE-145</a></li>
				<li><b>2016-04-08</b>: Updated the definition and use of sh:hasShape <a href="http://www.w3.org/2014/data-shapes/track/issues/131">ISSUE-131</a></li>
				<li><b>2016-04-08</b>: Renamed sh:notEquals to sh:disjoint <a href="http://www.w3.org/2014/data-shapes/track/issues/136">ISSUE-136</a></li>
				<li><b>2016-04-07</b>: Added section on Invalid Shapes Graphs for <a href="http://www.w3.org/2014/data-shapes/track/issues/134">ISSUE-134</a></li>
				<li><b>2016-03-25</b>: rearrange cleanup sections 2 and 4, better definition of shape validation</li>
				<li><b>2016-03-25</b>: entailment regime - fix the graph IRI issue</li>
				<li><b>2016-03-25</b>: $shapesGraph warnings</li>
				<li><b>2016-03-22</b>: Cleaned up generic mechanism to define constraint components applied to 3.1</li>
				<li><b>2016-03-21</b>: SHACL does not assume that the data graph is an RDF dataset</li>
				<li><b>2016-03-21</b>: updated some definitions for shapes, scopes and filters</li>
				<li><b>2016-03-21</b>: Re-organized the sections on the various constraint properties, introducing the term constraint component</li>
				<li><b>2016-03-21</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-03-14</b>: Added three new node kinds as resolved (<a href="http://www.w3.org/2014/data-shapes/track/issues/99">ISSUE-99</a>)</li>
				<li><b>2016-03-12</b>: Added issue warning regarding recursion</li>
				<li><b>2016-03-04</b>: Simplified the definition of sh:class (<a href="http://www.w3.org/2014/data-shapes/track/issues/99">ISSUE-99</a>)</li>
				<li><b>2016-02-24</b>: Updated the definition of pre-binding (<a href="http://www.w3.org/2014/data-shapes/track/issues/68">ISSUE-68</a>)</li>
				<li><b>2016-02-19</b>: Clarified that support for <code>$shapesGraph</code> is optional (<a href="http://www.w3.org/2014/data-shapes/track/issues/47">ISSUE-47</a>)</li>
				<li><b>2016-02-19</b>: Clarified that the SHACL graph URI includes the # (<a href="http://www.w3.org/2014/data-shapes/track/issues/129">ISSUE-129</a>)</li>
				<li><b>2016-02-18</b>: Removed reference to the proposed class <code>sh:QCC</code>(<a href="http://www.w3.org/2014/data-shapes/track/issues/92">ISSUE-92</a>)</li>
				<li><b>2016-02-12</b>: Added a paragraph on the limits of the core vocabulary, highlighting how rdf:Lists can be handled by the extension mechanism (<a href="http://www.w3.org/2014/data-shapes/track/issues/119">ISSUE-119</a>)</li>
				<li><b>2016-02-10</b>: Added <code>sh:partition</code>. (<a href="http://www.w3.org/2014/data-shapes/track/issues/92">ISSUE-92</a>)</li>
				<li><b>2016-02-05</b>: Removed value type constraints on various constraint properties such as sh:class (<a href="http://www.w3.org/2014/data-shapes/track/issues/117">ISSUE-117</a>)</li>
				<li><b>2016-01-29</b>: Clarified that validation results must be based on the data graph only. (<a href="http://www.w3.org/2014/data-shapes/track/issues/118">ISSUE-118</a>)</li>
				<li><b>2016-01-25</b>: Clarified direction of property path. Remove comment about consistency. (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-22</b>: Switched closed shapes syntax to sh:closed (<a href="http://www.w3.org/2014/data-shapes/track/issues/115">ISSUE-115</a>)</li>
				<li><b>2016-01-21</b>: Limit definition of shapes that are also classes to the shapes graph (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-19</b>: Describe scoping of shapes that are also classes (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>)</li>
				<li><b>2016-01-18</b>: Stated starting point for recursion (<a href="http://www.w3.org/2014/data-shapes/track/issues/22">ISSUE-22</a>)</li>
				<li><b>2016-01-18</b>: Clarified the meaning of filter shapes (<a href="http://www.w3.org/2014/data-shapes/track/issues/49">ISSUE-49</a>)</li>
				<li><b>2016-01-11</b>: Deleted operations section (<a href="http://www.w3.org/2014/data-shapes/track/issues/108">ISSUE-108</a>)</li>
				<li><b>2016-01-11</b>: Added derived properties (<a href="http://www.w3.org/2014/data-shapes/track/issues/97">ISSUE-97</a>)</li>
				<li><b>2016-01-11</b>: Dropped sh:ShapeClass (<a href="http://www.w3.org/2014/data-shapes/track/issues/23">ISSUE-23</a>), elaborated on possible sh:scopeClass rule</li>
				<li><b>2016-01-10</b>: Added sh:order (<a href="http://www.w3.org/2014/data-shapes/track/issues/100">ISSUE-100</a>) and sh:group (<a href="http://www.w3.org/2014/data-shapes/track/issues/114">ISSUE-114</a>)</li>
				<li><b>2016-01-10</b>: Introduced sh:datatypeIn and sh:classIn, deleted sh:text (<a href="http://www.w3.org/2014/data-shapes/track/issues/104">ISSUE-104</a>)</li>
				<li><b>2016-01-09</b>: Syntax simplifications: Switched to sh:not, sh:and, sh:or, sh:equals, sh:notEquals, sh:lessThan, sh:lessThanOrEquals (<a href="http://www.w3.org/2014/data-shapes/track/issues/103">ISSUE-103</a>)</li>
				<li><b>2015-12-02</b>: Fixed <a href="https://github.com/w3c/data-shapes/issues/9">minor mistake in spec - ex:unsinged</a>.</li>
				<li><b>2015-11-20</b>: Switched from rdfs:label/rdfs:comment at property constraints to sh:name/sh:description (ISSUE-112)</li>
				<li><b>2015-11-06</b>: Renamed sh:nodeShape to sh:scopeNode, clarified that its triples are expected in shapes graph (ISSUE-61)</li>
				<li><b>2015-10-30</b>: Deleted sh:cachable, removed the option for sh:sparql to be a query fragment in sh:scope</li>
				<li><b>2015-10-29</b>: Improved wording in the definition of sh:in.</li>
				<li><b>2015-10-28</b>: Separated definitions of sh:qualifiedMinCount and sh:qualifiedMaxCount</li>
				<li><b>2015-10-22</b>: Define sh:minLength, sh:maxLength, sh:qualifiedMinCount, and sh:qualifiedMaxCount without reference to default values</li>
				<li><b>2015-10-22</b>: Replaced ex:bornIn with ex:residentIn in Section 2.2</li>
				<li><b>2015-10-16</b>: Added sh:SPARQLConstraint and sh:SPARQLScope (part of ISSUE-98)</li>
				<li><b>2015-10-16</b>: Renamed sh:valueClass to sh:class, sh:allowedValues to sh:in, sh:directValueType to sh:directType (part of ISSUE-98)</li>
				<li><b>2015-10-15</b>: Define sh:minCount and sh:maxCount without reference to default values</li>
				<li><b>2015-10-15</b>: Use real-world names in examples 3, 4 and 5</li>
				<li><b>2015-10-15</b>: Changed SPARQL definition of sh:AllObjects, implementing resolution to ISSUE-90</li>
				<li><b>2015-10-09</b>: Added sh:flags and sh:uniqueLang</li>
				<li><b>2015-09-23</b>: Multiple minor stylistic edits and corrections</li>
				<li><b>2015-09-21</b>: Added button to show or hide SPARQL definitions (thanks to Simon)</li>
				<li><b>2015-09-18</b>: Deleted <code>sh:XorConstraint</code> as resolved, renamed <code>sh:Error</code> to <code>sh:Violation</code></li>
				<li><b>2015-09-17</b>: Added missing definition of <code>sh:class</code>, editorial changes, renamed sh:ClosedShape to sh:Closed, added sh:sourceTemplate</li>
				<li><b>2015-09-15</b>: Restructured Part 2, with new examples, integrated SPARQL binding and rewritten Operations section</li>
				<li><b>2015-09-14</b>: Added SPARQL definitions for each constraint type, added description of sh:hasShape function</li>
				<li><b>2015-09-11</b>: Restructured constraint section, cleaned up results vocabulary</li>
				<li><b>2015-09-10</b>: Added sh:shapesGraph property (<a href="http://www.w3.org/2014/data-shapes/track/issues/44">ISSUE-44</a>)</li>
				<li><b>2015-09-09</b>: Rewritten introduction, dropped Profile section, word-smithing on sh:class</li>
				<li><b>2015-09-04</b>: Applied resolution to <a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a></li>
				<li><b>2015-09-03</b>: Many editorial changes, restructured section 5 (scopes and filters) into section 2 (Shapes)</li>
				<li><b>2015-09-01</b>: Minor changes and clarifications</li>
				<li><b>2015-08-24</b>: Added section on sh:defaultValueType (<a href="http://www.w3.org/2014/data-shapes/track/issues/70">ISSUE-70</a>)</li>
				<li><b>2015-08-21</b>: Added support for validation functions (<a href="http://www.w3.org/2014/data-shapes/track/issues/79">ISSUE-79</a>)</li>
				<li><b>2015-08-14</b>:
					Added qualified cardinality restrictions (<a href="http://www.w3.org/2014/data-shapes/track/issues/72">ISSUE-72</a>),
					added sh:ignoredProperties to sh:ClosedShape (<a href="http://www.w3.org/2014/data-shapes/track/issues/58">ISSUE-58</a>),
					editorial improvements to terminology, added Glossary to appendix
				</li>
				<li><b>2015-08-07</b>: Extended the use of sh:severity to template constraints, split sh:source into sh:sourceConstraint and sh:sourceShape, renamed sh:root to sh:focusNode</li>
				<li><b>2015-07-31</b>: Added sh:text as the union of xsd:string and rdf:langString</li>
				<li><b>2015-07-30</b>: Integrated sh:InversePropertyScope and sh:AllObjects</li>
				<li><b>2015-07-24</b>: Added details of XSD-like facets (<a href="http://www.w3.org/2014/data-shapes/track/issues/64">ISSUE-64</a>)</li>
				<li>
					<b>2015-07-17</b>: Rewritten scope and filter mechanism (<a href="http://www.w3.org/2014/data-shapes/track/issues/62">ISSUE-62</a>),
					suggestion for generalized execution language interface (<a href="http://www.w3.org/2014/data-shapes/track/issues/60">ISSUE-60</a>)
				</li>
				<li><b>2015-07-13</b>: Replaced Appendix with references to SHACL-REF document</li>
				<li><b>2015-07-03</b>: Editorial fixes, started revision history</li
			</ul>
		</section>
		<section class="introductory">
			<h2>Document Outline</h2>
			<p>
				The sections 2 - 5 cover the <span class="term">SHACL Core Profile</span> and may be read independently from the later sections.
			</p>
			<p>
				The sections 6 onwards are about the advanced features of the SHACL language, including templates, functions, and execution semantics.
			</p>
			<p>
				The Appendix provides a <a href="#terms">Glossary of Key Concepts</a> that may also serve as a quick overview of the language.
			</p>
			<p>
				The examples in this document use Turtle [[!turtle]].
				The reader should be familiar with basic RDF concepts [[!rdf11-concepts]] such as triples and (for the advanced concepts of SHACL) with SPARQL [[!sparql11-overview]].			<p>
			</p>
		</section>
	
		<section id="introduction">
			<h2>Introduction</h2>
			<p>
				SHACL (Shapes Constraint Language) is a language for describing and constraining RDF graphs. 
				SHACL can be used with RDF graphs that are obtained by any means, e.g. from the file system, HTTP requests, or <a href="http://www.w3.org/TR/rdf11-concepts/#section-dataset">RDF datasets</a>.
				SHACL groups descriptive information and constraints that apply to a given data node into <span class="term">shapes</span>.
				This document defines what it means for an <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graph</a>, referred to as the "data graph", to conform to a graph containing SHACL shapes, referred to as the "shapes graph".
				Conformance can be programmatically checked by processors referred to as SHACL <span class="term">validation engines</span>.
				The process of checking conformance is referred to as <span class="term">validation</span>.
				A shape may include a <span class="term">scope</span> which defines which nodes in the data graph must conform to it.
				When a data node is checked for conformance to a shape, that node is referred to as the <span class="term">focus node</span>.
				The output of the validation process is a <span class="term">validation report</span> which indicates whether or not the data graph conforms to the shapes graph.
				If any constraints are not satisfied, then the validation report will include one or more <span class="term">violations</span> which indicate the source of the problem.
			</p>
			<p>
				For example, SHACL can be used to check whether all the nodes in a data graph that have a type link to <code>foaf:Person</code> have a single value for <code>foaf:mbox</code>, and that that value is an IRI.
				SHACL can also be used to check whether a particular node in a data graph, say the node <code>ex:bug1</code>, has at least one
				value for <code>ex:reportedBy</code> and all such values have an <code>rdf:type</code> link to <code>foaf:Person</code>.
			</p>
			<p>
				The simplest interface to a SHACL processor has two inputs:
			</p>
			<ul>
				<li>A <span class="term">data graph</span> that contains the data that is to be validated</li>
				<li>A <span class="term">shapes graph</span> containing shape definitions and other information that can be utilized to determine what validation is to be done</li>
			</ul>
			<p>
				For example, one might use SHACL to determine whether data graphs that contain information about issues and users conform to the following constraints:
			</p>
			<ul>
				<li>each issue is in either an unassigned or an assigned state, and</li>
				<li>each issue has a reporter and each such reporter has precisely one name (which is a string) and one or more mailboxes (which are IRIs).</li>
			</ul>
			<p>
				A shapes graph that defines these constraints has two shapes.
				The first, <code>ex:IssueShape</code> contains the two constraints on issues.
				The second, <code>ex:UserShape</code>, contains the two constraints on reporters.
				<code>ex:IssueShape</code> contains scope information which in this case says that its constraints apply to all nodes that have an <code>rdf:type</code> link to
				either <code>ex:Issue</code> directly or to a (transitive) subclass of <code>ex:Issue</code> following <code>rdf:subClassOf</code> triples.
			</p>
			<pre class="example-shapes">
ex:IssueShape
	a sh:Shape ;
	sh:scopeClass ex:Issue;
	sh:property [
		sh:predicate ex:state ;
		sh:in (ex:unassigned ex:assigned) ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate ex:reportedBy ;
		sh:valueShape ex:UserShape ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] .

ex:UserShape
	a sh:Shape ;
	sh:property [
		sh:predicate foaf:name ;
		sh:datatype xsd:string ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:predicate foaf:mbox ;
		sh:nodeKind sh:IRI ;
		sh:minCount 1 ;
	] .</pre>
			<p>
				The following data graph might be validated against this shapes graph.
			</p>
			<pre class="example-data">
inst:Issue1
	a ex:Issue ;
	ex:state ex:unassigned ;
	ex:reportedBy inst:User2 .

inst:User2
	a foaf:Person ;
	foaf:name "Bob Smith" ;
	foaf:mbox &lt;mailto:bob@example.org&gt; ;
	foaf:mbox &lt;mailto:rs@example.org&gt; .

inst:Issue3
	a ex:Issue ;
	ex:state ex:unsigned ;
	ex:reportedBy inst:User4 .

inst:User4
	a foaf:Person ;
	foaf:name "Bob Smith", "Robert Smith" ;
	foaf:mbox &lt;mailto:bob@example.org&gt; ;
	foaf:mbox &lt;mailto:rs@example.org&gt; .</pre>
			<p>
				The SHACL validation would validate <code>ex:IssueShape</code> against <code>inst:Issue1</code> and <code>inst:Issue3</code>.
				Validating the first node would determine that <code>inst:Issue1</code> satisfies the constraints in <code>ex:IssueShape</code>, along the way determining that <code>inst:User2</code> satisfies the constraints in <code>ex:UserShape</code>.
				Validating the second node would determine that <code>inst:Issue3</code> violates the constraint on values for <code>ex:state</code>, because <code>ex:unsigned</code> is not in the list of allowed values (the correct value is <code>ex:unassigned</code>),
				and also violates the constraint on values for <code>ex:reportedBy</code>, because <code>inst:User4</code> violates the <code>ex:UserShape</code> constraint on the maximum number of values for <code>foaf:name</code>.
			</p>
			
			<section id="shacl-rdfs">
				<h3>Relationship between SHACL and RDFS</h3>
				<p>
					SHACL uses RDF and RDFS vocabulary (in particular <code>rdf:type</code>, <code>rdfs:Class</code>, <code>rdfs:subClassOf</code>, <code>rdf:Property</code>, <code>rdf:List</code>,
					<code>rdf:langLiteral</code>, and <code>rdfs:Resource</code>) and notions (notably classes, instances, and subclasses).
					However, SHACL does not always use this vocabulary or these notions in exactly the way that they are formally defined in RDF and RDFS [[!rdf11-mt]].				
				</p>
				<p>
					When determining subclass and instance relationships SHACL only uses the transitive closure of <code>rdfs:subClassOf</code>,
					without requiring in particular the RDF axioms, the RDFS meaning of <code>rdfs:Resource</code>, the reflexivity of <code>rdfs:subClassOf</code>,
					the effect of subproperties of <code>rdfs:subClassOf</code>, and the effects of <code>rdfs:domain</code> and <code>rdfs:range</code>.
				</p>
				<p>
					Note that <code>rdfs:subClassOf</code> transitivity is not uniformly applied throughout SHACL.
					It is only used when SHACL explicitly determines type and subclass relationships in the shapes graph and the data.
					In other places only triples that are explicitly present in the shapes graph or the data are considered.
					For example, SHACL property constraints on <code>rdf:type</code> and <code>rdfs:subClassOf</code> only utilize triples that are explicitly in the data.
					Similarly, subproperties of <code>rdfs:label</code> and <code>rdfs:commment</code> and subclasses of <code>rdf:List</code> are not recognized in the shapes graph.
				</p>
				<p>
					These design decisions mean that SHACL processors do not have to natively support full RDFS inferencing.
					However, SHACL validation engines may operate on RDF graphs that include entailments - either pre-computed before being submitted to a SHACL processor or performed on the fly as part of SHACL processing.
					To support on the fly processing of entailments, SHACL includes the property <a href="#entailment"><code>sh:entailment</code></a> to indicate what kind of inferencing is required by a given shapes graph.
					SHACL implementations may, but are not required to, support entailment regimes.
				</p>
				<p>
					In the remainder of this document, the following terminology is used:
				</p>
				<ul>
					<li>
						<span class="term">subclass</span>, <span class="term">superclass</span>:
						A class <code>Sub</code> is a subclass of another class <code>Super</code>
						if there is a path of asserted <code>rdfs:subClassOf</code> triples from <code>Sub</code> to <code>Super</code>
						equivalent to the SPARQL property path  [[!sparql11-query]] <code>?Sub rdfs:subClassOf+ ?Super</code>.
						The term superclass is referring to the same relationship in reverse order.
					</li>
					<li>
						<span class="term">type</span>: The types of a node are the classes that are linked to the node via
						<code>rdf:type</code> as well as their superclasses as defined above.
					</li>
					<li>
						<span class="term">instance</span>: A node is an instance of a class if one of its
						<span class="term">types</span> (as defined above) is the given class.
					</li>
				</ul>
			</section>
			
			<section id="shacl-sparql">
				<h3>Relationship between SHACL and SPARQL</h3>
				<p>
					This specification uses parts of SPARQL 1.1 in the normative definition of the semantics of the SHACL Core constraints and scopes.
					However, SPARQL is not required for the implementation of the SHACL Core language.
				</p>
				<p>
					SPARQL variables using <code>$</code> marker represent external values that must be <a href="#pre-binding">pre-bound</a> in the query before execution.
				</p>
				<p>
					In some places, the specification assumes that the provided SPARQL engines are preserving the identity of blank nodes,
					so that repeated invocations of queries consistently identify and communicate the same blank nodes.
				</p>
				<p>
					The definition of some constraints requires or is simplified through access to the shapes graph during query execution.
					SHACL validation engines MAY <a href="#pre-binding">pre-bind</a> the variable <code>$shapesGraph</code> to provide access to the shapes graph.
					Access to the shapes graph is not a requirement for supporting the SHACL core language.
					The variable <code>$shapesGraph</code> can also be used in user-defined <a href="#native-constraints-sparql">SPARQL constraints</a> and <a href="#template-constraints">constraint components</a> .
					However, such constraints may not be interoperable across different SHACL validation engines or not applicable to remote RDF datasets.
				</p>
				<p>
					Some SHACL constraints are defined with the use of the <a href="#hasShape"><code>sh:hasShape</code></a> function.
					SHACL additionally introduces mechanisms to define constraints, scopes and new functions in SPARQL.
					Implementations that cover only the the SHACL Core features are not required to implement these mechanisms or the <code>sh:hasShape</code> function.
				</p>
				<div class="syntaxmenu">
					<p>The button below can be used to show or hide the SPARQL definitions.</p>
					<form>
						<p>
							<input id="hide-sparql" onclick="$('.def-sparql').css('display', 'none'); $('#hide-sparql').css('display', 'none'); $('#show-sparql').css('display', '');" type="button" value="Hide SPARQL Definitions" />
							<input id="show-sparql" onclick="$('.def-sparql').css('display', '');     $('#show-sparql').css('display', 'none'); $('#hide-sparql').css('display', '');" style="display:none" type="button" value="Show SPARQL Definitions" />
						</p>
					</form>
				</div>
			</section>
			
			<section id="namespaces">
				<h3>Namespaces</h3>
				<p>
					Within this document, the following namespace prefix bindings are used:
				</p>
				<table class="term-table">
					<tr>
						<th>Prefix</th>
						<th>Namespace</th>
					</tr>
					<tr>
						<td><code>rdf:</code></td>
						<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
					</tr>
					<tr>
						<td><code>rdfs:</code></td>
						<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
					</tr>
					<tr>
						<td><code>sh:</code></td>
						<td><code>http://www.w3.org/ns/shacl#</code></td>
					</tr>
					<tr>
						<td><code>xsd:</code></td>
						<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
					</tr>
				</table>
				<p>
					Note that the URI of the graph defining the SHACL vocabulary itself is equivalent to
					the namespace above, i.e. it includes the <code>#</code>.
					References to the SHACL vocabulary, e.g. via <code>owl:imports</code> SHOULD include the <code>#</code>. 
				</p>
			</section>
			
			<section id="conformance">
				<p>
					<span class="todo">TODO: We still need to mark non-normative sections.</span>
				</p>
			</section>
			
		</section>
		
		<div style="padding-top: 30px"> <!-- ALH: really??? -->
			<h1 id="part1" style="font-size: 160%; font-weight: bold">Part 1: Core Features</h1>
		</div>

		<section id="shapes">
			<h2>Shapes</h2>
			<p>
				Shapes are instances of the class <code>sh:Shape</code> and define a group of <span class="term"><a href="#shape-constraints">constraints</a></span> that a set of <span class="term">focus nodes</span> can be validated against.
				The set of focus nodes may be defined explicitly in a shape using <span class="term"><a href="#scopes">scopes</a></span> and <span class="term"><a href="#filterShape">filter shapes</a></span>, or provided by the validation engine as defined in later sections. <!-- DK: TODO: check consistent terminology later-->
				Shape scopes instruct a SHACL validation engine how to select the focus nodes.
				Shapes with scopes MAY additionally provide <span class="term">filter shapes</span>.
				Filter shapes further refine the focus nodes to the ones that conform to a set of filter shapes.

				The following figure provides a workflow of the scoping and filtering process.
				SHACL validation engines MAY alter the order of the depicted steps as long as the returned validation results  are correct.
				<!--DK: TODO check term correct -->

			</p>
			<figure>
				<img src="images/SHACL-Validation-Process.png" />
				<figcaption>Illustration of the scoping and filtering process</figcaption>
			</figure>

			<section id="scopes">
				<h3>Scopes</h3>
				<p>
					Scopes define the set of focus nodes for a shape and SHACL provides three scope types:
				</p>
				<ul>
					<li><a href="#scopeNode"><b>Node scopes</b></a> define a specific RDF node as scope.</li>
					<li><a href="#scopeClass"><b>Class-based scopes</b></a> define the scope as the set of all <span class="term"><a href="#shacl-rdfs">instances</a></span> of a class.</li><!--TODO: check instance -->
					<li><a href="#scope"><b>General scopes</b></a> define a flexible mechanism to produce arbitrary focus nodes.</li>
				</ul>
				<p>
					When multiple scopes are provided in a shape, the scope of a shape is the union of all focus nodes produced by these scopes.
					Focus nodes produced by scopes may not exist in the data graph.
				</p>
				
				<section id="scopeNode">
					<h4>Node scopes (sh:scopeNode)</h4>
					<p>
						Shapes define node scopes with the <code>sh:scopeNode</code> predicate.
						The value of a node scope can be an IRI or a Literal.
						<!-- TODO: " that SHOULD exist in the data graph" do we need SHOULD here? and why is this different that other scopes-->
						<!-- TODO: change examples and visually differentiate the shapes graph from the data graph-->
					</p>

					<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:scopeNode ex:Alice .</pre>

					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
ex:Bob a ex:Person .</pre>
				</section>
				
				<section id="scopeClass">
					<h4>Class-based Scopes (sh:scopeClass)</h4>
					<p>
						Shapes define class scopes with the <code>sh:scopeClass</code> predicate.
						The value is an IRI that is assumed to be an instance of <code>rdfs:Class</code>.
						It is of no concern to SHACL if the IRI is indeed an instance of <code>rdfs:Class</code> or where this definition exists.

					</p>
					<p>
						A shape with a class-based scope selects all focus nodes that are <span class="term"><a href="#shacl-rdfs">instances</a></span> of the class IRI.
					</p>
					<pre class="example-shapes">
ex:PersonShape
	a sh:Shape ;
	sh:scopeClass ex:Person .</pre>

					<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person .
<span class="focus-node-selected">ex:Bob</span> a ex:Person .
ex:NewYork a ex:Place .</pre>

					Note that, according to the SHACL <span class="term">instance</span> definition, all the <code>rdfs:subClassOf</code> declarations must exist in the data graph.
					However, the <code>ex:Person a rdfs:Class</code> triple is not required to exist in either graphs.

					<pre class="example-data">
ex:Doctor rdfs:subClassOf ex:Person .
<span class="focus-node-selected">ex:Who</span> a ex:Doctor .</pre>

					<section id="implicit-scopeClass">
						<h4>Implicit Class Scopes</h4>
						<p>
							Shapes and classes are independent concepts in SHACL.
							In many applications, classes and shapes are separate resources and are therefore given different IRIs.
							However, some application designers may find it more convenient to tightly couple class and shape information and use the same IRI for both.

						</p>
						<p>
							If, in the shapes graph, a shape is an <span class="term"><a href="#shacl-rdfs">instance</a></span> of both <code>sh:Shape</code> and <code>rdfs:Class</code>
							the shape must get an implicit class scope of the class IRI and the <code>sh:scopeClass</code> triple MAY be omitted.
						</p>
						<pre class="example-shapes">
ex:Person
	<b>a rdfs:Class</b>, sh:Shape ;
	<span style="color: grey;">sh:scopeClass ex:Person .  #this triple can be omitted</span></pre>


						<span class="todo">TODO: move this to "Non-Validating Constraint" section?</span>
						<div class="issue" data-number="78" title="Abstract classes">
						The following paragraph about <code>sh:abstract</code> is not yet approved by the WG.
						Options include:
						<ul>
							<li>No support of abstract classes</li>
							<li>Use <code>sh:abstract</code> entirely for documentation purposes</li>
							<li>Use <code>sh:abstract</code> also as a constraint check, possibly producing a warning</li>
						</ul>
					</div>
					<p>
						Classes may be declared to be <span class="term">abstract</span> by
						setting their property <code>sh:abstract</code> to <code>true</code>.
						Abstract classes SHOULD not be instantiated directly, i.e. every instance of an abstract class SHOULD also
						have an <code>rdf:type</code> triple to a non-abstract subclass of the abstract class.
					</p>
					</section>
				</section>
				
				<section id="scope">
					<h4>General scopes (sh:scope)</h4>
					<p>
						SHACL includes a generic mechanism to select focus nodes.
						A Shape can point to one or more instances of <code>sh:Scope</code> using the <code>sh:scope</code> predicate.
						SHACL includes four built-in scope classes:
						<a href="#PropertyScope">sh:PropertyScope</a>,
						<a href="#InversePropertyScope">sh:InversePropertyScope</a>,
						<a href="#AllSubjectsScope">sh:AllSubjectsScope</a> and
						<a href="#AllObjectsScope">sh:AllObjectsScope</a>
						The full SHACL language defines an additional <a href="#general-scopes">generic scoping mechanism based on SPARQL</a>.
					</p>
					<section id="PropertyScope">
						<h5>Property scopes (sh:PropertyScope)</h5>
						<p>
							The scope class <code>sh:PropertyScope</code> selects all subjects that have at least one value for a given property <code>sh:predicate</code>.
						</p>
						<div class="def def-sparql">
							<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?this $predicate ?any .
}</pre>
						</div>
						<p>
							The following example uses <code>sh:PropertyScope</code> to define a constraint	that applies to all resources that have any value for the property <code>ex:property</code>:
						</p>
						<pre class="example-shapes">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:PropertyScope ;
		sh:predicate ex:knows ;
	] .</pre>

						<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> ex:knows ex:Bob .
ex:Bob ex:livesIn ex:NewYork .</pre>
					</section>
					<section id="InversePropertyScope">
						<h5>Inverse property scopes (sh:InversePropertyScope)</h5>
						<p>
							The scope class <code>sh:InversePropertyScope</code> selects all objects that appear in at least one triple with a given property <code>sh:predicate</code>.
						</p>
						<div class="def def-sparql">
							<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?any $predicate ?this .
}</pre>
						</div>
						<pre class="example-shapes">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:InversePropertyScope ;
		sh:predicate ex:knows ;
	] .</pre>

						<pre class="example-data">
ex:Alice ex:knows <span class="focus-node-selected">ex:Bob</span> .
ex:Bob ex:livesIn ex:NewYork .</pre>
					</section>
					<section id="AllSubjectsScope">
						<h5>All subjects scopes (sh:AllSubjectsScope)</h5>
						<p>
							The scope class <code>sh:AllSubjectsScope</code> selects all subjects in the data graph.
						</p>
						<div class="def def-sparql">
							<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?this ?anyPredicate ?anyObject .
}</pre>
						</div>
						<p>
							The following example uses <code>sh:AllSubjectsScope</code> to define a constraint that shall apply to all subjects in the data graph:
						</p>
						<pre class="example-shapes">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:AllSubjectsScope ;
	] .</pre>

						<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> ex:knows ex:Bob .
<span class="focus-node-selected">ex:Bob</span> ex:livesIn ex:NewYork .</pre>

					</section>
					<section id="AllObjectsScope">
						<h5>All objects scopes (sh:AllObjectsScope)</h5>
						<p>
							The scope class <code>sh:AllObjectsScope</code> selects all objects in the data graph.
						</p>
						<div class="def def-sparql">
							<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT ?this
WHERE {
	?anySubject ?anyPredicate ?this .
}</pre>
						</div>

						<pre class="example-shapes">
ex:PropertyScopeExampleShape
	a sh:Shape ;
	sh:scope [
		a sh:AllObjectsScope ;
	] .</pre>

						<pre class="example-data">
ex:Alice ex:knows <span class="focus-node-selected">ex:Bob</span> .
ex:Bob ex:livesIn <span class="focus-node-selected">ex:NewYork</span> .</pre>
					</section>
				</section>
			</section>
			
			<section id="filterShape">
				<h3>Filter Shapes</h3>
				<p>
					Filter shapes can further refine the focus nodes produced by a scope.
					For example, instances of the given class <code>ex:Person</code> that were <code>ex:residentIn</code>
					the country <code>ex:USA</code> may have a different legal drinking age than others.
					In order to support such use cases, SHACL includes the concept of <span class="term">filter shapes</span> that act as pre-conditions that all focus nodes need to fulfill before they are being validated.
					Formally, filter shapes eliminate entries from the collection of focus nodes selected by a shape's scopes, if the focus node produces a validation result with severity <a href="#results-severity"><code>sh:Violation</code></a> or a failure for the given filter shapes.
				</p>
				<p>
					The following example states that the <code>sh:minCount</code> constraint on <code>ex:email</code> applies on <code>ex:Person</code>s that are <code>ex:member</code>s of <code>ex:W3c</code>.
				</p>
				<pre class="example-shapes">
ex:FilteredExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Person ;
	sh:filterShape [
		<span style="color: grey;">a sh:Shape ; # Optional triple</span>
		sh:property [
			sh:predicate ex:member ;
			sh:hasValue ex:W3c ;
		]
	] ;
	sh:property [
		sh:predicate ex:email ;
		sh:minCount 1 ;
	] .</pre>

<pre class="example-data">
<span class="focus-node-selected">ex:Alice</span> a ex:Person ;
	ex:member ex:W3c ;
	ex:email &lt;mailto:alice@example.org&gt; .
<span class="focus-node-selected">ex:John</span> a ex:Person ;
	ex:member ex:W3c .
ex:Bob a ex:Person ;
	ex:member ex:Acme .</pre>

				<pre class="example-results">
[  a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:John ;
	sh:subject ex:John ;
	sh:predicate ex:email ;
	sh:message "sh:minCount for ex:email is '1'." .
] . </pre>

				<p>
					Alternatively, <code>sh:filterShape</code> can be defined on specific constraints, instead of the whole shape.
				</p>

				<pre class="example-shapes">
ex:FilteredExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Person ;
	sh:property [
		sh:predicate ex:email ;
		sh:minCount 1 ;
		sh:filterShape [
			sh:property [
				sh:predicate ex:member ;
				sh:hasValue ex:W3c ;
			]
		] ;
	] .
</pre>


				<span class="todo">TODO: say about filters when they are evaluated from sh:valueShape?</span><br/>
				<span class="todo">TODO: say anything about filters and severities?</span><br/>
				<!--
				DK: I think we can omit all these, we have a formal definition of how validation works later
				<p>
					Filters always contribute to the meaning of a shapes.
					This includes both the computation of scopes and when shapes are directly referenced via <code>sh:valueShape</code>.
					In general, a filter shape acts like the test condition of an <code>IF-THEN</code> statement.
					For example, suppose some optional property has a default value.
					Then a shape might express the constraint that <code>IF</code> the property is present <code>THEN</code> its value must be equal to the default value.
					In this case the filter would test for the presence of the property and the constraint would test that its value was equal to the
					default value.
				</p>
				<p>
					When a SHACL processor validates a focus node against a shape, it begins by validating any filters associated with the shape via 
					<code>sh:filterShape</code>.
					If any of the filters produce a violation then the processor interprets this as indicating that none of the constraints
					of the shape are applicable to the focus node and no violations for the shape are reported.
					Conversely, if none of the filters produce a violation then the processor proceeds to evaluate the constraints and reports any 
					violations produced by them.
				</p>
				<p>
					Similarly, when a SHACL processor validates a focus node against a constraint, it begins by validating any filters
					associated with the constraint via <code>sh:filterShape</code>.
					If any of the filters produce a violation then the processor interprets this as indicating that the constraint
					is not applicable to the focus node and no violations for the constraint are reported.
					Conversely, if none of the filters produce a violation then the processor proceeds to evaluate the constraint and reports any 
					violations produced by it.
				</p>
				-->
			</section>
			<section id="shape-constraints">
				<h3>Constraints</h3>
				<p>
					A shape defines a group of constraints and <code>sh:Constraint</code> is the superclass of all constraint types.
					The SHACL core language defines the following three <span class="term">constraint types</span>:
				</p>
				<ul>
					<li>
						<code>sh:PropertyConstraint</code> is the class of all <span class="term">property constraints</span>.
						Given the current focus node <code>s</code> and a provided property <code>p</code>, property constraints apply on the object of triples with <code>s</code> as the subject and <code>p</code> as the predicate.
						Every property constraint must provide exactly one value of  <code>p</code> using the property <code>sh:predicate</code>.
					</li>
					<li>
						<code>sh:InversePropertyConstraint</code> is the class of all <span class="term">inverse property constraints</span>.
						Given the current focus node <code>o</code> and a provided property <code>p</code>, inverse property constraints apply on the subject of triples with <code>p</code> as the predicate and <code>o</code> as the object.
						Every inverse property constraint must provide exactly one value of  <code>p</code> using the property <code>sh:predicate</code>.
					</li>
					<li>
						<code>sh:NodeConstraint</code> is the class of all <span class="term">node constraints</span>.
						Given the current focus node <code>s</code>, node constraints apply directly on <code>s</code>.
					</li>
				</ul>
				<p>
					Additional types of constraints can be added using the <a href="#native-constraints">extension mechanism</a>, called <span class="term">native constraints</span>.
				</p>
				<p>
					Shapes link to their constraints via the following properties:
				</p>
				<ul>
					<li>
						<code>sh:property</code> links a shape to one or more <span class="term">property constraints</span>.
						The <span class="term">default value type</span> of <code>sh:property</code> is <code>sh:PropertyConstraint</code>.
					</li>
					<li>
						<code>sh:inverseProperty</code> links a shape to one or more <span class="term">inverse property constraints</span>.
						The <span class="term">default value type</span> of <code>sh:inverseProperty</code> is <code>sh:InversePropertyConstraint</code>.
					</li>
					<li>
						<code>sh:constraint</code> links a shape with one or more <span class="term">node constraints</span> or <span class="term">native constraints</span>.
						The <span class="term">default value type</span> of <code>sh:constraint</code> is <code>sh:NodeConstraint</code>.
					</li>
				</ul>
				<p id="default-value-types">
					All three properties have a <a href="#defaultValueType"><span class="term">default value type</span></a> and thus, the <code>rdf:type</code> triple can be omitted.
					<span class="term">Instances</span> of constraint types can be reused across the same shape or different shapes.
					However, all constraint types are pairwise disjoint and no more than one property of <code>sh:property</code>, <code>sh:inverseProperty</code> and <code>sh:constraint</code> can link to the same RDF node.
				</p>
				<p>
					Constraints may contain
					<a href="#nonValidation">non-validating</a> properties (e.g. <code>sh:description</code>) or,
					<span class="term">parameters</span> of <span class="term">constraint components</span> (e.g. <code>sh:minCount</code>).
					<span class="term">Constraint components</span> define one or more parameter properties and validation instructions
					(e.g. implemented via SPARQL queries) that can be used to perform the validation for the given focus node and parameter values.
					The relationship between a <span class="term">constraint component</span> and the <span class="term">constraint type</span>
					that it can be used with is called the <span class="term">context</span> of the component.
					For example, the <span class="term">context</span> of the component defining the <code><a href="#ClosedConstraintComponent">sh:closed</a></code> property
					is <code>sh:NodeConstraint</code>, i.e. <code>sh:closed</code> can only be used with <code>sh:constraint</code>.
					The catalog of constraint components in the Core of SHACL is defined in the following section.
				</p>
				<p> 
					The following examples illustrate two ways of using (property) constraints.
					The first example uses a blank node:
				</p>
				<pre class="example-shapes">
ex:InlinePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:name "some property" ;
		sh:description "Description of the role of ex:someProperty (in the context of the constraint)" ;
		sh:minCount 1 ;
		sh:class ex:SomeClass ;
	] .</pre>
				<p>
					The second example defines a constraint as an IRI node, allowing it to be more easily referenced and shared across multiple shapes:
				</p>
				<pre class="example-shapes">
ex:StandAlonePropertyConstraintExampleShape
	a sh:Shape ;
	sh:property ex:StandAloneConstraint .

ex:StandAloneConstraint
	a sh:PropertyConstraint ;
	sh:predicate ex:someProperty ;
	sh:defaultValue ex:SomeInstance ;
	sh:minCount 1 ;
	sh:class ex:SomeClass .</pre>
				<p>
					Parameters of constraint components that only have one parameter (such as <code>sh:class</code>)
					may be used multiple times within the same constraint node.
					In the following example this technique is used to restrict the values of a property to be both
					<code>ex:Customer</code> and <code>ex:MalePerson</code>.
				</p>
				<pre class="example-shapes">
ex:ShapeWithTwoClasses
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:class ex:Customer ;
		sh:class ex:MalePerson ;
	] .</pre>
			</section>
		</section>
		
		<section id="constraints">
			<h2>Core Constraint Components</h2>
			<p>
				The following sections define the constraint components built into the SHACL Core.
				Compliant SHACL validation engines MUST support all of these constraint components.
			</p>
			<p>
				The choice of constraint components that are defined by the SHACL Core was made based on
				the requirements collected by the [[shacl-ucr]] document.
				Special attention was paid to the balance between trying to cover as many common use cases as possible
				and keeping the size of the core language under control.
				Not all use cases (such as describing constraints on members of an <code>rdf:List</code>) can be expressed by the Core Vocabulary alone.
				Instead, SHACL provides extension mechanisms, such as SPARQL queries, as described in the second part of this specification.
				It is the expectation of the Working Group that reusable libraries of SHACL extensions will be maintained by third parties.
			</p>
			<p>
				Note that the textual definitions of the constraint components refer to the <a href="#results">Validation Results Vocabulary</a>
				introduced in a later section.
				Each constraint component is identified by a URI that is referenced in the validation results via <code>sh:sourceConstraintComponent</code>
			</p>
			<p>
				Many constraint components can be used in multiple contexts, e.g. both in a <span class="term">property constraint</span>
				and an <span class="term">inverse property constraint</span>.
				The textual descriptions of each component refer to the concept of <span class="term">value nodes</span>
				which is defined as follows, including rules for the creation of validation results:
			</p>
			<ul>
				<li>
					For <span class="term">property constraints</span> the value nodes are the objects of the triples that have the <span class="term">focus node</span> as subject and the given property as predicate.
					Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
					the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value node as its <code>sh:object</code>.
				</li>
				<li>
					For <span class="term">inverse property constraints</span> the value nodes are the subjects of the triples that have the <span class="term">focus node</span> as object and the given property as predicate.
					Each produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:object</code>,
					the <code>sh:predicate</code> as its <code>sh:predicate</code> and the respective violating value node as its <code>sh:subject</code>.
				</li>
				<li>
					For <span class="term">node constraints</span> the value nodes are the <span class="term">focus nodes</span>.
				</li>
			</ul>
			<p>
				The SPARQL definitions in this section may only be written for one of the three possible contexts, for brevity.
				Corresponding queries can be formulated for the other cases (such as the inverse direction) easily.
				The SPARQL definitions also assume the following variable bindings (see the <a href="#pre-binding">appendix</a> for a formal definition of variable binding):
			</p>
			<ul>
				<li>The value of the variable <code>$this</code> is the current focus node.</li>
				<li>The value of the variable <code>$shapesGraph</code> can be used to access the <span class="term">shapes graph</span> (used only to <a href="#shacl-sparql">simplify</a> the definitions).</li>
				<li>The value of the variable <code>$currentShape</code> is the currently evaluated shape.</li>
				<li>
					In <code>sh:PropertyConstraint</code>s and <code>sh:InversePropertyConstraint</code>s,
					the value of the variable <code>$predicate</code> is the value of <code>sh:predicate</code>
					in the constraint.
				</li>
			</ul>
			<p>
				Additional variables (using the <code>$</code> syntax) must be bound using the provided constraint parameter values.
				For example, the variable <code>$class</code> must be bound to the value of <code>sh:class</code> for class constraint components.
				Note that the parameter tables in each of the following sections have a column called Value Type which indicates the expected
				type of the parameter values for documentation purposes, without enforcing any formal restrictions. 
			</p>
			<p>
				Each row in the result set of the SPARQL queries in this document represents one <span class="term">validation result</span>.
				The other variables in the SELECT clause are mapped to the details of each <a href="#results">validation result</a>, e.g. <code>?object</code> is mapped to <code>sh:object</code>.
				<span class="todo">(Clarify what exact compliance level is required, e.g. do they need to produce focus nodes)</span>
				If a row in a SPARQL result set produces <code>true</code> as value for the variable <code>?failure</code> then a <span class="term">failure</span> must be reported.
			</p>
			<p>
				The SPARQL definitions in this section also assume the existence of a built-in SPARQL function <code>sh:hasShape</code>, which is described in the <a href="#hasShape">Appendix</a>.
			</p>
			<p>
				The following table summarizes the parameters used by the core constraint components.
				The table clarifies whether these parameters can be used as part of a
				<code>sh:NodeConstraint</code> (NC, to apply to the focus node itself),
				a <code>sh:PropertyConstraint</code> (PC, to apply to all values of a given property),
				or a <code>sh:InversePropertyConstraint</code> (IPC, to apply to all inverse values of a given property).
			</p>
			<table class="term-table">
				<tr>
					<th>Parameters</th>
					<th>NC</th>
					<th>PC</th>
					<th>IPC</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td>
						<a href="#ClassConstraintComponent"><code>sh:class</code></a>,
						<a href="#ClassInConstraintComponent"><code>sh:classIn</code></a> and
						<a href="#DirectTypeConstraintComponent"><code>sh:directType</code></a>
					</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Type, based on <code>rdf:type</code></td>
				</tr>
				<tr>
					<td>
						<a href="#ClosedConstraintComponent"><code>sh:closed</code></a>
					</td>
					<td>&#9745;</td>
					<td></td>
					<td></td>
					<td>Only allow the declared properties</td>
				</tr>
				<tr>
					<td>
						<a href="#DatatypeConstraintComponent"><code>sh:datatype</code></a> and
						<a href="#DatatypeInConstraintComponent"><code>sh:datatypeIn</code></a>
					</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Datatype, for literals</td>
				</tr>
				<tr>
					<td><a href="#DisjointConstraintComponent"><code>sh:disjoint</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>Property without overlapping values</td>
				</tr>
				<tr>
					<td><a href="#EqualsConstraintComponent"><code>sh:equals</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>Property with equal values</td>
				</tr>
				<tr>
					<td><a href="#HasValueConstraintComponent"><code>sh:hasValue</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>A specific required value</td>
				</tr>
				<tr>
					<td><a href="#InConstraintComponent"><code>sh:in</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Enumeration of allowed values</td>
				</tr>
				<tr>
					<td><a href="#LessThanConstraintComponent"><code>sh:lessThan</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>Must have lesser values than another property</td>
				</tr>
				<tr>
					<td><a href="#LessThanOrEqualsConstraintComponent"><code>sh:lessThanOrEquals</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>Must have lesser or equal values than another property</td>
				</tr>
				<tr>
					<td><a href="#MinCountConstraintComponent"><code>sh:minCount</code></a>, <a href="#MaxCountConstraintComponent"><code>sh:maxCount</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Minimum and maximum cardinality</td>
				</tr>
				<tr>
					<td><a href="#MinLengthConstraintComponent"><code>sh:minLength</code></a>, <a href="#MaxLengthConstraintComponent"><code>sh:maxLength</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Minimum and maximum string length</td>
				</tr>
				<tr>
					<td><a href="#MaxExclusiveConstraintComponent"><code>sh:maxExclusive</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Maximum exclusive value (&gt;)</td>
				</tr>
				<tr>
					<td><a href="#MaxInclusiveConstraintComponent"><code>sh:maxInclusive</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Maximum inclusive value (&gt;=)</td>
				</tr>
				<tr>
					<td><a href="#MinExclusiveConstraintComponent"><code>sh:minExclusive</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Minimum exclusive value (&lt;)</td>
				</tr>
				<tr>
					<td><a href="#MinInclusiveConstraintComponent"><code>sh:minInclusive</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td></td>
					<td>Minimum inclusive value (&lt;=)</td>
				</tr>
				<tr>
					<td><a href="#NodeKindConstraintComponent"><code>sh:nodeKind</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Node kind (IRI, blank node, or literal) of all values</td>
				</tr>
				<tr>
					<td><a href="#PatternConstraintComponent"><code>sh:pattern</code></a></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Regular expression string matching</td>
				</tr>
				<tr>
					<td><a href="#UniqueLangConstraintComponent"><code>sh:uniqueLang</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td></td>
					<td>No duplicate language tags</td>
				</tr>
				<tr>
					<td><a href="#ValueShapeConstraintComponent"><code>sh:valueShape</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Nested shape of all values</td>
				</tr>
				<tr>
					<td><a href="#QualifiedValueShapeConstraintComponent"><code>sh:qualifiedValueShape</code>, <code>sh:qualifiedMinCount</code>, <code>sh:qualifiedMaxCount</code></a></td>
					<td></td>
					<td>&#9745;</td>
					<td>&#9745;</td>
					<td>Nested shape of a given minimum/maximum number of values</td>
				</tr>
			</table>

			<section id="constraints-value-type">
				<h3>Value Type Constraint Components</h3>
				<p>
					The constraint components in this section have in common that they define restrictions
					on the type of the nodes.
				</p>
				<p class="issue" data-number="141" title="How to represent mixed datatype-or-class ranges">
					It is an open issue how to best represent properties that may either take a literal or a non-literal.
				</p>
				<section id="ClassConstraintComponent">
					<h4>sh:class</h4>
					<p>
						The property <code>sh:class</code> can be used to verify that each <span class="term">value node</span> is an instance of a given type.
						The main difference with <a href="#DirectTypeConstraintComponent"><code>sh:directType</code></a> is that <code>sh:class</code> also includes subclasses of the type.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ClassConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>, <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:class</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Type of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that is either a literal or a non-literal without a matching <code>rdf:type</code>.
							A non-literal matches a type if it has an <code>rdf:type</code> value that is the given type or one of its (transitive) subclasses, via <code>rdfs:subClassOf</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS { ?value rdf:type/rdfs:subClassOf* $class } .
}</pre>
					</div>
					<pre class="example-shapes">
ex:ClassExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:class ex:ClassA ;
	] .</pre>

					<pre class="example-data">
ex:InstanceOfClassA
	a ex:ClassA .

ex:ClassExampleValidResource
	ex:someProperty ex:InstanceOfClassA .</pre>
				</section>
				<section id="ClassInConstraintComponent">
					<h4>sh:classIn</h4>
					<p>
						The property <code>sh:classIn</code> can be used to verify that each <span class="term">value node</span> is an instance of a type from a given list.
						The values of <code>sh:classIn</code> must be lists of resources.
						<code>sh:classIn</code> is a generalization of <code>sh:class</code> allowing users to state that the values must have at least one out of several types.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ClassInConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>, <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:classIn</code></td>
							<td><code>rdf:List</code> (members: <code>rdfs:Resource</code>)</td>
							<td>List of types of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that is either a literal or a non-literal without a matching <code>rdf:type</code>.
							A non-literal matches a type if it has an <code>rdf:type</code> value that is one of the types from the list or one of its (transitive) subclasses, via <code>rdfs:subClassOf</code>.
							Each type from the list is tested using the same logic as <code>sh:class</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isLiteral(?value) || NOT EXISTS {
			GRAPH $shapesGraph {
				$classIn (rdf:rest*)/rdf:first ?class .
			}
			FILTER NOT EXISTS { ?value rdf:type/rdfs:subClassOf* ?class }
		})
}</pre>
					</div>
					<pre class="example-shapes">
ex:ClassInExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:classIn ( ex:ClassA ex:ClassB ) ;
	] .</pre>

					<pre class="example-data">
ex:InstanceOfClassA
	a ex:ClassA .

ex:InstanceOfClassB
	a ex:ClassB .

ex:ClassExampleValidResource
	ex:someProperty ex:InstanceOfClassA ;
	ex:someProperty ex:InstanceOfClassB .</pre>
				</section>
				<section id="DatatypeConstraintComponent">
					<h4>sh:datatype</h4>
					<p>
						The property <code>sh:datatype</code> can be used to restrict the datatype of all <span class="term">value nodes</span>.
						The values of <code>sh:datatype</code> must be resources representing datatypes, such as <code>xsd:string</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:DatatypeConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>, <code>sh:property</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:datatype</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Datatype of all value nodes (e.g., <code>xsd:integer</code>)</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that is not a literal, or is a literal with a mismatching datatype.
							A literal matches a datatype if the literal's datatype has the same IRI.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		{
			FILTER isLiteral(?value) .
		} .
		BIND (datatype(?value) AS ?valueDatatype) .
		FILTER (?valueDatatype = $datatype) .
	}
}</pre>
					</div>
					<pre class="example-shapes" title="Shape with sh:datatype property constraint">
ex:DatatypeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:datatype xsd:string ;
	] .</pre>

					<pre class="example-data">
ex:DatatypeShapeExampleValidResource
	ex:someProperty "Some value" .

ex:DatatypeShapeExampleInvalidResource
	ex:someProperty "Value with language tag"@en ;
	ex:someProperty 42 .</pre>
				</section>
				<section id="DatatypeInConstraintComponent">
					<h4>sh:datatypeIn</h4>
					<p>
						The property <code>sh:datatypeIn</code> can be used to restrict the datatype of all <span class="term">value nodes</span>.
						The values of <code>sh:datatypeIn</code> must be lists of resources representing datatypes, such as <code>xsd:string</code>.
						<code>sh:datatypeIn</code> is a generalization of <code>sh:datatype</code> allowing users to state that the values must have one out of several datatypes.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:DatatypeInConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>, <code>sh:property</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:datatype</code></td>
							<td><code>rdf:List</code> (members: <code>rdfs:Resource</code>)</td>
							<td>Allowed datatypes of all value nodes (e.g., <code>xsd:integer</code>)</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that is not a literal, or is a literal with a mismatching datatype.
							A literal matches if the literal's datatype is member of the provided datatypes list.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (!isLiteral(?value) || NOT EXISTS {
			GRAPH $shapesGraph {
				$datatypeIn (rdf:rest*)/rdf:first ?datatype .
			} 
			BIND (datatype(?value) AS ?valueDatatype) .
			FILTER (?valueDatatype = $datatype) .
		})
	}
}</pre>
					</div>
					<pre class="example-shapes" title="Shape with sh:datatypeIn property constraint">
ex:DatatypeInExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:datatypeIn ( xsd:string rdf:langString ) ;
	] .</pre>

					<pre class="example-data">
ex:DatatypeInShapeExampleValidResource
	ex:someProperty "Value with language tag"@en ;
	ex:someProperty "Some string value" .

ex:DatatypeInShapeExampleInvalidResource
	ex:someProperty 42 .</pre>
				</section>
				<section id="DirectTypeConstraintComponent">
					<h4>sh:directType</h4>
					<p>
						The property <code>sh:directType</code> can be used to restrict the <code>rdf:type</code> of all <span class="term">value nodes</span>.
						The main difference with <a href="#ClassConstraintComponent"><code>sh:class</code></a> is that <code>sh:directType</code> does not include subclasses of the type.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:DirectTypeConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>, <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:directType</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Type of all value nodes</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that does not have an <code>rdf:type</code> triple with the given value type as object.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		?value a $directType .
	}
}</pre>
					</div>
				</section>
				<section id="NodeKindConstraintComponent">
					<h4>sh:nodeKind</h4>
					<p>
						The property <code>sh:nodeKind</code> is used to restrict the RDF node kind of each <span class="term">value node</span>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:NodeKindConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>, <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:nodeKind</code></td>
							<td><code>sh:NodeKind</code></td>
							<td>Node kind (IRI, blank node, literal or combinations of these) of all value nodes</td>
						</tr>
					</table>
					<p>
						The values of <code>sh:nodeKind</code> must be instances of the class <code>sh:NodeKind</code>.
						The SHACL system vocabulary defines that <code>sh:NodeKind</code> has exactly 6 instances:
						<code>sh:BlankNode</code>, <code>sh:IRI</code> and <code>sh:Literal</code> as well as the
						following instances that represent combinations of the former three instances, i.e. either-or:
						<code>sh:BlankNodeOrIRI</code>, <code>sh:BlankNodeOrLiteral</code> and <code>sh:IRIOrLiteral</code>.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that does not match the given node kind.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		FILTER ((isIRI(?value) &amp;&amp; $nodeKind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ) ) ||
				(isLiteral(?value) &amp;&amp; $nodeKind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ) ) ||
				(isBlank(?value)   &amp;&amp; $nodeKind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ) )) .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:NodeKindExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:nodeKind ex:IRI ;
	] .</pre>

					<pre class="example-data">
ex:NodeKindShapeExampleValidResource
	ex:someProperty ex:SomeIRI .

ex:NodeKindShapeExampleInvalidResource
	ex:someProperty ex:SomeIRI ;
	ex:someProperty "A literal" .</pre>
				</section>
			</section>

			<section id="constraints-count">
				<h3>Cardinality Constraint Components</h3>
				<p>
					The constraint components in this section can be applied to either a property constraint or an inverse property
					constraints, to represent restrictions on the number of values that the focus node may have for these properties.
				</p>
				<section id="MinCountConstraintComponent">
					<h4>sh:minCount</h4>
					<p>
						The property <code>sh:minCount</code> restricts the number of triples involving the <span class="term">focus node</span> and a given predicate.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MinCountConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum cardinality. If the value is 0 then this constraint is always satisfied and so may be omitted.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the number of
							<span class="term">value nodes</span> is less than the value of <code>sh:minCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	{
		SELECT (COUNT(?value) AS ?count)
		WHERE {
			$this $predicate ?value .
		}
	}
	FILTER (?count &lt; $minCount)
}</pre>
					</div>
					<pre class="example-shapes">
ex:CountExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:CountExampleValidResource
	ex:someProperty ex:OneValue .</pre>
				</section>
				<section id="MaxCountConstraintComponent">
					<h4>sh:maxCount</h4>
					<p>
						The property <code>sh:maxCount</code> restricts the number of triples involving the <span class="term">focus node</span> and a given predicate.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MaxCountConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:maxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum cardinality. If this parameter is omitted then there is no limit on the number of triples.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the number of
							<span class="term">value nodes</span> is greater than the value of <code>sh:maxCount</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	{
		SELECT (COUNT(?value) AS ?count)
		WHERE {
			$this $predicate ?value .
		}
	}
	FILTER (?count &gt; $maxCount))
}</pre>
					</div>
					<pre class="example-shapes">
ex:CountExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:maxCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:CountExampleValidResource
	ex:someProperty ex:OneValue .</pre>
				</section>
			</section>
			
			<section id="constraints-range">
				<h3>Value Range Constraint Components</h3>
				<p>
					The following constraint components represent range restrictions on node that are comparable
					via operators such as <code>&lt;</code> and <code>&gt;</code>.
				</p>
				<section id="range-property-constraints">
					<h4>sh:minExclusive, sh:minInclusive, sh:maxExclusive, sh:maxInclusive</h4>
					<p>
						The properties from the following table restrict the range of objects of triples with the <span class="term">focus node</span>
						as the <span class="term">subject</span> and the given property as the <span class="term">predicate</span>.
						The supported datatypes of these properties are <code>xsd:string</code>, <code>xsd:boolean</code>, <code>xsd:dateTime</code> and all numeric datatypes such as <code>xsd:integer</code>.
					</p>
					<p>
						<span class="component-class">Constraint Components:</span> <code>sh:MinExclusiveConstraintComponent</code>, <code>sh:MinInclusiveConstraintComponent</code>, <code>sh:MaxExclusiveConstraintComponent</code>, <code>sh:MaxInclusiveConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>, <code>sh:property</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
							<th>Definition</th>
						</tr>
						<tr id="MinExclusiveConstraintComponent">
							<td><code>sh:minExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum exclusive value</td>
							<td><code>&lt;</code></td>
						</tr>
						<tr id="MinInclusiveConstraintComponent">
							<td><code>sh:minInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The minimum inclusive value</td>
							<td><code>&lt;=</code></td>
						</tr>
						<tr id="MaxExclusiveConstraintComponent">
							<td><code>sh:maxExclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum exclusive value</td>
							<td><code>&gt;</code></td>
						</tr>
						<tr id="MaxInclusiveConstraintComponent">
							<td><code>sh:maxInclusive</code></td>
							<td>(supported datatypes)</td>
							<td>The maximum inclusive value</td>
							<td><code>&gt;=</code></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that does not match the literal range specified by the table above,
							using the semantics of the SPARQL operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.
							A <span class="term">validation result</span> must also be produced if the node cannot be compared to the specified range.
						</div>
					</div>
					<p>
						Note that if the comparison cannot be performed, for example when someone compares a string with an integer,
						then the validation engine will produce a validation result.  This is different from, say, a plain SPARQL query, in
						which such failures would silently not lead to any results.
					</p>
					<p>
						The following SPARQL definition covers <code>sh:minExclusive</code> - the other variations can be derived by replacing the <code>&gt;</code> operator.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	BIND (?value &gt; $minExclusive AS ?result) .
	FILTER (!?result || !bound(?result)) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:NumericRangeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:minInclusive 1 ;
		sh:maxInclusive 10 ;
	] .</pre>

					<pre class="example-data">
ex:NumericExampleValidResource
	ex:someProperty 7 .

ex:NumericExampleInvalidResource1
	ex:someProperty 11 .

ex:NumericExampleInvalidResource2
	ex:someProperty "a string" .</pre>
				</section>
			</section>

			<section id="constraints-string">
				<h3>String-based Constraint Components</h3>
				<p>
					The constraint components in this section have in common that they are representing
					restrictions on the string representation of certain nodes.
				</p>
				<section id="MinLengthConstraintComponent">
					<h4>sh:minLength</h4>
					<p>
						The property <code>sh:minLength</code> restricts the string length of <span class="term">value nodes</span>.
						This can be applied to any type of literal and IRIs, but not for blank nodes.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MinLengthConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>, <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:minLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum length. If the value is 0 then there is no restriction on the string length but this constraint is still violated if the node is a blank node.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							where the length of its string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							is less than the specified minimum length, or if the node is a blank node.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || STRLEN(str(?value)) &lt; $minLength) .
}</pre>
					</div>
				</section>
				<section id="MaxLengthConstraintComponent">
					<h4>sh:maxLength</h4>
					<p>
						The property <code>sh:maxLength</code> restrict the string length of <span class="term">value nodes</span>
						This can be applied to any type of literal and IRIs, but not for blank nodes.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:MaxLengthConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>, <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:maxLength</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum length. If this constraint is omitted then there is no restriction on the string length and no requirement that the node is a literal or IRI.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							where the length of its string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							is greater than the specified maximum length, or if the node is a blank node.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || STRLEN(str(?value)) &gt; $minLength) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:PasswordExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:password ;
		sh:minLength 8 ;
		sh:maxLength 10 ;
		rdfs:comment "Password must be between 8 and 10 characters long" ;
	] .</pre>

					<pre class="example-data">
ex:PasswordExampleValidResource
	ex:password "password" .</pre>
				</section>
				<section id="PatternConstraintComponent">
					<h4>sh:pattern</h4>
					<p>
						The property <code>sh:pattern</code> can be used to validate whether all <span class="term">value nodes</span> match a given regular expression.
						The values of <code>sh:pattern</code> must be valid pattern arguments for the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:PatternConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>, <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:pattern</code></td>
							<td><code>xsd:string</code></td>
							<td>Regular expression that all value nodes must match</td>
						</tr>
						<tr>
							<td><code>sh:flags</code></td>
							<td><code>xsd:string</code> (optional)</td>
							<td>An optional string of flags, interpreted as in <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL 1.1 REGEX</a></td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							where the string representation (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-str">SPARQL str function</a>)
							does not match the given regular expression (as defined by the <a href="http://www.w3.org/TR/sparql11-query/#func-regex">SPARQL REGEX function</a>).
							If <code>sh:flags</code> is present then this must be interpreted according to the SPARQL REGEX function. 
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (isBlank(?value) || IF(bound($flags), !regex(str(?value), $pattern, $flags), !regex(str(?value), $pattern))) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:PatternExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:pattern "^Ali" ;
		sh:flags "i" ;       # Ignore case
	] .</pre>
					<pre class="example-data">
ex:PatternShapeExampleValidResource
	ex:someProperty "alice" .

ex:PatternShapeExampleInvalidResource
	ex:someProperty "The Alice" .</pre>
				</section>
				<section id="StemConstraintComponent">
					<h4>sh:stem</h4>
					<p>
						The property <code>sh:stem</code> validates whether all <span class="term">value nodes</span> are IRIs and the IRI starts with a given string value.
						<code>sh:stem</code> is a shortcut for <code>sh:nodeKind sh:IRI</code> and <code>sh:pattern "^{stem value}"</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:StemConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>, <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:stem</code></td>
							<td><code>xsd:string</code></td>
							<td>String value that an IRI must start with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							that is not an IRI and the <a href="https://www.w3.org/TR/sparql11-query/#func-str">string representation</a> of the IRI value does not <a href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#func-strstarts">start with</a> the given string.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER (!isIRI(?value) || !STRSTARTS(str(?value), $stem) ) .
}</pre>
					</div>
					<pre class="example-shapes">
ex:PatternExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:w3cHomepage ;
		sh:stem "https://www.w3.org/People/" ;
	] .</pre>
					<pre class="example-data">
ex:Alice ex:w3cHomepage &lt;https://www.w3.org/People/Alice&gt; .
<span class="focus-node-error">ex:Bob</span> ex:w3cHomepage &lt;https://example.com/People/Bob&gt; .
<span class="focus-node-error">ex:Carol</span> ex:w3cHomepage "https://www.w3.org/People/Carol" .</pre>
				</section>
				<section id="UniqueLangConstraintComponent">
					<h4>sh:uniqueLang</h4>
					<p>
						The property <code>sh:uniqueLang</code> can be set to <code>true</code> to specify that no pair of value nodes may use the same language tag.
						The values of <code>sh:uniqueLang</code> must be <code>xsd:boolean</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:UniqueLangConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:property</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:uniqueLang</code></td>
							<td><code>xsd:boolean</code></td>
							<td><code>true</code> to activate this constraint</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							If <code>sh:uniqueLang</code> is set to <code>true</code> then a <span class="term">validation result</span> must be produced for each non-empty language tag that is
							used by at least two <span class="term">value nodes</span>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT DISTINCT $this ($this AS ?subject) $predicate
WHERE {
	{
		FILTER ($uniqueLang) .
	}
	$this $predicate ?value .
	BIND (lang(?value) AS ?lang) .
	FILTER (bound(?lang) &amp;&amp; ?lang != "") . 
	FILTER EXISTS {
		$this $predicate ?otherValue .
		FILTER (?otherValue != ?value &amp;&amp; ?lang = lang(?otherValue)) .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:UniqueLangExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:uniqueLang true ;
	] .</pre>

					<pre class="example-data">
ex:UniqueLangShapeExampleValidResource
	ex:someProperty "Me" ;
	ex:someProperty "Me"@en ;
	ex:someProperty "Moi"@fr .

ex:UniqueLangShapeExampleInvalidResource
	ex:someProperty "Me"@en ;
	ex:someProperty "Myself"@en .</pre>
				</section>
			</section>
			
			<section id="constraints-property-pairs">
				<h3>Property Pair Constraint Components</h3>
				<p>
					The constraint components in this section restrict the sets of values represented by
					the <code>sh:predicate</code> used in the property constraint, and another property
					that is specified as the value of the respective parameter such as <code>sh:equals</code>.
				</p>
				<p class="issue" data-number="136" title="Naming of property pair constraint components">
					The names of the following properties have been the source of confusion and may get renamed.
				</p>
				<section id="EqualsConstraintComponent">
					<h3>sh:equals</h3>
					<p>
						<code>sh:equals</code> constrains a pair of properties so that the value sets of both properties at a given focus node must be equal.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:EqualsConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:property</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:equals</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>Property to compare with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced
							for each value of <code>sh:predicate</code> that does not exist as value of <code>sh:equals</code> and
							for each value of <code>sh:equals</code> that does not exist as value of <code>sh:predicate</code>
							at the given <span class="term">focus node</span>.
							The produced <span class="term">validation result</span> must have the corresponding values of the existing triple as <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	{
		$this $predicate ?object .
		FILTER NOT EXISTS {
			$this $equals ?object .
		}
	}
	UNION
	{
		$this $equals ?object .
		FILTER NOT EXISTS {
			$this $predicate ?object .
		}
	}
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:equals</code> in a shape to verify
						that certain nodes must have the same value sets for <code>ex:firstName</code> and <code>ex:givenName</code>.
					</p>
					<pre class="example-shapes">
ex:EqualExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:firstName ;
		sh:equals ex:givenName ;
	] .</pre>
					<pre class="example-data">
ex:ValidInstance1
	ex:firstName "John" ;
	ex:givenName "John" .</pre>
				</section>
				<section id="DisjointConstraintComponent">
					<h3>sh:disjoint</h3>
					<p>
						<code>sh:disjoint</code> constrains a pair of properties so that the value sets of both properties at a given focus node must not share any values.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:DisjointConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:property</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:disjoint</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each value of <code>sh:predicate</code>
							that also exists as value of <code>sh:disjoint</code> at the given <span class="term">focus node</span>.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the value as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	$this $disjoint ?object .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:disjoint</code> in a shape to verify
						that certain nodes must not share any values for <code>ex:prefLabel</code> and <code>ex:altLabel</code>.
					</p>
					<pre class="example-shapes">
ex:DisjointExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:prefLabel ;
		sh:disjoint ex:altLabel ;
	] .</pre>
					<pre class="example-data">
ex:ValidInstance1
	ex:prefLabel "USA" ;
	ex:altLabel "United States" .

ex:InvalidInstance1
	ex:prefLabel "Germany" ;
	ex:altLabel "Germany" .</pre>
				</section>
				<section id="LessThanConstraintComponent">
					<h3>sh:lessThan</h3>
					<p>
						<code>sh:lessThan</code> constrains a pair of properties so that the values of the first property must be smaller than the values of the second property at a given focus node.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:LessThanConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:property</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:lessThan</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each pair of values of <code>sh:predicate</code>
							and <code>sh:lessThan</code> at the given <span class="term">focus node</span>, where
							the first value is not less than the second value, based on SPARQL's <code>&lt;</code> operator.
							A validation result must also be produced if the two values cannot be compared.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the value of <code>sh:predicate</code> as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	$this $lessThan ?object2 .
	FILTER (!(?object &lt; ?object2)) .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:lessThan</code> in a shape to verify
						that all values of <code>ex:startDate</code> must "before" the values of <code>ex:endDate</code>.
					</p>
					<pre class="example-shapes">
ex:LessThanExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:startDate ;
		sh:lessThan ex:endDate ;
	] .</pre>
				</section>
				<section id="LessThanOrEqualsConstraintComponent">
					<h3>sh:lessThanOrEquals</h3>
					<p>
						<code>sh:lessThanOrEquals</code> constrains a pair of properties so that the values of the first property must be smaller than or equal to the values of the second property at a given focus node.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:LessThanOrEqualsConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:property</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:lessThanOrEquals</code></td>
							<td><code>rdfs:Resource</code></td>
							<td>The property to compare the values with</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each pair of values of <code>sh:predicate</code>
							and <code>sh:lessThanOrEquals</code> at the given <span class="term">focus node</span>, where
							the first value is not less than or equal to the second value, based on SPARQL's <code>&lt;=</code> operator.
							A validation result must also be produced if the two values cannot be compared.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							the <code>sh:predicate</code> as its <code>sh:predicate</code> and the value of the first predicate as its <code>sh:object</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	$this $lessThanOrEquals ?object2 .
	FILTER (!(?object &lt;= ?object2)) .
}</pre>
					</div>
				</section>
			</section>				
	
			<section id="constraints-logical">
				<h3>Logical Constraint Components</h3>
				<p>
					The constraint components implement the common logical operators <span class="term">and</span>,
					<span class="term">or</span> and <span class="term">not</span>.
				</p>
				<p class="issue" data-number="135" title="Should sh:and/sh:or/sh:not support constraints too">
					There is a proposal to generalize the following components to also allow their values to be constraints, not just shapes.
				</p>
				<section id="NotConstraintComponent">
					<h3>sh:not</h3>
					<p>
						SHACL supports a high-level negation constraint that can be used to verify that the <span class="term">focus node</span> does not have a given shape.
						This is comparable to a logical "not" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:NotConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:not</code></td>
							<td><code>sh:Shape</code></td>
							<td>The shape to negate</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the <span class="term">focus node</span> produces no validation results with severity <code>sh:Violation</code> for the shape given via <code>sh:not</code>.
							A <span class="term">failure</span> must be reported if the validation of the shape produces a failure.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	BIND (sh:hasShape($this, $not, $shapesGraph) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || ?hasShape) .
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:not</code> in a shape to verify
						that certain nodes cannot have any value of <code>ex:property</code>.
					</p>
					<pre class="example-shapes">
ex:NotExampleShape
	a sh:Shape ;
	sh:constraint [
		sh:not [
			a sh:Shape ;
			sh:property [
				sh:predicate ex:property ;
				sh:minCount 1 ;
			] ;
		]
	] .</pre>
					<pre class="example-data">
ex:InvalidInstance1
  	ex:property "Some value" .</pre>
				</section>
				<section id="AndConstraintComponent">
					<h3>sh:and</h3>
					<p>
						SHACL supports a high-level syntax for conjunctive constraints that can be used to test whether the <span class="term">focus node</span> has all out of several shapes.
						This is comparable to a logical "and" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:AndConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:and</code></td>
							<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
							<td>List of shapes to validate the focus node against</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the following condition is false:
							The validation of the <span class="term">focus node</span> against all of the shapes in the <code>sh:and</code> list produces a validation result with severity <code>sh:Violation</code> for at least one shape.
							A <span class="term">failure</span> must be produced if the validation of one of the shapes fails.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			GRAPH $shapesGraph {
				$and rdf:rest*/rdf:first ?shape .
			}
			BIND (sh:hasShape($this, ?shape, $shapesGraph) AS ?hasShape) .
			BIND (IF(bound(?hasShape), IF(!?hasShape, 1, 0), 'error') AS ?s) .
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &gt; 0) .
}</pre>
					</div>
					<p>
						Note that although <code>sh:and</code> has an <code>rdf:List</code> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:and</code> in a shape to verify
						that certain nodes have exactly one value of <code>ex:property</code>.
						This is achieved via the conjunction of a separate named shape (<code>ex:SuperShape</code>) which defines
						the minimum count, and a blank node shape that further constrains the maximum count.
						As shown here, <code>sh:and</code> can be used to implement a specialization mechanism between shapes. 
					</p>
					<pre class="example-shapes">
ex:SuperShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:minCount 1 ;
	] .

ex:ExampleAndShape
	a sh:Shape ;
	sh:constraint [
		sh:and (
			ex:SuperShape
			[
				a sh:Shape ;
				sh:property [
					sh:predicate ex:property ;
					sh:maxCount 1 ;
				]
			]
		)
	] .</pre>

<pre class="example-data">
ex:ValidInstance1
	ex:property "One" .

# Invalid: more than one property
ex:InvalidInstance2
	ex:property "One" ;
	ex:property "Two" .</pre>
				</section>
				<section id="OrConstraintComponent">
					<h3>sh:or</h3>
					<p>
						SHACL supports a high-level syntax for disjunctive constraints that can be used to test whether the <span class="term">focus node</span> has at least one out of several shapes.
						This is comparable to a logical "or" operator.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:OrConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:or</code></td>
							<td><code>rdf:List</code> (members: <code>sh:Shape</code>)</td>
							<td>List of shapes to validate the focus node against</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the following condition is false:
							The validation of the <span class="term">focus node</span> against all of the shapes in the <code>sh:or</code> list produces no validation results with severity <code>sh:Violation</code> for at least one shape.
							A <span class="term">failure</span> must be produced if the validation of one of the shapes fails.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			GRAPH $shapesGraph {
				$or rdf:rest*/rdf:first ?shape .
			}
			BIND (sh:hasShape($this, ?shape, $shapesGraph) AS ?hasShape) .
			BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count = 0) .
}</pre>
					</div>
					<p>
						Note that although <code>sh:or</code> has an <code>rdf:List</code> of shapes as its value,
						the order of those shapes does not impact the validation results.
					</p>
					<p>
						The following example illustrates the use of <code>sh:or</code> in a shape to verify
						that certain nodes have at least one value of <code>ex:exampleProperty1</code>
						or at least one value of <code>ex:exampleProperty2</code>.
					</p>
					<pre class="example-shapes">
ex:OrConstraintExampleShape
	a sh:Shape ;
	sh:constraint [
		sh:or (
			[
				sh:property [
					sh:predicate ex:exampleProperty1 ;
					sh:minCount 1 ;
				]
			]
			[
				sh:property [
					sh:predicate ex:exampleProperty2 ;
					sh:minCount 1 ;
				]
			]
		)
	] .</pre>

					<pre class="example-data">
ex:OrConstraintExampleValidResource
	ex:exampleProperty1 ex:someValue .</pre>
				</section>
			</section>
	
			<section id="constraints-shape">
				<h3>Shape-based Constraint Components</h3>
				<p>
					The constraint components in this section can be used to represent complex restrictions
					based on applying shape definitions on the property values. 
				</p>
				<section id="ValueShapeConstraintComponent">
					<h4>sh:valueShape</h4>
					<p>
						The property <code>sh:valueShape</code> can be used verify that all values of the given property must have a given shape.
						The value type of <code>sh:valueShape</code> is <code>sh:Shape</code>, but the <code>rdf:type</code> triple of those shapes can be omitted.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ValueShapeConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:valueShape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of all values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced for each <span class="term">value node</span>
							where validating the value node against the shape specified by <code>sh:valueShape</code> 
							produces any validation results with severity <code>sh:Violation</code> or a failure.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?object ?failure
WHERE {
	$this $predicate ?object .
	BIND (sh:hasShape(?object, $valueShape, $shapesGraph) AS ?hasShape) .
	BIND (!bound(?hasShape) AS ?failure) .
	FILTER (?failure || !?hasShape) .
}</pre>
					</div>
					<p class="issue" data-number="22" title="Treatment of recursive shape definitions">
						According to resolution <a href="https://www.w3.org/2015/12/16-shapes-minutes.html#resolution04">2015.12.16/04</a> shapes graphs with dependency loops are invalid and suitable limitations of this will be explored.
						Until issue 22 is closed, definitions regarding recursion are not endorsed by the WG.
					</p>
					<p>
						A shape may refer to itself directly or indirectly via <code>sh:valueShape</code>, <code>sh:filterShape</code>, etc.
						Such a shape is said to be <em>recursive</em>.
						The meaning of non-recursive shapes is always well-founded.
						In contrast, the meaning of a recursive shape may not be well-founded.
						As a starting point, the SHACL specification only defines the meaning of non-recursive shapes.
						However, there are use-cases where recursion is valuable, either for its inherent expressive power or because it makes the
						intension of shapes clearer.
						The Working Group will therefore explore conditions under which recursive shapes can be assigned a well-defined meaning and will
						relax the restrictions on recursion accordingly. 
					</p>
					<p>
						In the following example, all values of the property <code>ex:someProperty</code> will validate with no results for the shape
						specified by a blank node that ensures that the property <code>ex:nestedProperty</code> has at least one value.
					</p>
					<pre class="example-shapes">
ex:ValueShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:valueShape [
			a sh:Shape ;   # Optional
			sh:predicate [
				sh:predicate ex:nestedProperty ;
				sh:minCount 1 ;
			]
		]
	] .</pre>

					<pre class="example-data">
ex:ValueShapeExampleValidResource
	ex:someProperty [
		ex:nestedProperty 42 ;
	] .</pre>
				</section>
				<section id="QualifiedValueShapeConstraintComponent">
					<h4>sh:qualifiedValueShape, sh:qualifiedMinCount, sh:qualifiedMaxCount</h4>
					<div class="issue" data-number="92" title="Relationship of QCRs with Partitions">
						Feature at risk:
						There is an ongoing proposal (see sh:partition) that strongly overlaps with the QCRs proposed here.
						The WG may decide to support only one of these options, but not both.
					</div>
					<p>
						The property <code>sh:qualifiedValueShape</code> can be used verify that a certain number  of values of the given property must have a given shape.
						The value type of <code>sh:qualifiedValueShape</code> is <code>sh:Shape</code>, and it needs to be accompanied by
						a <code>sh:qualifiedMinCount</code> or a <code>sh:qualifiedMaxCount</code> (both typed <code>xsd:integer</code>), or both.
						The <code>rdf:type</code> of the value shapes can be omitted.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:QualifiedValueShapeConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:property</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:qualifiedValueShape</code></td>
							<td><code>sh:Shape</code></td>
							<td>The required shape of the specified values</td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMinCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The minimum number of values that must have the shape. If this constraint is omitted then there is no minimum number of values required. </td>
						</tr>
						<tr>
							<td><code>sh:qualifiedMaxCount</code></td>
							<td><code>xsd:integer</code></td>
							<td>The maximum number of values that can have the shape. If this constraint is omitted then there is no maximum number of values required.</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMinCount</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the number of triples that have
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where validating the object against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no validation results with severity <code>sh:Violation</code> or a failure is less than
							<code>sh:qualifiedMinCount</code>.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							and the <code>sh:predicate</code> as its <code>sh:predicate</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:qualifiedMinCount</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			{
				FILTER NOT EXISTS { $this $predicate ?value } .
				BIND (0 AS ?s) .
			}
			UNION
			{
				$this $predicate ?value .
				BIND (sh:hasShape(?value, $qualifiedValueShape, $shapesGraph) AS ?hasShape) .
				BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
			}
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &lt; $qualifiedMinCount) .
}</pre>
					</div>
					<p>
						Note that in the SPARQL query above, we assume that the <code>SUM</code> operation fails
						if one of the values of <code>?s</code> is not a number.
						This mechanism is used by the error handling, which sets <code>?s</code> to the string <code>'error'</code>
						whenever one of the individual <code>sh:hasShape</code> calls fails.
					</p>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION of sh:qualifiedMaxCount</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the number of triples that have
							the <span class="term">focus node</span> as its subject, the <code>sh:predicate</code>
							as its predicate and where validating the object against the shape specified by <code>sh:qualifiedValueShape</code>
							produces no validation results with severity <code>sh:Violation</code> or a failure is greater than
							<code>sh:qualifiedMaxCount</code>.
							The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
							and the <code>sh:predicate</code> as its <code>sh:predicate</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION of sh:qualifiedMaxCount</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate ?failure
WHERE {
	{
		SELECT (SUM(?s) AS ?count)
		WHERE {
			{
				FILTER NOT EXISTS { $this $predicate ?value } .
				BIND (0 AS ?s) .
			}
			UNION
			{
				$this $predicate ?value .
				BIND (sh:hasShape(?value, $qualifiedValueShape, $shapesGraph) AS ?hasShape) .
				BIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .
			}
		}
	}
	BIND (!bound(?count) AS ?failure) .
	FILTER IF(?failure, true, ?count &gt; $qualifiedMaxCount) .
}</pre>
					</div>
					<p>
						In the following example, the property <code>ex:parent</code> must have exactly two values,
						and at least one of them needs to be female.
					</p>
					<pre class="example-shapes">
ex:QualifiedValueShapeExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:parent ;
		sh:minCount 2 ;
		sh:maxCount 2 ;
		sh:qualifiedValueShape [
			a sh:Shape ;   # Optional
			sh:property [
				sh:predicate ex:gender ;
				sh:hasValue ex:female ;
			]
		] ;
		sh:qualifiedMinCount 1 ;
	] .</pre>

					<pre class="example-data">
ex:QualifiedValueShapeExampleValidResource
	ex:parent ex:John ;
	ex:parent ex:Jane .

ex:John
	ex:gender ex:male .

ex:Jane
	ex:gender ex:female .</pre>
				</section>
				<section id="PartitionConstraintComponent">
					<h4>sh:partition</h4>
					<div class="issue" data-number="92" title="Under Development">
						This section is one proposal to resolve ISSUE-92.
					</div>
					<p>
						In some cases a given property may be multi-valued and it may be required that the set of values
						be partitioned into two or more subsets, each of which satisfies certain constraints.
					</p>
					<p>
						For example, suppose that in the Library of Congress BIBFRAME (<code>bf:</code>) Cultural Heritage vocabulary each person (<code>bf:Person</code>) must be identified by 
						(<code>bf:identifiedBy</code>) exactly one identifier from <code>id.loc.gov</code> and may have another identifier
						from <code>viaf.org</code>. No other identifiers are allowed. Thus the set of all identifiers is partitioned into
						two subsets, the first of which contains exactly one member and the second of which contains zero or one members.
						The following example shows a snippet of some valid BIBFRAME data.
					</p>
					<pre class="example-data" title="Valid BIBFRAME Data">&lt;bf_Person1>
  	bf:identifiedBy &lt;http://id.loc.gov/authorities/names/n80103961#RWO> ;
 	bf:identifiedBy &lt;https://viaf.org/viaf/268367832/#Knape,_Joachim> .</pre>
					<p>
						The following example shows a snippet of some invalid BIBFRAME data.
					</p>
					<pre class="example-data" title="Invalid BIBFRAME Data">&lt;bf_Person1>
  	bf:identifiedBy &lt;http://id.loc.gov/authorities/names/n80103961#RWO> ;
 	bf:identifiedBy &lt;https://viaf.org/viaf/268367832/#Knape,_Joachim> ;
	bf:identifiedBy "this is a mistake" . # should be an error</pre>
					<p>
						Qualified cardinality constraints provide a basis for expressing this type of partitioning requirement, but using them imposes a burden on the shapes author. In the BIBFRAME example the author would need to express the requirement that the set of all identifiers that are from neither <code>id.loc.gov</code> nor <code>viaf.org</code> is empty, i.e. it has a maximum cardinality of 0. Clearly, as more subsets of values are involved, the burden on the author increases.
						The <code>sh:partition</code> constraint makes it easier to express this type of requirement than it would be to use 
						multiple qualified cardinality constraints.
						In effect, <code>sh:partition</code> chains together a sequence of qualified cardinality constraints and removes the set of context nodes matched by each from further consideration. If every context node gets matched in this process, then
						the <code>sh:partition</code> constraint reports no violations. Otherwise, any context nodes remaining are reported as
						violations of the constraint.
						The BIBFRAME example constraint is expressed as follows.
					</p>
					<pre class="example-shapes" title="BIBFRAME constraint expressed using sh:partition">
ex:BibframeShape a sh:Shape ;
	sh:property [
		sh:predicate bf:identifiedBy ;
		sh:partition (
			[sh:minCount 1; sh:maxCount 1; sh:pattern "^http://id.loc.gov/"]
			[sh:maxCount 1; sh:pattern "^https://viaf.org/"]
		)
] .</pre>
					<p>
						The value of the <code>sh:partition</code> constraint parameter MUST be an <code>rdf:List</code> that contains zero or more resources. 
						Each resource in the list defines conditions on a subset of the context nodes and MAY contain the following parameters:
					</p>
					<ul>
						<li>zero or one <code>sh:minCount</code>. This defines the minimum cardinality of the corresponding subset.</li>
						<li>zero or one <code>sh:maxCount</code>. This defines the maximum cardinality of the corresponding subset.</li>
						<li>any combination of parameters associated with node validation constraints. A node validation constraint
							is any constraint defined by a boolean function on nodes. 
							These include the built-in constraints defined by <code>sh:nodeKind</code>, <code>sh:partition</code>,
							<code>sh:minExclusive</code>, etc.
							The corresponding subset consists of those remaining nodes for which the boolean function is <code>true</code>.</li>
					</ul>
					<p>
						Note that a resource that contains no parameters matches all nodes. Such a resource is useful as the last member of the list where it acts as a default matching rule in the case where nodes that do not match any of the preceeding constraints are allowed. 
						Note also that a qualified cardinality constraint defined using <code>sh:qualifiedValueShape</code>,
						<code>sh:qualifiedMinCount</code>, and <code>sh:qualifiedMaxCount</code> is equivalent to a <code>sh:partition</code> constraint that contains two resources with the first one containing the corresponding parameters and the last one being the default matching rule that matches any set of nodes.
					</p>
					<p>
						Each member of the list is used by the SHACL processor to match a subset of the context nodes.
						The SHACL processor matches as many nodes as possible and then compares the result with the specified
						minimum and maximum cardinalities if specified. This is referred to as a <em>greedy</em> matching algorithm.
						Greedy pattern matching is commonly used with textual regular expressions.
						Nodes that match are removed from further matching. Thus the set of all context nodes becomes partitioned by 
						the matching algorithm. The following paragraphs define this algorithm more precisely.
					</p>
					<p>
						Let D be a data graph and let F be a focus node in D. Let S be a shapes graph, let T be a shape in S, 
						and let C be a <code>sh:partition</code> constraint in T. 
						Let N be the set of context nodes for C in D at F. Recall that N depends on how C is related to T. 
					</p>
					<ul>
						<li>If (T, <code>sh:constraint</code>, C) is in S then N consists of just the node F.</li>
						<li>If (T, <code>sh:property</code>, C) and (C, <code>sh:predicate</code>, P) are in S 
							then N consists of all the nodes X such that (F, P, X) is in D.</li>
						<li>If (T, <code>sh:inverseProperty</code>, C) and (C, <code>sh:predicate</code>, P) are in S 
							then N consists of all the nodes X such that (X, P, F) is in D.</li>
					</ul>
					<p>
						Let the value of the <code>sh:partition</code> parameter be the list (Q<sub>1</sub>, ..., Q<sub>n</sub>) of resources.
						The SHACL validator MUST perform the following steps to validate the constraint C at F.
					</p>
					<ol>
						<li>Let R denote the set of remaining context nodes. Initialize R to N.</li>
						<li>Repeat the following for Q = Q<sub>1</sub>, ..., Q<sub>n</sub>
						<ol>
							<li>Let P be the conjunction of all the node validation constraints in Q.</li>
							<li>Compute R' to be the set of all nodes in R that satisfy P, i.e. R' = {X in R | P(X) = true}</li>
							<li>If Q contains a minimum cardinality m<sub>min</sub> and the number of nodes in R' is less than m<sub>min</sub>,
							i.e. m<sub>min</sub> > #R', then report a constraint violation and exit the loop.</li>
							<li>If Q contains a maximum cardinality m<sub>max</sub> and the number of nodes in R' is greater then m<sub>max</sub>,
							i.e. m<sub>max</sub> &lt; #R', then report a constraint violation and exit the loop.</li>
							<li>Remove R' from R, i.e. set R = R \ R'.</li>
						</ol>
						</li>
						<li>If R is non-empty and no violations have been reported yet then report a violation.</li>
					</ol>
					<p>
						Note that the order of resources within the list is significant. 
						In general, if the members of the list are reordered then different context node sets will be matched
						and different violation results will be reported.
					</p>
				</section>
			</section>
			
			<section id="constraints-others">
				<h3>Other Constraint Components</h3>
				<p>
					This section enumerates core constraint components that did not fit into the other categories.
				</p>
				<section id="ClosedConstraintComponent">
					<h3>sh:closed, sh:ignoredProperties</h3>
					<p>
						The RDF data model offers a huge amount of flexibility.
						Any resource can in principle have values for any property.
						However, in some cases it makes sense to restrict which properties can be applied to resources.
						The SHACL core language includes a property called <code>sh:closed</code> that can be assigned to
						a shape via the property <code>sh:constraint</code> to indicate that valid resources must only have
						values for those properties that have been explicitly declared via <code>sh:property</code>.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:ClosedConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:closed</code></td>
							<td><code>xsd:boolean</code></td>
							<td>Set to <code>true</code> to close the shape</td>
						</tr>
						<tr>
							<td><code>sh:ignoredProperties</code></td>
							<td><code>rdf:List</code> (members: <code>rdf:Property</code>)</td>
							<td>Optional list of properties that are also permitted in addition to those explicitly enumerated via <code>sh:property</code></td>
						</tr>
					</table>
					<div id="def-ClosedShape-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							If <code>sh:closed</code> is <code>true</code> then
							a <span class="term">validation result</span> must be produced for each triple that has the <span class="term">focus node</span> as its
							<span class="term">subject</span> and a <span class="term">predicate</span> that is not explicitly enumerated as a <code>sh:predicate</code>
							of the <code>sh:property</code> constraints at the surrounding shape.
							If the argument <code>sh:ignoredProperties</code> is present then the properties enumerated in this list are also permitted.
							The produced <span class="term">validation result</span> must have the corresponding values of the triple as <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>.
						</div>
					</div>
					<p>
						The core vocabulary includes an instance of <code>sh:NodeConstraint</code> called <code>sh:Closed</code>
						that can be used in places where no other arguments such as <code>sh:ignoredProperties</code> are needed.
					</p>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) ?predicate ?object
WHERE {
	{
		FILTER $closed .
	}
	$this ?predicate ?object .
	FILTER (NOT EXISTS {
		GRAPH $shapesGraph {
			$currentShape sh:property/sh:predicate ?predicate .
		}
	} &amp;&amp; (!bound($ignoredProperties) || NOT EXISTS {
		GRAPH $shapesGraph {
			$ignoredProperties rdf:rest*/rdf:first ?predicate .
		}
	}))
}</pre>
					</div>
					<p>
						The following example illustrates the use of <code>sh:closed</code> in a shape to verify
						that certain nodes only have values for <code>ex:exampleProperty1</code> and <code>ex:exampleProperty2</code>.
						The "ignored" property <code>rdf:type</code> would also be allowed.
					</p>
					<pre class="example-shapes">
ex:ClosedShapeExampleShape
	a sh:Shape ;
	sh:constraint [
		sh:closed true ;
		sh:ignoredProperties (rdf:type) ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty1 ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty2 ;
	] .</pre>

					<pre class="example-data">
ex:ClosedShapeExampleValidResource
	ex:exampleProperty1 ex:someValue .

ex:ClosedShapeExampleInvalidResource
	ex:exampleProperty2 ex:someValue ;
	ex:someOtherProperty 42 .</pre>
					<p>
						The next example illustrates a more compact syntax using the built-in instance <code>sh:Closed</code>.
						In this form, no ignored properties can be specified.
					</p>
					<pre class="example-shapes">
ex:ClosedShapeExampleShape
	a sh:Shape ;
	sh:constraint sh:Closed ;
	sh:property [
		sh:predicate ex:exampleProperty1 ;
	] ;
	sh:property [
		sh:predicate ex:exampleProperty2 ;
	] .</pre>
				</section>
				<section id="HasValueConstraintComponent">
					<h4>sh:hasValue</h4>
					<p>
						The property <code>sh:hasValue</code> can be used to verify
						that the <span class="term">focus node</span> has a given RDF node among the values of the given
						predicate.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:HasValueConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:hasValue</code></td>
							<td>any</td>
							<td>A specific required value</td>
						</tr>
					</table>
					<div id="def-hasValue-text" class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							A <span class="term">validation result</span> must be produced if the <code>sh:hasValue</code> is not among the <span class="term">value nodes</span>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate
WHERE {
	FILTER NOT EXISTS {
		$this $predicate $hasValue .
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:HasValueExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:property ;
		sh:hasValue ex:Green ;
	] .</pre>

					<pre class="example-data">
ex:HasValueExampleValidResource
	ex:property ex:Green .</pre>
				</section>
				<section id="InConstraintComponent">
					<h4>sh:in</h4>
					<p>
						The property <code>sh:in</code> exclusively enumerates the value nodes that a property may have.
						When specified, each value of the given property must be a member of the specified list.
					</p>
					<p>
						<span class="component-class">Constraint Component:</span> <code>sh:InConstraintComponent</code>
					</p>
					<p>
						<span class="parameter-context">Supported Context Properties:</span> <code>sh:constraint</code>, <code>sh:property</code>, <code>sh:inverseProperty</code>
					</p>
					<div class="parameters">Parameters:</div>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value Type</th>
							<th>Summary</th>
						</tr>
						<tr>
							<td><code>sh:in</code></td>
							<td><code>rdf:List</code></td>
							<td>Enumeration of allowed values</td>
						</tr>
					</table>
					<div class="def def-text">
						<div class="def-header">TEXTUAL DEFINITION</div>
						<div class="def-text-body">
							The values of <code>sh:in</code> must be well-formed instances of <code>rdf:List</code>.
							The members of that <code>rdf:List</code> must not be blank nodes.
							A <span class="term">validation result</span> must be produced for every <span class="term">value node</span>
							that is not a member of the given list.
							Matching of literals needs to be exact, e.g. <code>"04"^^xsd:byte</code> does not match <code>"4"^^xsd:integer</code>.
						</div>
					</div>
					<div class="def def-sparql">
						<div class="def-header">SPARQL DEFINITION (for property constraints)</div>
<pre class="def-sparql-body">
SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
WHERE {
	$this $predicate ?value .
	FILTER NOT EXISTS {
		GRAPH $shapesGraph {
			$in (rdf:rest*)/rdf:first ?value .
		}
	}
}</pre>
					</div>
					<pre class="example-shapes">
ex:AllowedValuesExampleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:someProperty ;
		sh:in ( ex:Value1 ex:Value2 ex:Value3 ) ;
	] .</pre>

					<pre class="example-data">
ex:InExampleValidResource
	ex:someProperty ex:Value2 .</pre>
				</section>
			</section>
				
			<section id="nonValidation">
				<h4>Non-Validating Constraint Characteristics</h4>
				<p>
					While the previous sections introduced properties that represent validation conditions,
					this section covers properties that are ignored by SHACL validation engines.
					The use of these properties is entirely optional and not subject to formal interpretation contracts.
					They may be used for purposes such as form building, predictable printing of RDF files, etc.
				</p>
				<p id="name">
					Property constraints may have one or more values for <code>sh:name</code> to provide human-readable labels for the property in the scope where it appears.
					If present, tools SHOULD prefer those locally defined labels over globally defined labels at the <code>rdf:Property</code> itself.
					For example, if a form displays a resource that is in the scope of a given shape, and the shape defines a <code>sh:property</code> constraint with an <code>sh:name</code>, then the tool SHOULD use the provided name.
					Similarly, property constraints may have an <code>sh:description</code> to provide a description of the property in the given context.
					Both <code>sh:name</code> and <code>sh:description</code> may have multiple values, but SHOULD only have one value per language tag.
				</p>
				<p id="order">
					Property constraints may have one value for the property <code>sh:order</code> to indicate the relative order of the property constraint for purposes such as form building.
					The values of <code>sh:order</code> must be decimals.
					<code>sh:order</code> is not used for validation purposes.
					If present, the recommended use of <code>sh:order</code> is to sort the property constraints in an ascending order, for example so that
					properties with smaller order are placed above (or to the left) of properties with larger order.
				</p>
				<p id="group">
					Property constraints may link to an instance of the class <code>sh:PropertyGroup</code> using the property <code>sh:group</code> to indicate that
					the constraint belongs to a group of related property constraints.
					Each group may have additional triples that serve application purposes, such as an <code>rdfs:label</code> for form building.
					Groups may also have an <code>sh:order</code> property to indicate the relative ordering of groups within the same form.
				</p>
				<p id="defaultValue">
					Property constraints may have a single value for <code>sh:defaultValue</code>.
					The default value does not have fixed semantics in SHACL, but MAY be used by user interface tools to pre-populate input widgets.
					The value type of the <code>sh:defaultValue</code> SHOULD align with the specified <code>sh:datatype</code>, <code>sh:directType</code> or <code>sh:class</code> of the same constraint.
				</p>
				<p>
					The following example illustrates the use of these various features together.
				</p>
				<pre class="example-shapes">
ex:PersonFormShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:firstName ;
		sh:name "first name" ;
		sh:description "The person's given name(s)" ;
		sh:order 0 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:predicate ex:lastName ;
		sh:name "last name" ;
		sh:description "The person's last name" ;
		sh:order 1 ;
		sh:group ex:NameGroup ;
	] ;
	sh:property [
		sh:predicate ex:streetAddress ;
		sh:name "street address" ;
		sh:description "The street address including number" ;
		sh:order 11 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:predicate ex:locality ;
		sh:name "locality" ;
		sh:description "The suburb, city or town of the address" ;
		sh:order 12 ;
		sh:group ex:AddressGroup ;
	] ;
	sh:property [
		sh:predicate ex:postalCode ;
		sh:name "postal code" ;
		sh:name "zip code"@en-US ;
		sh:description "The postal code of the locality" ;
		sh:order 13 ;
		sh:group ex:AddressGroup ;
	] .

ex:NameGroup
	a sh:PropertyGroup ;
	sh:order 0 ;
	rdfs:label "Name" .

ex:AddressGroup
	a sh:PropertyGroup ;
	sh:order 1 ;
	rdfs:label "Address" .</pre>
				<p>
					A form building application may use the information above to display instances as follows:
				</p>
				<div style="background: #f3f3f3; padding: 8px">
					<div style="font-size: 18px; color: #0000a0"><b>Name</b></div>
					<table>
						<tr>
							<td style="text-align: right; width: 160px"><b>first name:</b></td>
							<td>John</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>last name:</b></td>
							<td>Doe</td>
						</tr>
					</table>
					<div style="font-size: 18px; padding-top: 6px; color: #0000a0"><b>Address</b></div>
					<table>
						<tr>
							<td style="text-align: right; width: 160px"><b>street address:</b></td>
							<td>123 Silverado Ave</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>locality:</b></td>
							<td>Cupertino</td>
						</tr>
						<tr>
							<td style="text-align: right"><b>zip code:</b></td>
							<td>54321</td>
						</tr>
					</table>
				</div>
			</section>
		</section>
		
		<section id="validation">
			<h2>Validation and Graphs</h2>
			<p>
				A SHACL validation engine takes two RDF graphs as input, a <span class="term"><a href="#shapes-graph">shapes
				graph</a></span> and a
				<span class="term"><a href="#data-graph">data graph</a></span>, and validates the <span class="term">data graph</span>
				against the <span class="term">shapes graph</span> as described herein.
			</p>

			<div id="def-validation" class="def def-text">
				<div class="def-header">VALIDATION DEFINITION</div>
				<div class="def-text-body">
					<ul>
						<li>A <span class="term">node</span> validates against a <span class="term">shape</span> iff
							either it does not validate against some filter of the shape
							or none of the constraints in the shape produce a validation result with severity <span class="term">sh:Violation</span> for the node.
						</li>
						<li>A <span class="term">data graph</span> validates against a <span class="term">shape</span> iff
							each node that is in any of the scopes of the shape validates against the shape.
						</li>
						<li>A <span class="term">data graph</span> validates against a <span class="term">shapes graph</span> iff
							the data graph validates against each shape in the shapes graph.
						</li>
					</ul>
				</div>
			</div>

			<p>
				The validation process returns a <span class="term"><a href="#results-graph">results graph</a></span> containing all validation results.
				By default, the results graph contains validation results of all <a href="#results-severity">severity</a> levels
				but the user can request validation results with a custom minimum severity (i.e. <code>sh:Warning</code>).
				According to the definition of validation, a results graph may contain validation results but as long as none is of severity <code>sh:Violation</code> the data graph is considered valid.
				For simpler validation scenarios, SHACL validation engines should provide an additional validation interface that returns only <span class="term">VALID</span> or <span class="term">INVALID</span>.
			<p>
				During validation, the <span class="term">data graph</span> and the <span class="term">shapes graph</span> must remain unchanged, i.e. both graphs at the end of the validation must be identical to the graph at the beginning of validation.
			</p>
			<p>
				A SHACL validation engine MUST implement all constructs in the core of SHACL (Sections 2, 3, 5).
				A SHACL engine MAY not implement the other parts of SHACL.
				<br/><span class="todo">TODO sections 2 and 5 are implied by definition</span>
			</p>

			<section id="shapes-graph">
				<h3>Shapes Graph</h3>
				<p>
					The <span class="term">shapes graph</span> contains shape definitions that a data graph can be tested against.
					Shape definitions can be reusable validation components.
					For example, a set of shapes can target data under a specific schema (i.e. SKOS) and validate different data graphs that use this schema.
					It is considered as a best practice to modularize shape definitions into separate graphs and import them at validation time.
					Importing multiple shapes graphs can be achieved with the predicate predicate <a href="http://www.w3.org/TR/owl2-syntax/#Imports"><code>owl:imports</code></a>.
					SHACL validation engines SHOULD transitively follow all <a href="http://www.w3.org/TR/owl2-syntax/#Imports"><code>owl:imports</code></a> to other graphs and use the resulting union graph as shapes graph to the validation process.
				</p>
				<p>
					In addition to shape definitions, the shapes graph may contain additional information for the validation engine such as <a href="#entailment">entailment</a> directives, namespace declarations,
					<span class="todo">TODO ns declarations is an open issue, others?</span>
				</p>
				<section id="shapes-graph-invalid">
					<h4>Invalid Shapes Graphs</h4>
					<p>
						SHACL validation engines MUST reject shapes graphs that are invalid, according to the following rules.
						No validation results must be produced, but instead a system error reported by other means.
					</p>
					<p>
						The classes <code>sh:NodeConstraint</code>, <code>sh:PropertyConstraint</code> and <code>sh:InversePropertyConstraint</code> are pairwise disjoint, i.e. it is illegal to have
						shape definitions that use nodes that are instances of two or more of these classes - either explicitly stated via <code>rdf:type</code> or implicitly via their <span class="term">default value type</span>.
					</p>
					<p>
						The values of <code>sh:property</code>, <code>sh:inverseProperty</code> and <code>sh:constraint</code>
						must have a valid type for these properties (either explicitly or via their default value type).
						It is not valid to only use instances of subclasses of the three system constraint classes (e.g. <code>sh:PropertyConstraint</code>).
						For example, if a value of <code>sh:property</code> has any declared <code>rdf:type</code> triples, then <code>sh:PropertyConstraint</code> must be one of them.
					</p>
					<p>
						The values of <code>sh:constraint</code> may be instances of any subclass of <code>sh:Constraint</code>.
						If a SHACL validation engine encounters a value of <code>sh:constraint</code> that it does not know how to handle
						(e.g. because it does not support a certain extension language), it MAY produce an error or a warning, but MAY also silently ignore such constraints.
					</p>
				</section>
			</section>
			<section id="data-graph">
				<h3>Data Graph</h3>
				<p>
					The <span class="term">data graph</span> contains the RDF data that a SHACL engine can validate.
					SHACL treats it as a general RDF graph and makes no assumption if it is e.g. an RDF dataset, an in memory graph or a named graph in a remote SPARQL endpoint.
					<!-- TODO: say something about datasets / $shapesGraph -->
				</p>
				<p>
					The data graph SHOULD include all the ontology axioms related to the data and especially all the <code>rdfs:subClassOf</code> triples in order for SHACL to correctly identify class scopes and core SHACL constraints.
					If such triples are missing, the validation could report false violations or miss to report some violations.
				</p>
				<p>
					A data graph can autonomously suggest one or more shapes graph to a SHACL validation engine with the predicate <code>sh:shapesGraph</code>.
					Every value of this property is an IRI representing a shapes graph that should be used to validate the data graph.
					A SHACL validation engine MAY use such suggestions to determine which shapes graph to use for validating a data graph.
				</p>
				<p>
					In the following example, a tool may use the union of <code>ex:graph-shapes1</code> and <code>ex:graph-shapes2</code> graphs (and their <code>owl:imports</code>) as the <span class="term">shapes graph</span> when validating the given graph.
				</p>

							<pre class="example-shapes">
[] sh:shapesGraph ex:graph-shapes1 ;
	sh:shapesGraph ex:graph-shapes2 .</pre>
			</section>

			<section id="results-graph">
				<h3>Results Graph</h3>
				<span class="todo">TODO talk about the results in a higher level than sec 5</span>
			</section>
		</section>
		
		<section id="results">
			<h2>Validation Results Vocabulary</h2>
			<p>
				The output of a SHACL constraint validation process is a set of <span class="term">validation results</span>.
				SHACL includes an RDF vocabulary to represent such results together with
				structural information that may provide guidance on how to fix a violation, as well as
				human-readable messages.
			</p>
			<p>
				The validation results produced by a standards-compliant SHACL validation engine MUST be the product of validation of the <span class="term">data graph</span> only.
				Some engines MAY also report errors in the <span class="term">shapes graph</span>, but those errors MUST NOT be mixed with the data validation results using the same results vocabulary.
			</p>
			<p>
				The following code snippet represents a syntactically correct result that may have been produced by a constraint validation engine:
			</p>
			<pre class="example-results">
ex:ExampleConstraintViolation
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:MyCurrentNode ;
	sh:subject ex:MyCurrentNode ;
	sh:predicate ex:someProperty ;
	sh:object ex:someInvalidValue ;
	sh:message "Incorrect value: expected something else here." .</pre>
			<p>
				Validation results must be instances of the class <code>sh:ValidationResult</code>.
				Its superclass <code>sh:AbstractResult</code> defines the properties described in the following sub-sections.
				SHACL implementations may produce instances of other subclasses of <code>sh:AbstractResult</code>, for example
				to report successfully completed constraint checks or accumulated results.
			</p>
			<section id="results-focus-node">
				<h4>sh:focusNode</h4>
				<p>
					Validation results may have a single value for the property <code>sh:focusNode</code> to point to an
					IRI or blank node that has caused the result.
					This represents the <span class="term">focus node</span> that was validated when the validation result was produced.
				</p>
			</section>
			<section id="results-triple">
				<h4>sh:subject, sh:predicate and sh:object</h4>
				<p>
					Validation results are often caused by a single RDF triple, or a predicate in the context of a given subject or object.
					This information can be encoded via the properties <code>sh:subject</code>, <code>sh:predicate</code> and <code>sh:object</code>,
					each of which can have at most one value.
					<code>sh:predicate</code> can only be present if either <code>sh:subject</code> or <code>sh:object</code> have also been specified.
					If <code>sh:object</code> is unspecified, then the interpretation is that the result is caused by the subject/predicate combination.
					If <code>sh:subject</code> is unspecified, then the interpretation is that the result is caused by the object/predicate combination.
				</p>
			</section>
			<section id="results-source">
				<h4>sh:sourceConstraint, sh:sourceShape and sh:sourceConstraintComponent</h4>
				<p>
					Validation results may link to one <code>sh:Constraint</code> that has caused
					the result, specified via the property <code>sh:sourceConstraint</code>,
					and at the <code>sh:Shape</code> defining the constraint, via <code>sh:sourceShape</code>.
					Validation results may link to the <span class="term">constraint component</span> that caused the result
					via <code>sh:sourceConstraintComponent</code>.
				</p>
			</section>
			<section id="results-detail">
				<h4>sh:detail</h4>
				<p>
					The property <code>sh:detail</code> may link a (parent) result with one or more other
					(child) results that provide further details about the cause of the (parent) result.
					Depending on the capabilities of the constraint validation engine, this may include failures of
					nested constraints that have been evaluated via <code>sh:valueShape</code>.
				</p>
			</section>
			<section id="results-message">
				<h3>sh:message</h3>
				<p>
					Validation results may have values for the property <code>sh:message</code> to communicate
					additional textual details to humans.
					While <code>sh:message</code> may have multiple values, there SHOULD not be two values with the same language tag.
				</p>
			</section>
			<section id="results-severity">
				<h3>sh:severity</h3>
				<p>
					Each validation result must have exactly one of the following values for the property <code>sh:severity</code>.
				</p>
				<table class="term-table">
					<tr>
						<th>Severity</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><code>sh:Info</code></td>
						<td>An informative message, not a violation.</td>
					</tr>
					<tr>
						<td><code>sh:Warning</code></td>
						<td>A non-critical constraint violation indicating a warning.</td>
					</tr>
					<tr>
						<td><code>sh:Violation</code></td>
						<td>A constraint violation that should be fixed.</td>
					</tr>
				</table>
			</section>
			<section id="severity">
				<h3>Declaring the Severity of a Constraint</h3>
				<p>
					Constraints can specify their severity level using the property <code>sh:severity</code>,
					which must link to one of the severity types.  <code>sh:Violation</code> is the default if unspecified.
					Constraints based on <a href="#template-constraints">templates</a> use the <code>sh:severity</code> declared at the template itself unless overridden at the constraint.
					The following example clarifies this.
				</p>
				<pre class="example-shapes">
ex:MyShape
	a sh:Shape ;
	sh:property [
		# Violations of either minCount and datatype are produced as warnings
		sh:predicate ex:myProperty ;
		sh:minCount 1 ;
		sh:datatype xsd:string ;
		sh:severity sh:Warning ;
	] ;
	sh:property [
		# The default severity for sh:maxCount is sh:Violation
		sh:predicate ex:myProperty ;
		sh:maxCount 1 ;
	] ;
.</pre>
			</section>
		</section>
		
		<div style="padding-top: 30px">
			<h1 id="part2" style="font-size: 160%; font-weight: bold">Part 2: Advanced Features</h1>
			<p>
				Part 1 of this specification has introduced features that are built into the Core of SHACL.
				The goal of this Core was to provide a high-level vocabulary for common use cases to describe shapes.
				However, SHACL also provides mechanisms to go beyond the Core vocabulary and represent constraints and scopes with greater flexibility.
				These mechanisms are described in the sections of Part 2.
			</p>
		</div>
		
		<section id="native-constraints">
			<h2>Native Constraints</h2>
			<p>
				The property <code>sh:constraint</code> provides the most general mechanism to associate a constraint with a shape.
				The values of this property must be <span class="term">constraints</span> - instances of the class <code>sh:Constraint</code>.
				Note that the property <code>sh:property</code> SHOULD be used instead of <code>sh:constraint</code> if the constraint is a <code>sh:PropertyConstraint</code>.
				The property <code>sh:inverseProperty</code> SHOULD be used instead of <code>sh:constraint</code> if the constraint is a <code>sh:InversePropertyConstraint</code>.
			</p>
			<p>
				SHACL supports two types of general constraints:
			</p>
			<ul>
				<li>Constraints based on a high-level vocabulary (<a href="#template-constraints">templates</a>)</li>
				<li>Constraints based on a native executable (such as a SPARQL query)</li>
			</ul>
			<p>
				The following sub-sections are about the latter, while templates are covered at a later stage.
			</p>
			<section class="informative">
				<h3>An Example Native Constraint</h3>
				<p>
					For the sake of this example, we assume a data graph containing the following instances:
				</p>
				<pre class="example-data">
ex:ValidCountry
	a ex:Country ;
	ex:germanLabel "Spanien"@de .
  
ex:InvalidCountry
	a ex:Country ;
	ex:germanLabel "Spain"@en .</pre>
				<p>
					The following example illustrates the definition of a <span class="term">native constraint</span> based on a SPARQL query.
					The value of the property <code>sh:sparql</code> is a SELECT query as explained in a later <a href="#native-constraints-sparql">section</a>.
				</p>
				<pre class="example-shapes">
ex:LanguageExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:constraint [
		sh:message "Values must be literals with German language tag." ;
		sh:sparql """
			SELECT $this ($this AS ?subject) (ex:germanLabel AS ?predicate) (?value AS ?object)
			WHERE {
				$this ex:germanLabel ?value .
				FILTER (!isLiteral(?value) || !langMatches(lang(?value), "de"))
			}
			""" ;
	] .</pre>
				<p>
					The scope of the shape includes all instances of <code>ex:Country</code>.
					For those instances (represented by the variable <code>$this</code>), the SPARQL query walks through the values of <code>ex:germanLabel</code>
					and verifies that they are literals with a German language code.
					The output of the graph validation for the instances above is shown in the next example: 
				</p>
				<pre class="example-results">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:InvalidCountry ;
	sh:subject ex:InvalidCountry ;
	sh:predicate ex:focusNode ;
	sh:object "Spain"@en ;
	sh:sourceShape ex:LanguageExampleShape ;
	...
]
</pre>
				<p>
					The SPARQL query returns result set rows for all bindings of <code>?value</code> that violate the constraint.
					A validation result is produced for each row in that result set, using <code>$this</code> as the <code>sh:focusNode</code> and <code>sh:subject</code>,
					<code>ex:germanLabel</code> as <code>sh:predicate</code> and the violating value as <code>sh:object</code>.
				</p>
				<p>
					In the example above, it is assumed that the existing SHACL validation engine is capable of evaluating native constraints using SPARQL, as described in the following section.
					Additional executable languages such as JavaScript may be provided based on other sets of properties like <code>ex:javaScript</code>,
					but that is outside of the scope of this specification.
				</p>
			</section>
			<section id="native-constraints-sparql">
				<h3>SPARQL-based Native Constraints</h3>
				<p>
					Native SPARQL constraints are instances of <code>sh:SPARQLConstraint</code>, which is a subclass of <code>sh:NativeConstraint</code>, which in turn is a subclass of <code>sh:Constraint</code>.
					Native SPARQL constraints must have one value for the property <code>sh:sparql</code>.
					The SPARQL queries linked to a <span class="term">constraint</span> via <code>sh:sparql</code> must be string literals that can be parsed into legal SPARQL 1.1 queries	of the query form <code>SELECT</code>.
					Before parsing, a SHACL processor must prepend <code>PREFIX</code> statements for all namespace prefixes defined in the current <span class="term">shapes graph</span>.
				</p>
				<section id="sparql-constraints-prebound">
					<h4>Pre-bound Variables in SPARQL Constraints ($this, $shapesGraph, $currentShape)</h4>
					<p>
						The following table enumerates variables that have special meaning in SPARQL constraints.
						When SPARQL constraints are executed, the validation engine must pre-bind values for these variables.
						A definition of <span class="term">pre-binding</span> can be found in the <a href="#pre-binding">Appendix</a>.
					</p>
					<table class="term-table">
						<tr>
							<th>Variable</th>
							<th>Interpretation</th>
						</tr>
						<tr>
							<td><code>$this</code></td>
							<td>
								The <span class="term">focus node</span>.
							</td>
						</tr>
						<tr>
							<td><code style="white-space: nowrap">$shapesGraph</code></td>
							<td>
								Can be used to query the shapes graph as in <code>GRAPH $shapesGraph { ... }</code>.
								If the shapes graph is a named graph in the same dataset as the data graph then it is the IRI of the shapes graph in the dataset.
								Otherwise a SHACL validation engine would need to provide alternative binding to enable such querying of the shapes graph.
								Not all SHACL validation engines need to support this variable.
								Processors that do not support <code>$shapesGraph</code> MUST report an error if they encounter a query that references this variable.
								Use of <code>GRAPH $shapesGraph { ... }</code> should be handled with extreme caution.
								It may result in constraints that are not interoperable across different SHACL validation engines and that may not run on remote RDF datasets.
							</td>
						</tr>
						<tr>
							<td><code style="white-space: nowrap">$currentShape</code></td>
							<td>
								The currently validated shape.  Typically used in conjunction with <code>$shapesGraph</code>.
							</td>
						</tr>
					</table>
				</section>
				<section id="sparql-constraints-variables">
					<h4>Mapping of Result Variables to Validation Results</h4>
					<p>
						Each row of the result set produced by a SELECT query must be converted into one validation result resource.
						The properties of those resources are derived by the following rules, through a combination of result variables and the properties linked to the constraint itself.
						The production rules are meant to be executed from top to bottom, so that the first bound value will be used.
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Production Rules</th>
						</tr>
						<tr>
							<td><code>sh:severity</code></td>
							<td>
								<ol>
									<li>For <span class="term">template constraints</span>, the value of <code>sh:severity</code> of the constraint node (template instance)</li>
									<li>The value of <code>sh:severity</code> of the subject of the <code>sh:sparql</code> triple</li>
									<li><code>sh:Violation</code> as default</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:focusNode</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>$this</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:subject</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?subject</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:predicate</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?predicate</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:object</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?object</code></li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:message</code></td>
							<td>
								<ol>
									<li>The value of the variable <code>?message</code></li>
									<li>
										The values of <code>sh:message</code> of the subject of the <code>sh:sparql</code> triple.
										These values may reference any variable from the SELECT result variables via <code>{?varName}</code>.
										If the constraint is a template constraint, then the template's argument variables can also be used.
										The <code>{?varName}</code> blocks SHOULD be substituted with suitable string representations of the values of said variables.
									</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:sourceConstraint</code></td>
							<td>
								<ol>
									<li>The <span class="term">constraint</span> that was validated against</li>
								</ol>
							</td>
						</tr>
						<tr>
							<td><code>sh:sourceShape</code></td>
							<td>
								<ol>
									<li>The <span class="term">shape</span> that was validated against</li>
								</ol>
							</td>
						</tr>
					</table>
				</section>
				<section id="sparql-constraints-annotations">
					<h4>Injecting Annotation Properties into Validation Results</h4>
					<p>
						It is possible to inject additional <span class="term">annotation properties</span> into the validation result resources created for each row of the SELECT result sets.
						Any such property needs to be declared via a value of <code>sh:resultAnnotation</code> at the subject holding the <code>sh:sparql</code> triple.
						The values of <code>sh:resultAnnotation</code> must be IRIs or blank nodes with the following properties:
					</p>
					<table class="term-table">
						<tr>
							<th>Property</th>
							<th>Value type</th>
							<th>Count</th>
							<th>Description</th>
						</tr>
						<tr>
							<td><code>sh:annotationProperty</code></td>
							<td><code>rdf:Property</code></td>
							<td><code>1 (mandatory)</code></td>
							<td>The annotation property that shall be set</td>
						</tr>
						<tr>
							<td><code>sh:annotationVarName</code></td>
							<td><code>xsd:string</code></td>
							<td><code>0..1</code></td>
							<td>The name of the SPARQL variable to take the values from</td>
						</tr>
						<tr>
							<td><code>sh:annotationValue</code></td>
							<td></td>
							<td><code>0..unlimited</code></td>
							<td>Constant nodes that shall be used as default values</td>
						</tr>
					</table>
					<p>
						For each row of a SELECT result set, a SHACL processor must walk through the declared result annotations.
						The mapping from result annotations to SPARQL variables uses the following rules:
					</p>
					<ol>
						<li>If a <code>sh:resultAnnotation</code> defines a <code>sh:annotationVarName</code> then the validation engine must look for the variable named after the <code>sh:annotationVarName</code></li>
						<li>Otherwise, the validation engine must derive a variable name from the value of <code>sh:annotationProperty</code> using the same <a href="#template-arguments">local name mechanism</a> as described earlier</li>
					</ol>
					<p>
						If a variable name could be determined, then the validation engine must copy the bindings for the given variable into the constructed validation results for the current row.
						If the variable has no binding in the result set row, then the value of <code>sh:annotationValue</code> must be used, if present.
					</p>
					<p>
						The values of <code>sh:annotationProperty</code> must not be from the SHACL namespace, to avoid clashes with variables that are already produced by other means.
					</p>
					<p>
						Here is a slightly complex example, illustrating the use of result annotations.
					</p>
					<pre class="example-shapes">
ex:ShapeWithPathViolationExample
	a sh:Shape ;
	sh:scopeNode ex:ExampleRootResource ;
	sh:constraint [
		a sh:SPARQLConstraint ;
		sh:resultAnnotation [
			sh:annotationProperty ex:time ;
			sh:annotationVarName "time"
		] ;
		sh:sparql """
			SELECT $this ?subject (ex:property2 AS ?predicate) (?first AS ?object) ?message ?time
			WHERE {
				$this ex:property1 ?first .
				?subject ex:property2 ?first .
				FILTER isBlank(?value) .
				BIND (CONCAT("The ", "message.") AS ?message) .
				BIND (NOW() AS ?time) .
			}
			""" ;
	] .</pre>

					<pre class="example-data">
ex:ExampleRootResource
	ex:property1 ex:ExampleIntermediateResource .

ex:ExampleValueResource
	ex:property2 ex:ExampleIntermediateResource .
</pre>
					<p>
						Which produces the following validation result resource:
					</p>
					<pre class="example-results">
[
	a sh:ValidationResult ;
	sh:severity sh:Violation ;
	sh:focusNode ex:ExampleRootResource ;
	sh:subject ex:ExampleValueResource ;
	sh:predicate ex:property2 ;
	sh:object ex:ExampleIntermediateResource ;
	sh:message "The message." ;
	sh:sourceConstraint [ the blank node of the sh:constraint above ] ;
	sh:sourceShape ex:ShapeWithPathViolationExample ;
	ex:time "2015-03-27T10:58:00"^^xsd:dateTime ;  # Example
] .</pre>
				</section>
			</section>
		</section>
		
		<section id="template-constraints">
			<h2>Template Constraints</h2>
			<p>
				Native constraints in a language like SPARQL as introduced in the previous section typically provide a lot of flexibility.
				However, SPARQL-based constraints may also be hard to understand for some people, and may be repetitive.
				<span class="term">Templates</span> can be used to encapsulate and parameterize such native queries.
				<span class="term">Constraint templates</span> can be instantiated anywhere where a native constraint may appear (in particular, at <code>sh:constraint</code>).
				<span class="term">Scope templates</span> can be instantiated anywhere where a native scope may appear, at <code>sh:scope</code>.
				All of the constraint and scope types built into the SHACL Core are also represented as templates in the SHACL RDF vocabulary.
				Such templates form a high-level vocabulary that may also be directly interpreted ("hard-coded") without reliance on the fact that they are templates.
			</p>
			<p>
				Constraint templates are represented as IRI nodes that are instances of the class <code>sh:ConstraintTemplate</code>.
				Scope templates are represented as IRI nodes that are instances of the class <code>sh:ScopeTemplate</code>.
				SHACL also includes a more general superclass <code>sh:Template</code> that may be used for other kinds of templates (rules, stored queries etc).
				Well-defined, non-abstract templates must provide at least one <span class="term">body</span> using a property such as <a href="#sparql-templates"><code>sh:sparql</code></a>.
			</p>
			<section class="informative">
				<h3>An Example Template Constraint</h3>
				<p>
					The following example illustrates the definition of a constraint template based on a SPARQL query.
					It is a variation of the native example constraint from the previous section.
					That SPARQL query included two constants: the specific property <code>ex:germanLabel</code> and the language tag <code>de</code>.
					Templates make it possible to generalize such scenarios, so that constants get <a href="#pre-binding">pre-bound</a> with <span class="term">arguments</span>.
					This allows the query logic to be reused in multiple places, without having to write any new SPARQL. 
				</p>
			<pre class="example-shapes" title="Constraint template based on SPARQL">
ex:LanguageConstraint
	a sh:ConstraintTemplate ;
	rdfs:label "Language constraint" ;
	rdfs:subClassOf sh:TemplateConstraint ;
	sh:argument [
		sh:predicate ex:predicate ;
		sh:class rdf:Property ;
		sh:name "predicate" ;
		sh:description "The property to validate the values of." ;
    ] ;
	sh:argument [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values of {?predicate} must be literals with language \"{?lang}\"" ;
	sh:message "Values must be literals with language \"{?lang}\"" ;
	sh:sparql """
		SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
		WHERE {
			$this $predicate ?value .
			FILTER (!isLiteral(?value) || !langMatches(lang(?value), $lang))
		}
		""" .</pre>
				<p>
					Once a template has been defined, it can be instantiated as a constraint, as illustrated in the following example:
				</p>
				<pre id="TemplateLanguageExampleShape" class="example-shapes" title="Shape definition using ex:LanguageConstraint">
ex:TemplateLanguageExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:constraint [
		a ex:LanguageConstraint ;
		ex:predicate ex:germanLabel ;
		ex:lang "de" ;
	] ;
	sh:constraint [
		a ex:LanguageConstraint ;
		ex:predicate ex:englishLabel ;
		ex:lang "en" ;
	] .</pre>
				<p>
					The example shape above specifies that all values of <code>ex:germanLabel</code> must carry the language tag <code>de</code>
					while all values of <code>ex:englishLabel</code> must have <code>en</code> as their language.
					These details are specified via two instances of <code>ex:LanguageConstraint</code> that provide values for the arguments required by the template.
				</p>
				<p>
					The following sections introduce the properties that constraint templates may have.
					All of these properties except for <code>sh:sparql</code> are independent of SPARQL-based execution and apply
					to constraint templates based on other languages such as JavaScript too.
					A later <a href="#sparql-templates">section</a> provides additional details for SPARQL-based SHACL templates.
				</p>
			</section>
			<section id="template-arguments">
				<h3>Template Arguments</h3>
				<p>
					The arguments of a template are linked via the property <code>sh:argument</code>.
					Each argument must be an instance of <code>sh:Argument</code>, but the <code>rdf:type</code> triples of these instances can be omitted.
				</p>
				<p>
					Each <code>sh:Argument</code> must have exactly one value for the property <code>sh:predicate</code>.
					The values of <code>sh:predicate</code> must be IRIs.
					<span id="def-local-name">The <span class="term">local name</span> of a IRI is defined as the longest <a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCNAME</a>
					at the end of the IRI, not immediately preceeded by the first colon in the IRI.</span>
					The local names of the values of <code>sh:predicate</code> must fulfill the following conditions (to ensure a correct mapping from arguments into SPARQL variables is possible):
				</p>
				<ul>
					<li>The <span class="term">local name</span> must be a valid <a href="http://www.w3.org/TR/sparql11-query/#rVARNAME">SPARQL VARNAME</a></li>
					<li>There must not be any other declared <code>sh:Argument</code> for the same template (and its transitive superclasses) that has a <code>sh:predicate</code> with the same <span class="term">local name</span></li>
				</ul>
				<p>
					An <code>sh:Argument</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the argument is not mandatory.
				</p>
				<p>
					An <code>sh:Argument</code> may declare a default value via <code>sh:defaultValue</code>.
					For non-optional arguments, the validation engine must use the declared default value for template instances that do not define a value for this argument.
					Template instances can have at most one value for each argument predicate.
				</p>
				<p>
					An <code>sh:Argument</code> may declare one value for the property <code>sh:class</code> or one value for
					<code>sh:datatype</code>, similar to their counterparts in property constraints.
					Likewise, an <code>sh:Argument</code> may specify a <code>sh:NodeKind</code> via <code>sh:nodeKind</code>.
					This can be used to communicate the expected value type of the argument in template instances.
					Some implementations MAY use this information to prevent the execution of a template with invalid arguments.
				</p>
			</section>
			<section id="template-instantiation">
				<h3>Template Instantiation</h3>
				<p>
					<code>sh:Template</code> is subclass of <code>rdfs:Class</code>, which means that templates can be instantiated via <code>rdf:type</code>.
					Such <span class="term">template instances</span> can be used as values of <code>sh:constraint</code>, among others, as demonstrated in an <a href="#TemplateLanguageExampleShape">example</a> above.
				</p>
				<p>
					Template instances are called <span class="term">complete</span> when they have values for all non-optional arguments.
					Only template instances that are complete will be used - incomplete templates will be (silently) ignored during constraint validation.
				</p>
				<p>
					Constraint templates may be placed in a <code>rdfs:subClassOf</code> relationship with other templates.
					The implication of doing this is that when an instance of the superclass template is validated, then all (transitive) superclass templates will also be validated,
					assuming their arguments are <span class="term">complete</span>.
				</p>
			</section>
			<section id="template-labelTemplate">
				<h3>sh:labelTemplate</h3>
				<p>
					The property <code>sh:labelTemplate</code> can be used to suggest how instances of the template shall be rendered to humans.
					The <code>sh:labelTemplate</code> must be a string that can reference the arguments using the syntax <code>{?varName}</code>,
					where <code>varName</code> is the name of the SPARQL variable that corresponds to the argument.
					At display time, these <code>{?...}</code> blocks SHOULD be substituted with the actual values used in the template instance.
				</p>
			</section>
			<section id="template-property-constraints">
				<h3>Property Constraint Templates</h3>
				<p>
					Some constraints are about a specific property only, and SHACL provides the system properties <code>sh:property</code> and <code>sh:inverseProperty</code> for those cases.
					In order to define constraints that can be used similar to the built-in Core constraint properties such as <code>sh:minCount</code>,
					a SHACL template needs to declared to be a subclass of <code>sh:PropertyConstraint</code> (for <code>sh:property</code>) or <code>sh:InversePropertyConstraint</code> (for <code>sh:inverseProperty</code>).
					Such templates "inherit" the argument <code>sh:predicate</code>.
					This is illustrated in the following example.
				</p>
				<pre class="example-shapes" title="An example property constraint template with a shape that uses it">
ex:LanguagePropertyConstraint
	a sh:ConstraintTemplate ;
	rdfs:subClassOf sh:PropertyConstraint ;
	sh:argument [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values of {?predicate} must be literals with language \"{?lang}\"" ;
	sh:message "Values must be literals with language \"{?lang}\"" ;
	sh:sparql """
		SELECT $this ($this AS ?subject) $predicate (?value AS ?object)
		WHERE {
			$this $predicate ?value .
			FILTER (!isLiteral(?value) || !langMatches(lang(?value), $lang))
		}
		""" .

ex:TemplateLanguageWithPropertyConstraintExampleShape
	a sh:Shape ;
	sh:scopeClass ex:Country ;
	sh:property [
		a ex:LanguagePropertyConstraint ;
		sh:predicate ex:germanLabel ;
		sh:datatype rdf:langString ;
		sh:maxCount 1 ;
		ex:lang "de" ;
	] .</pre>
				<p>
					As shown above, shapes can instantiate such templates via <code>sh:property</code>
					and mix custom constraint properties such as <code>ex:lang</code> with those from the SHACL Core vocabulary, such as <code>sh:maxCount</code>.
				</p>
			</section>
			<section id="template-validation-functions">
				<h3>Templates with a sh:validationFunction</h3>
				<p>
					Constraint templates that are instances of <code>sh:PropertyValueConstraintTemplate</code> or
					<code>sh:InversePropertyValueConstraintTemplate</code> (which are subclasses of <code>sh:ConstraintTemplate</code>) do not require an executable body (such a <code>sh:sparql</code>)
					if they instead link to a <code>sh:Function</code> via the property <code>sh:validationFunction</code>.
					These so called <span class="term">validation functions</span> must take an argument with the predicate <code>sh:value</code> as its first argument
					and return either <code>true</code> or <code>false</code>.
					This validation function must be used by a constraint validation engine to construct a procedure that iterates over all values of the (possibly inverse) property,
					and then runs a filter test using the function.  If the filter returns <code>false</code> then a validation result must be produced.
					Validation functions may take additional arguments, and the validation engine must fill them with the matching arguments from the surrounding template.
					The SHACL system vocabulary contains several examples of such validation functions, e.g. <code>sh:AbstractDatatypePropertyConstraint</code>.
				</p>
				<p>
					The following example defines a constraint template using a <span class="term">validation function</span> from a <a href="#ValidationFunctions">later section</a>.
				</p>
				<pre class="example-shapes" title="Template definition using a validation function">
ex:LanguageConstraint
	a sh:PropertyValueConstraintTemplate ;
	rdfs:label "Language constraint" ;
	rdfs:subClassOf sh:TemplateConstraint ;
	sh:argument [
		sh:predicate ex:predicate ;
		sh:class rdf:Property ;
		sh:name "predicate" ;
		sh:description "The property to validate the values of." ;
    ] ;
	sh:argument [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:name "language" ;
		sh:description "The language tag, e.g. \"de\"." ;
	] ;
	sh:labelTemplate "Values of {?predicate} must be literals with language \"{?lang}\"" ;
	sh:message "Values must be literals with language \"{?lang}\"" ;
	sh:validationFunction ex:hasLanguage .</pre>
			</section>
			<section id="sparql-templates">
				<h3>SPARQL-based Constraint Templates</h3>
				<p>
					If a <code>sh:Template</code> has a value for <code>sh:sparql</code>, then the corresponding instances need to follow the same execution rules as outlined for <a href="#native-constraints-sparql">SPARQL-based Constraints</a> and <a href="#sparql-scopes">SPARQL-based Scopes</a>.
					The only difference is that the SPARQL queries need to be executed with additional <span class="term">pre-bound</span> variables, derived from the arguments of the template.
					The names of those variables must match the <a href="#def-local-name"><span class="term">local name</span></a> of the argument predicates, including the arguments defined by any (transitive) superclasses of the template.
					For example, if an argument is represented with the predicate <code>ex:myArgument</code> then the variable <code>?myArgument</code> must be <span class="term">pre-bound</span> with the value of the argument in the template instance.
				</p>
				<p>
					If a <code>sh:PropertyValueConstraintTemplate</code> has a value for <code>sh:validationFunction</code>, then the validation engine needs to produce a SPARQL query equivalent to the following pattern:
				</p>
				<pre class="algorithm">
SELECT $this ($this AS ?subject) $predicate ?object
WHERE {
	$this $predicate ?object .
	FILTER (!{validationFunction}(?object, {+ other matching arguments})) .
}</pre>
				<p>
					If a <code>sh:InversePropertyValueConstraintTemplate</code> has a value for <code>sh:validationFunction</code>, then the validation engine needs to produce a SPARQL query equivalent to the following pattern:
				</p>
				<pre class="algorithm">
SELECT $this ?subject $predicate ($this AS ?object)
WHERE {
	?subject $predicate $this .
	FILTER (!{validationFunction}(?subject, {+ other matching arguments})) .
}</pre>
			</section>
		</section>
		
		<section id="general-scopes">
			<h2>General Scopes (sh:scope)</h2>
			<p>
				In addition to the scope classes introduced in the core section, such as <code>sh:PropertyScope</code>,
				SHACL provides facilities to define custom scopes.
				Similar to constraints, scopes may either be <span class="term">native scopes</span> or be an instance of <code>sh:TemplateScope</code>.
				All this is analogous to how constraints work, but with the additional restrictions:
			</p>
			<ul>
				<li>All subjects of <code>sh:scope</code> triples must be IRIs</li>
				<li>The arguments of a scope template must not be blank nodes</li>
			</ul>
			<section id="sparql-scopes">
				<h3>SPARQL-based Scopes</h3>
				<p>
					SPARQL-based scopes must be instances of <code>sh:SPARQLScope</code>, which is a subclass of <code>sh:NativeScope</code>.
					The SPARQL queries linked to a <span class="term">scope</span> via <code>sh:sparql</code> must be of the query form <code>SELECT</code>.
					The SELECT queries must project to the result variable <code>?this</code>.
					The resulting scope consists of all distinct bindings for the variable <code>?this</code>.
				</p>
				<p>
					The SELECT queries must also be executable when converted to an ASK query and with a pre-bound value for <code>?this</code>.
					The set of bindings for <code>?this</code> that return <code>true</code> for such ASK queries must be identical to the set produced by the SELECT query.
					This constraint makes sure that validation engines can validate whether a given shape applies to a given focus node.
				</p>
				<p>
					The following example illustrates a well-formed SPARQL-based scope that produces all persons born in the USA:
				</p>
				<pre class="example-shapes" title="SPARQL-based scope example">
ex:USCitizenShape
	a sh:Shape ;
	sh:scope [
		a sh:SPARQLScope ;
		sh:sparql """
			SELECT ?this
			WHERE {
				?this a ex:Person .
				?this ex:bornIn ex:USA .
			}
			""" ;
	] ;
	sh:constraint ...</pre>
			</section>
		</section>
		
		<section id="functions">
			<h2>Functions</h2>
			<p>
				SHACL <span class="term">functions</span> define operations that produce an RDF node based on zero or more arguments and an input RDF Graph (or dataset).
				Functions can be called within SPARQL queries to encapsulate complex logic of other SPARQL queries, or executable logic in other languages such as JavaScript.
				However, the general declaration mechanism for SHACL functions is independent from SPARQL and may also be exploited by other environments.
			</p>
			<p>
				Functions must be declared as instances of the class <code>sh:Function</code>.
				Well-defined, non-abstract functions must provide at least one body property such as <a href="#sparql-functions"><code>sh:sparql</code></a>.
			</p>
			<section class="informative">
				<h3>An Example Function</h3>
				<p>
					The following example illustrates the definition of a <span class="term">function</span> based on a SPARQL query.
				</p>
				<pre class="example-shapes" title="SHACL function with a SPARQL body">
ex:exampleFunction
	a sh:Function ;
	rdfs:comment "Computes the sum of its two arguments ?arg1 and ?arg2." ;
	sh:returnType xsd:integer ;
	sh:argument [
		sh:predicate sh:arg1 ;
		sh:datatype xsd:integer ;
		sh:description "The first operand" ;
	] ;
	sh:argument [
		sh:predicate sh:arg2 ;
		sh:datatype xsd:integer ;
		sh:description "The second operand" ;
	] ;
	sh:sparql """
		SELECT ($arg1 + $arg2 AS ?result)
		WHERE {
		}
		""" .</pre>
				<p>
					Based on the declaration above, SPARQL engines with full SHACL support can install a new SPARQL function based on the SPARQL 1.1 <a href="http://www.w3.org/TR/sparql11-query/#extensionFunctions">Extensible Value Testing</a> mechanism.
					Such engines are then able to handle expressions such as <code>ex:exampleFunction(40, 2)</code>, producing <code>42</code>, as illustrated in the following SPARQL query.
				</p>
				<pre class="example-shapes" title="Call of a SHACL function in a SPARQL query">
SELECT ?subject
WHERE {
	?subject ex:myProperty ?value .
	FILTER (ex:exampleFunction(?value, 2) = 42) .
}</pre>
				<p>
					The following sections introduce the properties that all such functions may have.
					A later <a href="#sparql-functions">section</a> provides additional details for SPARQL-based SHACL functions.
				</p>
			</section>
			<section id="function-arguments">
				<h3>Function Arguments</h3>
				<p>
					The arguments of a function are linked to its <code>sh:Function</code> via the property <code>sh:argument</code>.
					Each argument must be an instance of <code>sh:Argument</code>, but their <code>rdf:type</code> triple can be omitted.
				</p>
				<p>
					Each <code>sh:Argument</code> must have exactly one value for the property <code>sh:predicate</code>.
					The values of <code>sh:predicate</code> must be IRIs, and follow the same restrictions outlined for <a href="#template-arguments">Template Arguments</a>.
					Arguments are "inherited" from the superclasses of the function.
					For example if a superclass already declares <code>sh:arg1</code> then subclasses may only define <code>sh:arg2</code> etc.
				</p>
				<p id="function-arguments-ordering">
					Arguments are ordered, corresponding to the notation of function calls in SPARQL such as
					<code>ex:exampleFunction(?arg1, ?arg2)</code>.
					The ordering of function arguments (e.g. for printing in SPARQL strings) is determined by their index.
					For each function, the indices must be 0, 1, 2 etc.  The index of each declared <code>sh:Argument</code>
					is determined as follows:
				</p>
				<ol>
					<li>The index of the built-in argument predicates <code>sh:arg1</code>, <code>sh:arg2</code> etc is their numeric name part minus 1, e.g. <code>sh:arg1</code> has index 0.</li>
					<li>The index of other argument predicates is the value of the property <code>sh:order</code> at the surrounding <code>sh:Argument</code>.</li>
					<li>Arguments that are neither of the form <code>sh:argX</code> nor have an <code>sh:order</code> are place at the end, whereby arguments that have <code>sh:optional</code> set to <code>true</code> get a higher index than non-optional arguments.</li>
				</ol>
				<p>
					Each <code>sh:Argument</code> may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the argument is not mandatory.
					If an argument has been declared optional, then all succeeding arguments must also be declared optional.
				</p>
				<p>
					Similar to <a href="#constraints-property">Property Constraints</a>, each <code>sh:Argument</code> may declare one value for the property <code>sh:datatype</code> or one value for the property <code>sh:class</code>.
					This can be used to communicate the expected value type of the argument in function calls.
					Some implementations MAY use this information to prevent the execution of a function with invalid arguments.
				</p>
			</section>
			<section id="function-returnType">
				<h3>sh:returnType</h3>
				<p>
					A function may declare a single return type via <code>sh:returnType</code>.
					This information may serve for documentation purposes, only.
					However, in some execution languages such as JavaScript, the declared <code>sh:returnType</code> may inform
					a processor how to cast a native value into an RDF value type.
				</p>
			</section>
			<section id="ValidationFunctions">
				<h3>Validation Functions</h3>
				<p>
					It is a common design pattern for functions to take a value as input and validate whether that value fulfills certain conditions or not.
					In support of this pattern, SHACL supports <span class="term">validation functions</span>, which are instances of <code>sh:Function</code> that are also subclasses of <code>sh:ValidationFunctions</code>.
					From that superclass, these functions "inherit" the (first) argument <code>sh:value</code>.
					Validation functions may define additional arguments with <code>sh:order</code> values larger than 1.
					The following example illustrates a validation function for the running example of the <a href="#template-validation-functions">section on constraint templates</a>.
				</p>
				<pre class="example-shapes" title="A validation function">
ex:hasLanguage
	a sh:Function ;
	rdfs:subClassOf sh:ValidationFunctions ;
	sh:argument [
		sh:predicate ex:lang ;
		sh:datatype xsd:string ;
		sh:order 1 ;
		sh:name "language" ;
		sh:description "The language to match against, e.g. \"de\"." ;
	] ;
	sh:returnType xsd:boolean ;
	sh:sparql """
  		ASK {
  			FILTER (isLiteral($value) &amp;&amp; langMatches(lang($value), $lang)) .
		}
		""" .</pre>
				<p>
					An example invocation of the function above is: <code>ex:hasLanguage("Spain"@en, "en")</code>, producing <code>true</code>.
				</p>
			</section>
			<section id="sparql-functions">
				<h3>SPARQL-based Functions</h3>
				<p>
					If a <code>sh:Function</code> has a value for <code>sh:sparql</code> then it can be regarded as a <span class="term">SPARQL-based function</span>.
					In the SPARQL query, the SPARQL processor needs to <span class="term">pre-bind</span> variables based on the provided arguments of the function call.
					The SPARQL query must be of type ASK or SELECT.
					For ASK queries, the function's return value is the result of the ASK query execution.
					For SELECT queries, the function's return value is the first binding of the first result variable in the result set.
					Since all other bindings will be ignored, such SELECT queries SHOULD only return a single result variable and at most one row.
				</p>
				<p class="issue" data-number="22" title="Treatment of recursive shape definitions">
					According to resolution <a href="https://www.w3.org/2015/12/16-shapes-minutes.html#resolution04">2015.12.16/04</a> shapes graphs with dependency loops are invalid and suitable limitations of this will be explored.
					Until  issue 22 is closed, definitions regarding recursion are not endorsed by the WG.
				</p>
				<p>
					<em>Recursive use of functions is undefined:</em>
					If a SPARQL-based function contains calls to other functions so that the same function with the same combination of arguments would be visited twice
					then the result of the function call is undefined.
					An implementation may either return no result (unbound) or terminate the surrounding SPARQL query with an error.
				</p>
				<p>
					Some validation engines may ignore the specified <code>sh:sparql</code> query and rely on an alternative (possibly native) implementation instead,
					as long as the functions return the same values as the specified <code>sh:sparql</code> query.
					This can be used to optimize frequently needed functions.
					Some processors may even use the <code>sh:sparql</code> query to rewrite other SPARQL queries via inlining techniques.
				</p>
			</section>
		</section>
		
		<section id="derivedValues">
			<h2>Derived Values Constraints</h2>
			<p>
				It is a common scenario that certain property values are derived from other values.
				For example, the area of a rectangle must be the product of width and height, or an uncle of a person is a male sibling of a parent.
				SHACL includes a property <code>sh:derivedValues</code> that can be used with property and inverse property constraints, to define such constraints.
				The values of <code>sh:derivedValues</code> must be instances of the class <code>sh:DerivedValuesTemplate</code>, although the <code>rdf:type</code> triple of those instances is optional.
				Each <code>sh:DerivedValuesTemplate</code> must include execution instructions such as a SPARQL query or a JavaScript snippet, that produce the values that the property is expected to have.
				This is illustrated in the following example.
			</p>
			<pre class="example-shapes" title="A property definition with derived values">
ex:RectangleShape
	a sh:Shape ;
	sh:property [
		sh:predicate ex:width ;
		sh:datatype xsd:integer ;
	] ;
	sh:property [
		sh:predicate ex:height ;
		sh:datatype xsd:integer ;
	] ;
	sh:property [
		sh:predicate ex:area ;
		sh:datatype xsd:integer ;
		sh:derivedValues [
			sh:sparql """
				$this ex:width ?width .
				$this ex:height ?height .
				BIND (?width * ?height AS ?value) .
				""" ;
		] ;
	] .</pre>
			<p>
				For SHACL processors supporting SPARQL, a <code>sh:DerivedValuesTemplate</code> can have a value of <code>sh:sparql</code>.
				The values of <code>sh:sparql</code> must be SPARQL fragments that can be turned into a valid SPARQL query by surrounding it
				with the prefix declarations from the shapes graph and <code>SELECT ?value WHERE { ... }</code>.
				These fragments can access the current focus node via the variable <code>$this</code> and must produce bindings for the variable <code>?value</code> for all derived values.
				In the example above, all values of the property <code>ex:area</code> must be all products of <code>ex:width</code> and <code>ex:height</code>.
			</p>
			<div class="def def-text">
				<div class="def-header">TEXTUAL DEFINITION</div>
				<div class="def-text-body">
					Let S be the set of nodes produces by the derived values template for the <span class="term">focus node</span>.
					A <span class="term">validation result</span> must be produced for every value of the given property <code>sh:predicate</code>
					that is not in S, and for every member of S that is not a property value.
					The produced <span class="term">validation result</span> must have the <span class="term">focus node</span> as its <code>sh:subject</code>,
					the <code>sh:predicate</code> as its <code>sh:predicate</code>, and the missing or extra value as its <code>sh:object</code>.
					(The same definition applies in the inverse direction if <code>sh:derivedValues</code> is used in an inverse property constraint.)
				</div>
			</div>
		</section>

		<section id="defaultValueType">
			<h2>Validation of shapes graphs and the sh:defaultValueType property</h2>
			<p>
				The SHACL system vocabulary itself is using shapes, allowing SHACL constraint validation to be executed on shapes graphs, e.g. to validate the syntax of shape definitions.
				However, some system properties such as <code>sh:property</code>, <code>sh:filterShape</code> and <code>sh:argument</code> may have untyped blank nodes or IRIs as their values.
				If, for example, a value of <code>sh:property</code> is a blank node that does not have any <code>rdf:type</code>, then the assumption is that the blank node has type <code>sh:PropertyConstraint</code>.
				Unless these implicit triples are present in the data graph, constraint validation will not apply the constraints defined for <code>sh:PropertyConstraint</code>.
			</p>
			<p>
				If a validation engine intends to validate the syntax of a SHACL shapes graph itself, it should (temporarily) add the missing <code>rdf:type</code> triples.
				The SHACL system vocabulary includes some helper triples using the predicate <code>sh:defaultValueType</code> to specify the default <code>rdf:type</code> for certain properties.
				For example, the default value type of <code>sh:property</code> is <code>sh:PropertyConstraint</code>.
				These triples can be queried by a pre-processor to construct the missing type triples for the affected nodes.
				SHACL includes a template <code>sh:DefaultValueTypeRule</code> which encapsulates a SPARQL query that can be used for that purpose:
			</p>
			<pre class="algorithm">
CONSTRUCT {
	?node a ?defaultValueType .
}
WHERE {
	?predicate sh:defaultValueType ?defaultValueType .
	?anySubject ?predicate ?node .
	FILTER (NOT EXISTS { ?node a ?anyType }) .
}</pre>
			<p>
				The operations in this section assume that these default value types are present in the shapes graph, e.g.
				simplifying the test whether a given node is a <code>sh:PropertyConstraint</code>.
			</p>
		</section>

		<section id="entailment">
			<h2>Entailment</h2>
			<p>
				By default, SHACL does not assume any <span class="term">entailment regime</span> [[!sparql11-entailment]] to be activated on the data graph.
				However, the property <code>sh:entailment</code> can be used to instruct a SHACL validation engine to ensure that a given entailment is activated.
				The values of <code>sh:entailment</code> must be IRIs, with common use cases covered by [[!sparql11-entailment]].
				<!--DK: we can be agnostic on the what the subject is-->
				<!--The subject of <code>sh:entailment</code> must be the IRI of the shapes graph itself.-->
			</p>
			<p>
				SHACL validation engines are not required to support any entailment regimes.
				If an entailment regime is provided in the data graph which is not supported by the engine, the validation must produce a <span class="term">failure</span>.
			</p>
		</section>
		
		<div style="padding-top: 30px">
			<h1 id="appendix" style="font-size: 160%; font-weight: bold">Appendix</h1>
		</div>
		
		<section id="terms" class="appendix">
			<h2>Glossary of Key Concepts</h2>
			<section id="term-Shape">
				<h3>Shape</h3>
				<ul>
					<li>A <span class="term">shape</span> is represented by an RDF node belonging to the class <code>sh:Shape</code>.</li>
					<li>Can have zero or more <span class="term">constraints</span>.</li>
					<li>Can have zero or more <span class="term">scopes</span> that select the nodes that the shape applies to.</li>
					<li>Can have zero or more <span class="term">filter shapes</span> that narrow down the scope of nodes that the shape applies to.</li>
				</ul>
			</section>
			<section id="term-Constraint">
				<h3>Constraint</h3>
				<ul>
					<li>A <span class="term">constraint</span> is represented by an RDF node belonging to the class <code>sh:Constraint</code>.</li>
					<li>Are either <span class="term">native constraints</span> (e.g. based on a SPARQL query) or <span class="term">template constraints</span>.</li>
					<li>Can have zero or more <span class="term">filter shapes</span> that narrow down the scope of nodes that constraint applies to.</li>
					<li>Are validated against nodes in an RDF graph (or dataset).</li>
				</ul>
			</section>
			<section id="term-Validation">
				<h3>Constraint Validation</h3>
				<ul>
					<li><span class="term">Validation</span> of <span class="term">Constraints</span> checks for the presence or absence of certain triples in an RDF graph (or dataset)</li>
					<li>Produces results, including informational results, warnings, and violations.</li> 
				</ul>
			</section>
			<section id="term-FocusNode">
				<h3>Focus Node</h3>
				<ul>
					<li>A <span class="term">Focus Node</span> is an RDF node in a graph that is passed into the <span class="term">validation</span> of a constraint.</li>
					<li>Represented using the variable <code>?this</code> in SPARQL.</li>
				</ul>
			</section>
			<section id="term-Scope">
				<h3>Scope</h3>
				<ul>
					<li>A <span class="term">Scope</span> is a declarative mechanism to select <span class="term">Focus Nodes</span> from a given graph.</li>
					<li>There are node scopes (<code>sh:scopeNode</code>), class-based scopes (<code>sh:scopeClass</code>, <code>rdf:type</code>) and general scopes (<code>sh:scope</code>).</li>
					<li>A general scope may be defined by either a SPARQL query or a template.</li>
				</ul>
			</section>
			<section id="term-FilterShape">
				<h3>Filter Shape</h3>
				<ul>
					<li>A <span class="term">filter shape</span> defines constraints that potential focus nodes need to fulfill before they are validated.</li>
					<li>A node passes a filter shape when the validation against the shape does not lead to validation results with severity <code>sh:Violation</code> or a failure.</li>
				</ul>
			</section>
			<section id="term-Template">
				<h3>Template</h3>
				<ul>
					<li>A <span class="term">Template</span> encapsulates one or more (reusable) executable bodies, e.g. a SPARQL query.</li>
					<li>May take arguments that are passed into the executable body as parameters.</li>
					<li>Can be used for Constraints or Scopes.</li>
					<li>Define a high-level vocabulary that can be shared as linked data.</li>
				</ul>
			</section>
			<section id="term-Function">
				<h3>Function</h3>
				<ul>
					<li>A <span class="term">Function</span> encapsulates one or more (reusable) executable bodies, e.g. a SPARQL query.</li>
					<li>May take arguments that are passed into the executable body as parameters.</li>
					<li>Can be used in SPARQL queries.</li>
					<li>Define a high-level vocabulary that can be shared as linked data.</li>
				</ul>
			</section>
		</section>
		
		<section id="hasShape" class="appendix">
			<h2>The Function sh:hasShape</h2>
			<div class="issue" data-number="131" title="sh:hasShape">
				The following definition is under discussion.
			</div>
			<p>
				SHACL implementations with full support of the SHACL SPARQL extension mechanism must implement
				a function <code>sh:hasShape</code>, which takes the following arguments:
			</p>
			<table class="term-table">
				<tr>
					<th style="min-width: 200px">Argument</th>
					<th>Value Type</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><code>focusNode</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The focus node to validate.</td>
				</tr>
				<tr>
					<td><code>shape</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The shape to validate the focus node against.</td>
				</tr>
				<tr>
					<td><code>shapesGraph</code></td>
					<td><code>rdfs:Resource</code></td>
					<td>The IRI of the current <span class="term">shapes graph</span>.</td>
				</tr>
			</table>
			<p>
				An example call of this function is
			</p>
			<pre>
				<code>BIND (sh:hasShape(ex:JohnDoe, ex:PersonShape, $shapesGraph) AS ?hasShape)</code>
			</pre>
			<p>
				None of the arguments can be unbound.
				The result of the <code>sh:hasShape</code> function is either <code>true</code>, <code>false</code> or <span class="term">undefined</span>:
			</p>
			<ul>
				<li><span class="term">undefined</span> if during the execution, any call to <code>sh:hasShape</code> has recursively called <code>sh:hasShape</code> with exactly the same arguments, i.e. the same node/shape/shapesGraph combination. This result indicates a failure.</li>
				<li><code>true</code> if the validation of the <code>focusNode</code> against the given <code>shape</code> produces no validation results with severity <code>sh:Violation</code>.</li>
				<li><code>false</code> if the validation of the <code>focusNode</code> against the given <code>shape</code> produces at least one validation results with severity <code>sh:Violation</code>.</li>
			</ul>
			<p>
				Note that any validation results produced inside of the <code>sh:hasShape</code> function are temporary, i.e. they are not added to the results graph of the surrounding execution environment.
				However, some implementations may add those nested validation results as annotations to the surrounding validation results, via <a href="#results-detail"><code>sh:detail</code></a>.
			</p>
		</section>
		
		<section id="pre-binding" class="appendix">
			<h2>Pre-binding of Variables in SPARQL Queries</h2>
			<p class="issue" data-number="68" title="Pre-binding of Variables in SPARQL">
				The following definition of what pre-binding means has not been approved by the WG yet,
				and is work in progress.
			</p>
			<p>
				Some features of the SPARQL-based extension mechanism of SHACL rely on the concept of <span class="term">pre-binding of variables</span>.
				Although variations of this concept are supported by several existing SPARQL implementations, there is no formal definition of pre-binding in the SPARQL 1.1 specifications.
				The goal of this section is to illustrate the effect of pre-binding to users and implementers.
				Note however that the following definition is not meant to serve as recommendation for an actual implementation strategy.
			</p>
			<p>
				<span class="term">Pre-binding</span> a variable with a value means that
				the SPARQL processor needs to evaluate all occurrences of variables with that same name
				(including occurrences in inner scopes and nested SELECT queries)
				so that they have the provided value.
				In other words, whenever a SPARQL processor evaluates a pre-bound variable, it must use the given value.
 			</p>
		</section>
		
		<section id="ack" class="appendix informative">
			<h2>Acknowledgements</h2>
			<p>
				Many people contributed to this specification, including members of the RDF Data Shapes Working Group.
				We especially thank the following:
			</p>
			<p>
				Arnaud Le Hors (chair),
				Iovka Boneva,
				Karen Coyle,
				Richard Cyganiak,
				Michel Dumontier,
				Holger Knublauch,
				Dimitris Kontokostas,
				Jose Labra,
				Peter Patel-Schneider,
				Eric Prud'hommeaux,
				Arthur Ryman (who also served as a co-editor until Feb 2016),
				Harold Solbrig,
				Simon Steyskal,
				Ted Thibodeau
			</p>
		</section>
		
	</body>
</html>
